---
layout: post
title: 📄 백준 7569번 - 토마토 (BFS)
date: 2022-07-08 15:06:37 +0900
published: true
categories: [algorithm, baekjoon]
tags: [algorithm, baekjoon, bfs]
---

## **📄 문제 소개**

![image](https://user-images.githubusercontent.com/6462456/177927546-6f7c7f6e-8fe3-4925-a8b4-22213b8c9a77.png)
![image](https://user-images.githubusercontent.com/6462456/177927579-0ae344d8-58b3-4bac-be13-362ef4c7aa12.png)
_백준 7569번 : 토마토_

링크 : [https://www.acmicpc.net/problem/7569](https://www.acmicpc.net/problem/7569)

토마토 상자는 가로, 세로, 높이를 가진 3차원 배열 형태로
토마토를 보관하고 있으며, 각 칸은 아래의 상태를 나타낸다.  

- 1 : 익은 토마토가 있는 칸
- 0 : 아직 익지 않은 토마토가 있는 칸
- -1 : 비어 있는 칸

익은 토마토는 하루마다 상/하/좌/우/앞/뒤의 주변 6개 토마토에 대해
익지 않은 토마토를 익도록 영향을 줄 수 있다.  

토마토 상자의 모든 토마토가 익기까지 최대 며칠이 걸리는지, 혹은
익을 수 없는 토마토가 존재한다면 불가능함을 출력해 주는 문제이다.  

## **📗 문제풀이 과정**

### **🧐 일단 생각해 볼 것**

초기 상태에서 며칠이 흘렀는지를 증가시키면서
토마토 상자의 모든 토마토가 익었는지를 검사하게 될 경우
가로 M, 세로 N, 높이 H가 모두 최대 10^2이므로
종료 조건을 판정하는 데에만 최대 10^6 정도의 시간이 소요된다.  

문제의 시간 제한이 1초임을 감안한다면,
전체 토마토가 익기까지 날짜가 100일만 넘어가더라도
10^8을 넘게 되므로 이는 문제에 접근하기에 좋은 방법은 아니라고 느낄 수 있다.  

뿐만 아니라, 이러한 접근의 경우 어떠한 특정 칸의 토마토에 대해
주변 익은 토마토의 영향이 중복해서 적용될 경우도
지나치게 연산량을 많이 가져가게 되므로 다른 방법을 찾아봐야 한다.  

### **😀 BFS(너비 우선 탐색)를 이용한 전략**

이 문제를 잘 생각해 보면, 어떠한 익은 토마토가 영향을 줄 수 있는 건
6개 방향의 인근 토마토들이므로, 어떠한 정점들의 관계로 문제를 구체화할 수 있다.  

또한 어떠한 토마토가 주변에 영향을 주는 데 **하루**가 걸린다는 조건과
**모든 토마토가 익는 데 며칠 걸리는지**를 구해야 하므로
초기 상태의 익은 토마토를 따라 BFS를 수행해볼 수 있다.

1. 맨 처음 큐에 초기 토마토 상자 내 익은 토마토들에 대해 visited를 체크하고
`[익은 토마토들의 좌표.., 날짜 0]`을 추가
2. 큐 맨 앞에서 요소를 빼서 주변 6개 방향의 토마토들에 대해서 판단
3. 어떠한 방향의 토마토가 비어 있는 칸이 아님과 동시에
현재 해당 토마토의 visited에 기록된 날짜보다 방금 큐에서 꺼낸 날짜가
비교 상 더 작은 경우 큐에 추가
4. 큐가 빌 때까지 2~4를 반복
5. BFS가 마무리되고 큐가 비워진 상태는 상자 내의 모든 토마토들이
줄 수 있는 영향을 모두 전달한 상태이므로
초기 상태에서의 익지 않은 토마토들에 대해서 검사  
5-1. 방문하지 않은 토마토가 있다면, -1 출력
5-2. 모든 토마토를 방문했다면 가장 오래 걸리는 날짜를 출력

위 알고리즘의 핵심은 어떤 특정 토마토의 `visited` 리스트 인덱싱이
단순 토마토의 방문 여부가 아니라 **해당 토마토가 익기까지 걸리는 날짜**를
의미한다는 점이다.  

어떤 위치의 토마토에 이미 방문했다고 해서 다시 방문하지 않도록 하는 것이 아니라,
비교해서 더 짧은 날짜에 해당 토마토가 익을 수 없으면 `visited`를
갱신해 주도록 하는 것이 알고리즘의 포인트이다.  

코드로 보면 좀 더 쉽다!!  

### **😉 코드로 나타내면..? (큐 사용)**

```python
# 토마토 상자의 가로 M, 세로 N, 쌓여진 높이 H 입력
M, N, H = map(int, input().split())

# 익은 토마토, 안 익은 토마토, 그리고 빈 칸에 대한 정보 tomatoes 3차원 리스트 입력
tomatoes = [[list(map(int, input().split())) for _ in range(N)] for _ in range(H)]

# 토마토에 대한 BFS 방문 여부 visited 3차원 리스트로 초기화
visited = [[[999999 for _ in range(M)] for _ in range(N)] for _ in range(H)]
```

토마토 상자에 대한 입력이 3차원 리스트 형태로 주어지는데, 이를 파이썬의
_list comprehension_ 으로 받아서 `tomatoes` 리스트에 저장했다.  

`visited` 리스트 같은 경우는 `tomatoes`와 같은 형태를 가지지만
충분히 큰 값(최대로 가질 수 있는 날짜 값)으로 초기화했다.  

```python
q = deque()

# 익지 않은 토마토들을 큐에 추가 및 visited 0으로 입력
for i in range(H):
    for j in range(N):
        for k in range(M):
            if tomatoes[i][j][k] == 1:
                visited[i][j][k] = 0
                q.append([i, j, k, 0])
```

큐를 초기화한 후 초기 상태의 토마토 상자에서
익은 토마토들에 대해 `visited`를 기록 후 큐에 넣어준다.  

이는 이어지는 로직에서 익은 토마토들이 자연스럽게 BFS에 의해
주변 토마토들로 탐색을 이어갈 수 있도록 하기 위함이다.  

```python
# 큐가 비어 있지 않은 동안 BFS 진행
while len(q) > 0:
    i, j, k, day = q.popleft()

    if 0 < i and tomatoes[i - 1][j][k] != -1 and visited[i - 1][j][k] > day + 1:
        visited[i - 1][j][k] = day + 1
        q.append([i - 1, j, k, day + 1])
    if i < H - 1 and tomatoes[i + 1][j][k] != -1 and visited[i + 1][j][k] > day + 1:
        visited[i + 1][j][k] = day + 1
        q.append([i + 1, j, k, day + 1])

    if 0 < j and tomatoes[i][j - 1][k] != -1 and visited[i][j - 1][k] > day + 1:
        visited[i][j - 1][k] = day + 1
        q.append([i, j - 1, k, day + 1])
    if j < N - 1 and tomatoes[i][j + 1][k] != -1 and visited[i][j + 1][k] > day + 1:
        visited[i][j + 1][k] = day + 1
        q.append([i, j + 1, k, day + 1])

    if 0 < k and tomatoes[i][j][k - 1] != -1 and visited[i][j][k - 1] > day + 1:
        visited[i][j][k - 1] = day + 1
        q.append([i, j, k - 1, day + 1])
    if k < M - 1 and tomatoes[i][j][k + 1] != -1 and visited[i][j][k + 1] > day + 1:
        visited[i][j][k + 1] = day + 1
        q.append([i, j, k + 1, day + 1])
```

BFS 탐색을 하면서 큐에 넣기 전 시점에 이미
해당 정점이 탐색 가능한 정점인지 검사하고 넣기 때문에,
큐에서 뽑고 나서는 해당 토마토에 대한 6방향 검사로 바로 이어진다.  

6방향의 토마토에 대해서 검사하는 조건의 내용은

1. 인덱싱 범위 내에 있을 것
2. 해당 칸이 비어 있지 않을 것 (!= -1)
3. **해당 칸의 토마토에 대한 기존의 익기까지의 날짜보다
새로 비교하는 익기까지의 날짜가 더 짧을 경우**

의 3가지이다.  

```python
answer = 0

for i in range(H):
    for j in range(N):
        for k in range(M):
            # 전체 토마토 상자 중 맨 처음 익지 않은 토마토들에 대해서만 검사
            if tomatoes[i][j][k] == 0:
                # 만약 익지 않은 토마토인데 초기값 그대로 남아 있는 경우는 특정 토마토가 익을 수 없는 상황으로 가정
                if visited[i][j][k] == 999999:
                    print(-1)
                    sys.exit()

                answer = visited[i][j][k] if visited[i][j][k] > answer else answer

# 정답 출력
print(answer)
```

BFS 탐색을 끝내고 전체 토마토 상자를 검사했을 때는 주어진 초기 토마토 상자의
익지 않은 상태였던 토마토들에 대해서만 고려한다.  

만약 어떤 토마토에 대한 `visited` 리스트 값이 초기화 값으로 남아 있다면
해당 토마토에 BFS가 도달하지 못했다는 의미이므로,
영원히 익을 수 없는 토마토가 존재한다는 뜻이다...  

그렇지 않은 경우는 어쨌든 가장 익는 데 오래 걸리는 토마토의 날짜가
정답이므로, 이를 찾아서 출력해 주면 된다.  

---

로직만 보면 아주 기초적인 BFS 문제들과 크게 다를 바 없는데
정점의 데이터가 3차원으로 주어졌다는 점에서 약간 헷갈려서 오래 걸렸다.  

이 문제의 **"가장 늦게 익는 토마토는 얼마 만에 익을까?"** 를
찾아내는 과정에서 토마토와 토마토 사이를 이동하듯이 추상화해
BFS를 적용할 수 있었던 점이 신선했다.  

![image](https://user-images.githubusercontent.com/6462456/177938757-f17cd96b-a40f-47ca-8a0a-f7622e01deef.png)

별개로, `visited` 리스트에 초기화하는 값을 맨 처음에는 `301`로 정했는데,
그 이유는 직육면체 형태의 3차원 상자를 떠올렸을 때 가장 오래 걸리는 거리는
한쪽 모서리에서 반대쪽 모서리라고 생각했기 때문에
어떤 토마토가 익는 데 가장 오래 걸리는 발생 가능한 상황은
`가로 + 세로 + 높이의 최대 값 = M + N + H`라고 생각했기 때문이다.  

그런데 이렇게 하면 **틀렸습니다**가 뜨기 때문에
`999999` 정도로 초기화하니 통과했다.  
왜일까...

## **💻 코드**

<script src="https://gist.github.com/poodlepoodle/48d809154d76c3cd7fc48e674b666f14.js"></script>

## **📒 연관 개념**

> -   BFS(너비 우선 탐색)