---
layout: post
title: 📄 백준 16509번 - 장군 (구현, BFS)
date: 2022-07-20 21:27:29 +0900
published: true
categories: [algorithm, baekjoon]
tags: [algorithm, baekjoon, bfs, implementation]
---

## **📄 문제 소개**

![image](https://user-images.githubusercontent.com/6462456/179978569-d5a76967-7822-4c01-8fc4-774dd0999334.png)
![image](https://user-images.githubusercontent.com/6462456/179517144-4a8be584-3ca0-428f-a9d2-c4ba5a6d35b7.png)
_백준 16509번 : 장군_

링크 : [https://www.acmicpc.net/problem/16509](https://www.acmicpc.net/problem/16509)

가로 10 * 세로 9 크기의 장기 판이 주어지고
상의 초기 위치와 왕의 초기 위치가 주어졌을 때,
상이 왕에게 도달할 수 있는 최소 이동 횟수를 출력하는 문제이다.   

## **📗 문제풀이 과정**

### **🧐 일단 생각해 볼 것**

장기에 대해서는 잘 모르지만...  
친절하게도 문제에서 상의 움직임에 대해서 설명을 해 줬기 때문에
아래와 같이 상이 다음에 움직일 수 있는 칸을 정리할 수 있다.  

1. **상/하/좌/우 방향**으로 **1칸** 먼저 움직인다.
2. 움직인 칸에서 **대각선 4방향**으로 **2칸** 움직인다.

따라서 현재 상의 위치에 따라서 장기 판에서 벗어나지만 않는다면
상은 **최대 8개 칸**에 대해 다음에 움직일 수 있음을 알 수 있다.  

이외에는 목적지에 도착하는 최소 이동 횟수를 구하라는 점에서
어렴풋이 BFS를 시도할 수 있겠다 싶다.  

### **😀 BFS(너비 우선 탐색)를 이용한 전략**

1. 맨 처음 큐에 **상의 초기 위치**와 **이동 횟수 0**을 넣고 초기화
2. 큐 맨 앞에서 요소를 빼서 판단  
2-1. 상의 위치가 왕의 위치와 같다면 이동 횟수를 return하고 종료  
2-2. 8개 방향에 대해서 visited 리스트에 기록된 값보다 현재 이동 횟수 + 1이
적다면 큐에 삽입  
3. 큐가 빌 때까지 2로 반복
4. 큐가 비었는데도 return이 발생하지 않았다면
상의 위치에서 왕의 위치에 도달할 수 있는 방법이 없다고 판단하고 -1 출력

### **😉 코드로 나타내면..? (큐 사용)**

```python
# collections.deque 사용
from collections import deque
# sys.stdin.readline() 사용
import sys

# 상의 세로 위치 sang_r, 가로 위치 sang_c 입력
sang_r, sang_c = map(int, sys.stdin.readline().rstrip().split())
# 왕의 세로 위치 wang_r, 가로 위치 wang_c 입력
wang_r, wang_c = map(int, sys.stdin.readline().rstrip().split())

# 상이 다음에 이동할 수 있는 8개 방향에 대한 offset 리스트 정의
direction = [[-3, -2], [-2, -3], [-2, 3], [-3, 2], [2, -3], [3, -2], [2, 3], [3, 2]]
```

가장 먼저 **상의 좌표**와, **왕의 좌표**를 입력받는다.  
그 다음으로 이후 BFS 수행 중 상이 이동할 수 있는 좌표를
쉽게 계산하기 위한 offset 목적의 `direction` 리스트를 정의한다.  

```python
# BFS 방문을 기록하기 위한 visited 리스트를 충분히 큰 값으로 초기화
visited = [[99999 for _ in range(9)] for _ in range(10)]

# 빈 큐 선언
q = deque()

# 상의 초기 위치를 visited에 기록하고 큐에 추가
visited[sang_r][sang_c] = 0
q.append((sang_r, sang_c, 0))
```

BFS 수행을 위해 빈 큐와 `visited` 리스트를 선언하고
`[상의 초기 위치..., 이동 횟수 0]` 을 큐에 삽입한다.  

```python
# BFS를 위한 함수 정의
def bfs():
    # 큐가 비어 있지 않을 동안 반복
    while len(q) != 0:
        # 상의 세로 위치 y, 가로 위치 x, 이동 횟수 cnt 큐에서 추출
        y, x, cnt = q.popleft()

        # 상이 왕에 도달했다면
        if y == wang_r and x == wang_c:
            # 이동 횟수 출력하고 BFS 종료
            return cnt

        ...
```

이외에는 전형적인 BFS 문제와 동일하게 큐가 비어있지 않을 동안
맨 앞의 요소를 빼서 목적 지점에 도달했는지 확인한다.  

```python
def bfs():
        ...

        moves = ((y + h, x + w) for h, w in direction if y + h >= 0 and y + h < 10 and x + w >= 0 and x + w < 9)

        # 이동할 수 있는 8개 방향에 대해
        for new_y, new_x in moves:
            # 해당 칸에 방문했던 이전 기록보다 최단 거리를 갱신할 수 있다면
            if visited[new_y][new_x] > cnt + 1:
                # 해당 칸의 최단 거리를 갱신하고 큐에 추가
                visited[new_y][new_x] = cnt + 1
                q.append((new_y, new_x, cnt + 1))

    # 만약 큐가 비었는데도 return 값이 발생하지 않았다면
    # 상이 왕에게 도달할 수 있는 방법이 없다고 판단하고 -1 return
    return -1
```

만약 목적 지점에 도착하지 못했다면 큐에서 뺀 상의 현재 위치 기준으로
이동할 수 있는 8개 방향에 대해 조사한 후,
해당 지점의 최단 이동 횟수를 갱신할 수 있는 경우 큐에 삽입한다.  

만약 큐가 빌 때까지 수행했는데 return이 발생하지 않은 경우
도달할 수 있는 방법이 없다는 의미이므로 -1을 return한다.  

## **😢 위의 전략에서 에러 발생**

```plaintext
0 2
1 4

-> 정답은 5이나 3을 출력
```

위의 코드를 작성하고 테스트 케이스를 넣자...
**통과하지 못한 테스트 케이스가 존재했다.**  

위의 테스트 케이스는 5가 출력되어야 했지만,
실제로 3이 출력되었고 디버깅을 위해 매 탐색마다
큐의 값을 지켜봤지만 BFS 수행에 에러가 있는 것은 아니었다.  

**그러다가 내가 착각한 부분을 찾아냈다...**  

![image](https://user-images.githubusercontent.com/6462456/179529804-9332288a-7f15-4513-9807-b20adc3f8c42.png)

문제에 대한 질문이 있는지 찾아보자, 나랑 똑같은 사람이 딱 하나 있었다.  
질문에 대한 답변을 보자 바로 내가 간과한 부분을 알아냈는데, 바로
**상이 이동하는 경로에 다른 기물이 존재하는 경우 이동할 수 없다는 규칙**이었다.  

> 상이 이동하는 경로에 다른 기물이 존재하는 경우 **이동 불가**

![image](https://user-images.githubusercontent.com/6462456/179530335-016a26a9-282f-41e1-976c-522a081b35d4.png)

사실 문제의 설명에서 위 규칙에 대한 내용을 읽었을 때,
다른 기물들의 갯수와 위치가 주어진다는 정보도 없는데
이 설명이 왜 있을까... 싶었지만  
**왕으로 향하는 경로를 탐색하는 와중에 왕으로 인해 경로가 제한될 가능성**을
고려하지 못했다는 것을 깨달았다....  

```plaintext
0 2
1 4

-> 정답은 5이나 3을 출력
```

그러므로 이 테스트 케이스에서도 3에 해당하는 경로는
중간에 왕이 있음에도 이동할 수 있는 경로라고 잘못 판단해 3을 출력한 것이었다.  

따라서 BFS 로직에서 상이 이동할 수 있는 다음 8개 방향의 위치에 대해서도
이를 감안한 로직 수정이 필요했다.  

### **😀 위의 규칙을 반영해 수정된 전략 및 코드**

1. 맨 처음 큐에 상의 초기 위치와 이동 횟수 0을 넣고 초기화
2. 큐 맨 앞에서 요소를 빼서 판단  
2-1. 상의 위치가 왕의 위치와 같다면 이동 횟수를 return하고 종료  
2-2. 8개 방향에 대해서 <u><strong>"경로 중간에 왕이 있지 않으면서"</strong></u>
visited 리스트에 기록된 값보다 현재 이동 횟수 + 1이 적다면 큐에 삽입  
3. 큐가 빌 때까지 2로 반복
4. 큐가 비었는데도 return이 발생하지 않았다면
상의 위치에서 왕의 위치에 도달할 수 있는 방법이 없다고 판단하고 -1 출력

8개 방향에 대해서 기존에는 최소 이동 횟수 갱신이 가능한 경우에만
이동할 수 있다고 판단했지만 이제는 각 방향으로의 경로 중간에
왕이 위치한 경우를 제외하고 큐에 삽입하도록 조건을 추가했다.  

![image](https://user-images.githubusercontent.com/6462456/179530335-016a26a9-282f-41e1-976c-522a081b35d4.png)

위 그림으로 보면 예시로 상 바로 위에 만약 왕이 위치한다면,
그 칸으로부터 대각선으로 이동할 수 있는 2가지 경로 전부가 이동할 수 없게 된다.  

따라서 기존에 좀 더 계산을 쉽게 하기 위해 `direction` 리스트를
offset으로 사용했던 방식보다
그냥 8개 방향에 대해 if문을 중첩으로 사용하는 것이
좀 더 직관적으로 구현할 수 있는 부분이라고 생각했다.  

```python
# 상이 다음에 이동할 수 있는 8개 방향에 대한
# 11시 방향부터 시계 방향으로 돌아가는 offset 리스트 정의
direction = [[-3, -2], [-3, 2], [-2, 3], [2, 3], [3, 2], [3, -2], [2, -3], [-2, -3]]

# =============== 추가된 부분 =============== #
# 상이 direction[i]번째 방향으로 이동할 때 검사해야 할
# 왕이 존재해서는 안 되는 좌표들의 offset 리스트 정의
wang_direction =\
    [[[-1, 0], [-2, -1]],\
    [[-1, 0], [-2, 1]],\
    [[0, 1], [-1, 2]],\
    [[0, 1], [1, 2]],\
    [[1, 0], [2, 1]],\
    [[1, 0], [2, -1]],\
    [[0, -1], [1, -2]],\
    [[0, -1], [-1, -2]]]
# ======================================== #
```

기존에 상이 이동할 수 있는 8개 방향으로의 좌표를 계산하기 위해 사용했던
현재 좌표 대비 이동할 좌표로의 offset 리스트 `direction`과 같은 원리로,
`direction[i]` 번째 경로로 향할 때 왕이 있으면 안 되는
좌표들의 offset을 담고 있는 `wang_direction` 리스트를 만들었다.  

```python
def bfs():
    while len(q) != 0:
        ...

        # 이동할 수 있는 8개 방향에 대해 장기 판을 벗어나지 않는 경우만 필터링
        moves = ((i, h, w) for i, (h, w) in enumerate(direction) if y + h >= 0 and y + h < 10 and x + w >= 0 and x + w < 9)

        # 장기판 내에서 이동할 수 있는 방향들에 대해서 처리
        for i, h, w in moves:
            # =============== 추가된 부분 =============== #
            # 해당 이동할 수 있는 방향으로의 경로 상에 왕이 존재하는지 검사
            wang_on_route = False
            for wang_y, wang_x in wang_direction[i]:
                # 만약 경로 상에 왕이 존재한다면,
                if y + wang_y == wang_r and x + wang_x == wang_c:
                    # 해당 경로로로는 BFS 탐색을 수행하지 않음
                    wang_on_route = True
                    break

            if wang_on_route: continue
            # ======================================== #

            # 해당 칸에 방문했던 이전 기록보다 최단 거리를 갱신할 수 있다면
            if visited[y + h][x + w] > cnt + 1:
                # 해당 칸의 최단 거리를 갱신하고 큐에 추가
                visited[y + h][x + w] = cnt + 1
                q.append((y + h, x + w, cnt + 1))

    return -1
```

그 다음으로, 상이 `direction[i]` 를 i = 0 ~ 7까지 순회하며
접근 가능한 좌표를 찾을 때 `wang_direction[i]` 내의 좌표들 중
하나라도 왕이 있는 좌표를 가리키는 경우,
해당 방향으로는 BFS 탐색을 수행하지 않도록 했다.  

추가로 짚고 넘어갈 점 하나는, 위의 코드에서 상이 이동할 수 있는
8개 방향에 대해서만 장기 판의 크기를 벗어나지 않았는지 검사하고,
왕이 있을 법한 좌표들에 대해서는 비슷한 조건을 필터링하지 않았는데,
그 이유는...  

어떤 좌표로 상이 이동할 수 있다면, **해당 경로 중간에 위치한
왕 또한 장기 판 안에 무조건 위치할 것** 을 알 수 있으며,
만약 상이 이동할 수 없는 장기 판 밖으로의 경로일 경우
어차피 왕이 경로 상에 있는지 판단할 필요가 없기 때문이다.  

![image](https://user-images.githubusercontent.com/6462456/179530335-016a26a9-282f-41e1-976c-522a081b35d4.png)

위 그림을 통해 좀 더 직관적으로 이해할 수 있는데,  
상이 이동할 수 있는 경로의 모양이 전부 직사각형의 모서리 부분처럼 위치하므로
**일단 상이 이동하려는 좌표가 벗어나는지만 검사하면**
다른 좌표들까지 장기 판을 벗어나지 않는다고 알 수 있는 구조이다.  

---

처음엔 쉬운 BFS 문제 중 하나라고 느껴졌는데,  
상이 가져갈 수 있는 움직임과 가져갈 수 없는 움직임의 조건을
BFS에 반영하려다 보니까 문제 알고리즘 분류 상
**구현**도 함께 붙어 있는 이유를 알 것 같다고 생각했다...  

## **💻 코드**

<script src="https://gist.github.com/poodlepoodle/fcaa97d51e4110ca1ef57b79e912ee2a.js"></script>

## **📒 연관 개념**

> -   BFS(너비 우선 탐색)
> -   Implementation(구현)
> -   Simulation(시뮬레이션)