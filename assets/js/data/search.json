[ { "title": "📄 백준 14890번 - 경사로 (구현)", "url": "/posts/algorithm-boj-14890/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, implementation", "date": "2022-07-21 06:35:56 +0900", "snippet": "📄 문제 소개백준 14890번 : 경사로링크 : https://www.acmicpc.net/problem/14890입력 N에 따라 N * N 크기의 정사각형 모양 지도가 주어지고,각 칸의 높이가 주어졌을 때 행 + 열 12개의 길 중에지나갈 수 있는 길의 개수를 모두 출력하는 문제이다. 모든 칸의 높이가 같음 -&gt; 지나갈 수 있음 칸의 높이가 달라질 경우 -&gt; 지나갈 수 없음그러나, 입력과 함께 주어진 L 길이 이상의 공간이 있다면경사로를 놓아 높이가 1 차이나는 칸을 잇는다면 -&gt; 지나갈 수 있음지나갈 수 있는 길에 대한 규칙은 위와 같다.다만, 위의 규칙에 따라 경사로가 이미 놓여졌다면그 칸에 경사로를 중복해서 놓을 수는 없다.예제로 들면, 3 3 2 2 2 2 는 괜찮지만,3 3 2 2 3 3 은 가운데 2 2 부분에 경사로 2개가 놓아질 수 없으므로지나갈 수 없는 길로 판정된다. (위 그림과 같은 원리)📗 문제풀이 과정🧐 일단 시도해 본 방법아주 간단하게 문제에 접근해서,하나의 길에 대해 정반대 경로는 고려할 필요 없으므로N * N 칸에 대한 경로는 총 12개를 고려해 보기로 생각했다. 첫번째 칸의 높이를 current에 저장하고 flag를 True로 세팅 나머지 N-1개 칸에 대해 반복 : new_height2-1. 새로운 칸이 이전 칸과 같으면, 넘어감2-2. 새로운 칸이 이전 칸보다 하나 높다면, 이전 칸부터 포함해서왼쪽으로 L개의 칸 같은지 검사 후, 같지 않다면 flag를 False로 세팅2-3. 새로운 칸이 이전 칸보다 하나 낮다면,새로운 칸 포함 오른쪽으로 L개의 칸 같은지 검사 후,같지 않다면 flag를 False로 세팅2-4. 이외에는 칸의 높이가 2개 이상 차이나므로 flag를 False로 세팅 N-1개 칸을 전부 탐색한 결과 flag가 True라면, 갈 수 있는 경로 1 누적한 칸씩 높이를 검사해 가며 높이가 같은 경우는 넘어가고높이가 달라지는 경우에만 경사로를 놓을 수 있는 조건인지판단해 보기로 했다.N개 칸으로 이루어진 12개 경로에 대해 각각 판단할 때,위의 규칙대로 모든 칸을 검사해 나가면N이 최대 100으로 주어질 수 있다고 했으므로경사로를 놓기 위한 L개 칸을 검증하는 과정을대충 O(N)으로 계산한다면 10^6 안에 문제를 풀 수 있겠다고 생각했다.😉 코드로 나타내면..?# sys.stdin.readline() 사용import sys# 정사각형 모양의 칸의 너비 N, 경사로의 가로 길이 L 입력N, L = map(int, sys.stdin.readline().rstrip().split())# 정사각형 모양의 칸들 높이 정보 입력maps = [list(map(int, sys.stdin.readline().rstrip().split())) for _ in range(N)]# 존재하는 12개 경로 중 지나갈 수 있는 길의 개수를 카운트하는 변수 0으로 초기화cnt = 0정사각형 모양의 칸들의 너비와 경사로의 가로 길이 등을 입력받고,정사각형 모양의 높이 지도에 대한 정보 또한 입력받는다.12개 경로에 대해 지나갈 수 있는 경로의 수를 세 주어야 하므로cnt 또한 0으로 초기화한다.# 열 방향의 N개 경로에 대해서 검사for i in range(N): # 1. 첫번째 칸의 높이를 `current`에 저장하고 current = maps[i][0] # flag를 `True`로 세팅 flag = True # 2. 나머지 N-1개 칸에 대해 반복 -&gt; `new_height` for j in range(1, N): new_height = maps[i][j] # 2-1. 새로운 칸이 이전 칸과 같으면 if new_height == current: # -&gt; 넘어감 pass ...하나의 경로는 N개의 옆으로 연결된 칸들을 검사하는 방식인데,실제로는 맨 첫 칸을 고정하고 나머지 N-1개 칸을 비교하는 방식으로 수행된다.그 과정에서 이전 칸의 높이는 maps[i][j - 1] 이며 current로,현재 칸의 높이는 maps[i][j]를 가리키며 new_height로 처리한다.가장 먼저, 이전 칸과 현재 칸의 높이가 같은 경우는 별다른 처리 없이 무시한다.# 열 방향의 N개 경로에 대해서 검사for i in range(N): ... # 2-2. 새로운 칸이 이전 칸보다 하나 높다면, elif new_height == current + 1: if j &lt; L: flag = False break # 이전 칸부터 포함해서 왼쪽으로 L개의 칸 같은지 검사 후, l_flag = True for k in range(L): # 같지 않다면 flag를 False로 세팅 if current != maps[i][j - 1 - k]: l_flag = False break if not l_flag: flag = False break ...만약 새로 마주한 칸의 높이가 1칸 높다면,이전 칸을 포함해 왼쪽으로 L개의 칸들이 같은 높이인지를 검사한다.만약 조건을 만족한다면 이는 왼쪽에 경사로를 놓을 공간이 있음을 의미한다.왼쪽으로 L개의 칸을 인덱싱하지 못하는 경우에 대해서는 예외 처리로경사로가 놓일 수 없는 경우를 추가로 고려해 준다.# 열 방향의 N개 경로에 대해서 검사for i in range(N): ... # 2-3. 새로운 칸이 이전 칸보다 하나 낮다면, elif new_height == current - 1: if j &gt; N - L: flag = False break # 새로운 칸 포함 오른쪽으로 L개의 칸 같은지 검사 후, l_flag = True for k in range(L): # 같지 않다면 flag를 False로 세팅 if new_height != maps[i][j + k]: l_flag = False break if not l_flag: flag = False break ...만약 새로운 칸이 이전 칸보다 하나 낮다면,현재 칸부터 포함해 오른쪽으로 L개의 칸들의 높이를 검사한다.# 열 방향의 N개 경로에 대해서 검사for i in range(N): ... # 2-4. 이외에는 칸의 높이가 2개 이상 차이나므로, else: # flag를 False로 세팅 flag = False break # 다음 칸을 가리키기 전에 현재 칸을 이전 칸에 덮어씌우기 current = new_height # 3. N-1개 칸을 전부 탐색한 결과 flag가 True라면, if flag: # 갈 수 있는 경로 1 누적 cnt += 1마지막으로, 위의 조건들에 속하지 않는 경우는이전 칸 대비 현재 칸의 높이가 같지 않으면서 2칸 이상 차이나는 경우이므로,경사로를 놓을 수 없다고 판단한다.마지막으로, 이렇게 판단한 조건들로 flag가 True로 세팅되어 있으면갈 수 있는 경로로,False로 세팅되어 있으면 갈 수 없는 경로로 판단해 cnt에 누적한다.# 행 방향의 N개 경로에 대해서 검사for j in range(N): # 1. 첫번째 칸의 높이를 `current`에 저장하고 current = maps[0][j] # flag를 `True`로 세팅 flag = True # 2. 나머지 N-1개 칸에 대해 반복 -&gt; `new_height` for i in range(1, N): new_height = maps[i][j] ... # 2-2. 새로운 칸이 이전 칸보다 하나 높다면, elif new_height == current + 1: if i &lt; L: flag = False break # 이전 칸부터 포함해서 왼쪽으로 L개의 칸 같은지 검사 후, l_flag = True for k in range(L): # 같지 않다면 flag를 False로 세팅 if current != maps[i - 1 - k][j]: l_flag = False break ...나머지 행 방향으로의 6개 경로 또한 열 방향으로의 경로를판단했던 로직과 똑같지만,인덱싱 변수 i와 j의 위치가 바뀐다는 점을 고려해서 코드를 작성한다.😢 위의 전략에서 오류 발생위 전략에 의해 코드를 작성해서 돌려 보자, 행 방향의 5번째 경로인3 3 2 2 3 3 을 지나갈 수 있다고 잘못 판단했다.이는 경사로가 놓일 수 있는지의 조건을 각 칸에서 좌우로 판단했을 때는당연히 놓을 수 있다고 판단했지만,실제로는 경사로 2개가 동시에 넣어지게 되는 형태이므로불가능한 경로로 판단되어야 하기 때문이다.이를 해결하기 위해 문제에서 제시한 경사로가 놓일 수 없는 경우들을모아서 보면, “한 칸에는 하나의 경사로” 만 위치할 수 있음을 알 수 있다.🧐 수정된 문제 풀이 전략위의 규칙을 추가로 반영해서 한 칸에 하나 이상의 경사로가존재할 수 없도록 하면 전략을 수정할 수 있다. 첫번째 칸의 높이를 current에 저장하고 flag를 True로 세팅 나머지 N-1개 칸에 대해 반복 -&gt; new_height2-1. 새로운 칸이 이전 칸과 같으면 -&gt; 넘어감2-2. 새로운 칸이 이전 칸보다 하나 높다면 -&gt;새로운 칸 왼쪽으로 L개의 칸 높이가 같으면서**기존에 경사로가 놓인 적 없는 칸들로만 구성되었는지**검사 후 같지 않다면 flag False로 세팅2-3. 새로운 칸이 이전 칸보다 하나 낮다면 -&gt;새로운 칸 포함 오른쪽으로 L개의 칸 높이가 같으면서**기존에 경사로가 놓인 적 없는 칸들로만 구성되었는지**검사 후 같지 않다면 flag False로 세팅2-4. 이외에는 칸의 높이가 2개 이상 차이나므로 flag False로 세팅😉 코드로 나타내면..?# 열 방향의 N개 경로에 대해서 검사for i in range(N): current = maps[i][0] flag = True # =============== 추가된 부분 =============== # # 각 칸에 하나의 경사로만 위치하도록 하기 위해 visited 리스트 선언 visited = [False for _ in range(N)] # ======================================== # ...각 칸에 경사로가 이미 놓아졌는지를 가리키기 위해서visited 리스트를 선언했다.for i in range(N): ... # 2. 나머지 N-1개 칸에 대해 반복 -&gt; `new_height` for j in range(1, N): new_height = maps[i][j] ... # 2-2. 새로운 칸이 이전 칸보다 하나 높다면, elif new_height == current + 1: ... # 이전 칸부터 포함해서 왼쪽으로 L개의 칸 같은지 검사 후, l_flag = True for k in range(L): # 같지 않다면 flag를 False로 세팅 # =============== 추가된 부분 =============== # if current != maps[i][j - 1 - k] or visited[j - 1 - k]: # ======================================== # l_flag = False break if not l_flag: flag = False break # =============== 추가된 부분 =============== # else: for k in range(L): visited[j - 1 - k] = True # ======================================== #이후 조건에서도 경사로를 놓을 수 있는지 탐색하는 과정에서해당 칸에 이미 경사로가 놓인 경우 탐색을 중지하고경사로를 놓을 수 없는 칸으로 판단한다.만약 경사로를 놓을 수 있게 된 경우는해당 칸들에 대해서 돌면서 visited 리스트의 값을 True로 세팅한다.visited 리스트는 각 경로를 이루는 N개 칸에 대해서만판단하면 되므로 N 크기로 선언해서 사용했다.이번 주에 푼 구현 문제 중 가장 많은 시간을 소요했다…구현 및 시뮬레이션 문제를 풀 때 어느 정도 조건을 설정한 후해당 조건에서 추가로 적용해 주어야 하는 동작이 생기면빠르게 코드에 반영하는 것의 중요성을 느낀 문제였다.💻 코드📒 연관 개념 Implementation(구현) " }, { "title": "📄 백준 1091번 - 카드 섞기 (구현)", "url": "/posts/algorithm-boj-1091/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, implementation", "date": "2022-07-20 23:03:42 +0900", "snippet": "📄 문제 소개백준 1091번 : 카드 섞기링크 : https://www.acmicpc.net/problem/1091플레이어는 총 3명이 있고, 카드는 N개(3의 배수)가 있다고 했을 때,섞는 방법 S에 따라 몇 번 섞어야정해진 목표 P대로 카드를 나누어 줄 수 있을지 출력하는 문제이다.또한, 아무리 섞어도 카드를 정해진 목표 P대로 나누어 줄 수 없을 때에는불가능함 또한 출력해야 한다.📗 문제풀이 과정🧐 일단 생각해 볼 것딜러가 할 수 있는 행동은 2가지가 있다. 카드를 나누어 준다. 카드를 섞는다. 카드를 나누어 준다.1의 경우, 0번째 카드가 0번째 플레이어에게,1번째 카드가 1번째 플레이어에게, 2번째 카드가 2번째 플레이어에게,…i번째 카드가 (i % 3)번째 플레이어에게 가게 된다.카드를 나누어 주는 행동은 현재 가진 카드를 그대로 전달하는 행동이기 때문에,“순서를 조작한다” 는 목적에는 카드를 나누어 주는 행동은 영향을 줄 수 없다.x번째 카드가 y번째 플레이어에게 전달되기 위해서는,애초에 (x % 3) == y인 상태로 놓여져 있어야 한다. 카드를 섞는다.“카드를 섞는다” 는 행동이야말로 딜러의 목표인“원하는 사람에게 카드가 가게 한다” 는 목적에 영향을 줄 수 있는 행동이다.주어진 S 배열이 의미하는 바는, 한 번 섞었을 때i번째 카드가 아닌, i번째에 놓인 카드가 S[i] 번째로 이동하게 된다는 뜻이다. 이 두 가지를 설명한 이유는…S 배열을 이용해 카드를 섞는 것은 맞지만,자칫 맨 처음 주어진 카드의 상태를 착각하고 시작할 수 있다는 점 때문이다.32 0 1 # P : 목표 방법1 2 0 # S : 섞는 방법문제에서 제시한 예시 1처럼 이렇게 입력 값이 주어졌을 때,초기 상태를 0 1 2 라고 두고 이 형태의 리스트를 S에 의해섞다가 P와 일치하는 상태가 되면 출력하는 문제… 라고 생각할 수 있는데이는 문제를 잘못 이해한 경우다.문제를 제대로 해석하기 위해서는딜러가 3명의 플레이어에게 놓인 3개의 레인이 있고,딜러가 마지막으로 카드를 배부할 때는i번째 레인에 놓인 카드를 단순히i번째 플레이어에게 전달하기만 하는 행동 이라고 이해해야 한다.P 배열이 위 예제처럼 2 0 1 처럼 주어졌을 때는0번째 카드가 2번째 플레이어에게 주어져야 한다는 것을 의미하는데,위의 문단과 연결지으면, 그러기 위해서는 카드가 몇 번 섞인 끝에0번째 카드가 0번째 레인에 놓여 있어야 한다는 것으로 정리할 수 있다.i번째 플레이어에게 할당된 i번째 레인은 변하지 않고,각 레인에 위치한 카드들만 서로 위치를 바꾸는 것을딜러의 “섞는다” 라는 행동으로 이해할 수만 있다면이 문제를 해결하는 로직이 P 배열을 S에 따라 몇 번 섞어서[0, 1, 2, 0, 1, 2, ... (반복)]의형태로 이끌 수 있는지를 가리킨다는 것을 이해할 수 있다. 딜러의 매 턴 행동을 나타낸 Pseudo Code 앞에 위치한 레인 0부터 레인 2까지 P의 순서로 카드를 놓는다. 놓인 카드가 0 1 2 0 1 2 ... 의 순서라면, 카드 섞기를 중단한다. 그렇지 않다면, i -&gt; S(i)의 변환을 거쳐 카드를 섞는다. 2 ~ 3을 반복한다.위 코드는 카드를 아무리 섞어도 의도한 조건으로카드를 배부할 수 없는 경우를 고려하지 않은 Pseudo Code인데,일단은 추후 고려하기로 하고 여기까지만 정리해 봤다.😉 위의 로직을 코드로 표현해 보자!# sys.stdin.readline() 사용import sys# 카드의 개수 N 입력N = int(sys.stdin.readline().rstrip())# (현재 레인에 놓인) 원래 각자 도달해야 할 플레이어 정보를 나타낸 카드들의 정보 P 입력P = list(map(int, sys.stdin.readline().rstrip().split()))# i 레인에 놓인 카드가 S(i) 레인으로 놓이게 되는 섞는 방법을 나타낸 S 입력S = list(map(int, sys.stdin.readline().rstrip().split()))카드의 갯수 N, 그리고 카드 별로 원래 가야 할 플레이어 정보를 담고 있는카드 배열 P, 그리고 카드를 섞는 방법 S를 입력받는다.# 1. 앞에 위치한 레인 0부터 레인 2까지 P의 순서로 카드를 놓는다. (이미 놓여져 있음)# 섞은 횟수를 기록하는 카운트 변수 초기화cnt = 0while True: # 2. P가 0 1 2 0 1 2 ... 의 순서라면, flag = True for i in range(N): if P[i] != i % 3: flag = False break # 카드 섞기를 중단한다. if flag: break ...가장 먼저 카드를 섞은 횟수 cnt 를 0으로 초기화한다.그 다음으로, 카드가 현재 레인들에 놓여져 있는 모양새인P 가 도달해야 하는 플레이어들에게 잘 놓여져 있는지를 검사하고,만약 그렇다면 카드 섞기를 중단하도록 조건을 건다.while True: ... # 그렇지 않다면, cards = P.copy() for idx in range(N): # 카드를 방법 S에 따라 섞는다. cards[S[idx]] = P[idx] P = cards # 섞은 횟수를 1 누적한다. cnt += 1# 정답 출력print(cnt)만약 그렇지 않다면 카드를 1번 섞어야 하는데,카드를 섞는 방법은 i번째 레인에 놓인 카드를S(i)번째 레인으로 옮기는 동작이므로,cards[S[idx]] = P[idx] 처럼 새로운 인덱스를 매핑해 주면 된다.🧐 일단 생각해 볼 것# Test Case 1-&gt; 통과 (출력 : 59)121 1 2 0 2 0 1 0 2 2 1 05 0 9 7 1 8 3 10 4 11 6 2# Test Case 2-&gt; 런타임 에러 (무한 루프)31 0 20 2 1위 로직에 의해 코드를 실행하면 Test case 1과 같은카드를 N번 섞음으로써 목표에 도달할 수 있는 경우는잘 출력이 되지만,Test Case 2와 같이 아무리 섞어도 목표대로나누어줄 수 없는 경우에 대해서는 무한 루프에 빠진다.문제의 요구 사항에 따르면 위와 같은 상황에서는-1을 출력하도록 해야 하므로,while문 안에 이런 상황을 검출할 수 있는 탈출 조건을 추가해야 한다…어떻게 하면 카드를 섞어도 목표대로 나누어 줄 수 없는 상황을 감지할 수 있을까?😉 탈출 조건 : 사이클의 발생 감지바로, 사이클이 발생하는지를 감지하면 된다.카드를 섞은 결과가 목표 배열이 아니어서 계속 섞는 상황을 상상해 보면,영원히 무한하게 카드를 섞을 수는 없으니 어느 순간카드를 섞은 결과가 이전에 섞었던 결과와 일치하는 순간이 올 것이다.따라서 카드를 섞는 행위를 한 사이클이 시작하고 다시 돌아오기까지의순서 동안만 수행하는 것이 중점이므로,맨 처음 초기에 카드가 놓여 있는 P 순서를 고려한다면카드를 섞다가 P 와 같은 순서가 된다면 탈출하는 것으로 조건을 생각해 볼 수 있다. 탈출 조건을 추가한 Pseudo Code 앞에 위치한 레인 0부터 레인 2까지 P의 순서로 카드를 놓는다. 놓인 카드가 0 1 2 0 1 2 ... 의 순서라면, 카드 섞기를 중단한다. 1번 이상 섞은 상태에서 놓인 카드가 P의 순서라면, 카드 섞기를 중단한다. 그렇지 않다면, i -&gt; S(i)의 변환을 거쳐 카드를 섞는다. 2 ~ 4을 반복한다.😙 코드에도 반영해 보자!import sysN = int(sys.stdin.readline().rstrip())P = list(map(int, sys.stdin.readline().rstrip().split()))S = list(map(int, sys.stdin.readline().rstrip().split()))# =============== 추가된 부분 =============== ## 1. 앞에 위치한 레인 0부터 레인 2까지 P의 순서로 카드를 놓는다. (이미 놓여져 있음)cards = P.copy()# ======================================== #cnt = 0우선 고치는 김에 기존에 P 리스트를 그대로 가지고 섞었던 것에서cards 리스트로 복사해서 분리하도록 하자.추후 cards가 P와 같은 순서인지를 조건으로 검사하기 위함이다.while True: # 레인 0부터 레인 N까지 놓인 카드에 대해서 조건 검사 finished = True # =============== 수정한 부분 1 =============== # cycle = True # ========================================== # for i in range(N): # 2. 놓인 카드가 0 1 2 0 1 2 ... 의 순서인지 검사 if cards[i] != i % 3: finished = False # =============== 수정한 부분 2 =============== # # 3. 놓인 카드가 P와 같은 순서인지 검사 if cards[i] != P[i]: cycle = False # ========================================== # # 카드를 목표대로 섞었다면, 섞기를 중단하고 나누어 준다. if finished: break # =============== 수정한 부분 3 =============== # # 카드 섞기에 사이클이 발생했다면, 섞기를 중단하고 -1을 출력한다. if cnt &gt; 0 and cycle: cnt = -1 break # ========================================== # # 그렇지 않다면, new_cards = cards.copy() for idx in range(N): # 카드를 방법 S에 따라 섞는다. new_cards[S[idx]] = cards[idx] cards = new_cards # 섞은 횟수를 1 누적한다. cnt += 1# 정답 출력print(cnt)앞서 카드의 배열이 목표로 하는 순서인지를 판단하기 위해O(N)의 조건 검사를 수행했는데,같은 원리로 cards가 P와 같은지를 검사해서또 다른 탈출 플래그를 하나 설정하도록 했다.추가로 이러한 탈출 조건은 한 번 이상 섞은 뒤,즉 cnt가 1 이상일 때부터 적용되도록 해야카드 섞기를 시작하기도 전에 그만두는 상황을 막을 수 있다.💻 코드📒 연관 개념 Implementation(구현) Simulation(시뮬레이션) " }, { "title": "📄 백준 16509번 - 장군 (구현, BFS)", "url": "/posts/algorithm-boj-16509/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, bfs, implementation", "date": "2022-07-20 21:27:29 +0900", "snippet": "📄 문제 소개백준 16509번 : 장군링크 : https://www.acmicpc.net/problem/16509가로 10 * 세로 9 크기의 장기 판이 주어지고상의 초기 위치와 왕의 초기 위치가 주어졌을 때,상이 왕에게 도달할 수 있는 최소 이동 횟수를 출력하는 문제이다.📗 문제풀이 과정🧐 일단 생각해 볼 것장기에 대해서는 잘 모르지만…친절하게도 문제에서 상의 움직임에 대해서 설명을 해 줬기 때문에아래와 같이 상이 다음에 움직일 수 있는 칸을 정리할 수 있다. 상/하/좌/우 방향으로 1칸 먼저 움직인다. 움직인 칸에서 대각선 4방향으로 2칸 움직인다.따라서 현재 상의 위치에 따라서 장기 판에서 벗어나지만 않는다면상은 최대 8개 칸에 대해 다음에 움직일 수 있음을 알 수 있다.이외에는 목적지에 도착하는 최소 이동 횟수를 구하라는 점에서어렴풋이 BFS를 시도할 수 있겠다 싶다.😀 BFS(너비 우선 탐색)를 이용한 전략 맨 처음 큐에 상의 초기 위치와 이동 횟수 0을 넣고 초기화 큐 맨 앞에서 요소를 빼서 판단2-1. 상의 위치가 왕의 위치와 같다면 이동 횟수를 return하고 종료2-2. 8개 방향에 대해서 visited 리스트에 기록된 값보다 현재 이동 횟수 + 1이적다면 큐에 삽입 큐가 빌 때까지 2로 반복 큐가 비었는데도 return이 발생하지 않았다면상의 위치에서 왕의 위치에 도달할 수 있는 방법이 없다고 판단하고 -1 출력😉 코드로 나타내면..? (큐 사용)# collections.deque 사용from collections import deque# sys.stdin.readline() 사용import sys# 상의 세로 위치 sang_r, 가로 위치 sang_c 입력sang_r, sang_c = map(int, sys.stdin.readline().rstrip().split())# 왕의 세로 위치 wang_r, 가로 위치 wang_c 입력wang_r, wang_c = map(int, sys.stdin.readline().rstrip().split())# 상이 다음에 이동할 수 있는 8개 방향에 대한 offset 리스트 정의direction = [[-3, -2], [-2, -3], [-2, 3], [-3, 2], [2, -3], [3, -2], [2, 3], [3, 2]]가장 먼저 상의 좌표와, 왕의 좌표를 입력받는다.그 다음으로 이후 BFS 수행 중 상이 이동할 수 있는 좌표를쉽게 계산하기 위한 offset 목적의 direction 리스트를 정의한다.# BFS 방문을 기록하기 위한 visited 리스트를 충분히 큰 값으로 초기화visited = [[99999 for _ in range(9)] for _ in range(10)]# 빈 큐 선언q = deque()# 상의 초기 위치를 visited에 기록하고 큐에 추가visited[sang_r][sang_c] = 0q.append((sang_r, sang_c, 0))BFS 수행을 위해 빈 큐와 visited 리스트를 선언하고[상의 초기 위치..., 이동 횟수 0] 을 큐에 삽입한다.# BFS를 위한 함수 정의def bfs(): # 큐가 비어 있지 않을 동안 반복 while len(q) != 0: # 상의 세로 위치 y, 가로 위치 x, 이동 횟수 cnt 큐에서 추출 y, x, cnt = q.popleft() # 상이 왕에 도달했다면 if y == wang_r and x == wang_c: # 이동 횟수 출력하고 BFS 종료 return cnt ...이외에는 전형적인 BFS 문제와 동일하게 큐가 비어있지 않을 동안맨 앞의 요소를 빼서 목적 지점에 도달했는지 확인한다.def bfs(): ... moves = ((y + h, x + w) for h, w in direction if y + h &gt;= 0 and y + h &lt; 10 and x + w &gt;= 0 and x + w &lt; 9) # 이동할 수 있는 8개 방향에 대해 for new_y, new_x in moves: # 해당 칸에 방문했던 이전 기록보다 최단 거리를 갱신할 수 있다면 if visited[new_y][new_x] &gt; cnt + 1: # 해당 칸의 최단 거리를 갱신하고 큐에 추가 visited[new_y][new_x] = cnt + 1 q.append((new_y, new_x, cnt + 1)) # 만약 큐가 비었는데도 return 값이 발생하지 않았다면 # 상이 왕에게 도달할 수 있는 방법이 없다고 판단하고 -1 return return -1만약 목적 지점에 도착하지 못했다면 큐에서 뺀 상의 현재 위치 기준으로이동할 수 있는 8개 방향에 대해 조사한 후,해당 지점의 최단 이동 횟수를 갱신할 수 있는 경우 큐에 삽입한다.만약 큐가 빌 때까지 수행했는데 return이 발생하지 않은 경우도달할 수 있는 방법이 없다는 의미이므로 -1을 return한다.😢 위의 전략에서 에러 발생0 21 4-&gt; 정답은 5이나 3을 출력위의 코드를 작성하고 테스트 케이스를 넣자…통과하지 못한 테스트 케이스가 존재했다.위의 테스트 케이스는 5가 출력되어야 했지만,실제로 3이 출력되었고 디버깅을 위해 매 탐색마다큐의 값을 지켜봤지만 BFS 수행에 에러가 있는 것은 아니었다.그러다가 내가 착각한 부분을 찾아냈다…문제에 대한 질문이 있는지 찾아보자, 나랑 똑같은 사람이 딱 하나 있었다.질문에 대한 답변을 보자 바로 내가 간과한 부분을 알아냈는데, 바로상이 이동하는 경로에 다른 기물이 존재하는 경우 이동할 수 없다는 규칙이었다. 상이 이동하는 경로에 다른 기물이 존재하는 경우 이동 불가사실 문제의 설명에서 위 규칙에 대한 내용을 읽었을 때,다른 기물들의 갯수와 위치가 주어진다는 정보도 없는데이 설명이 왜 있을까… 싶었지만왕으로 향하는 경로를 탐색하는 와중에 왕으로 인해 경로가 제한될 가능성을고려하지 못했다는 것을 깨달았다….0 21 4-&gt; 정답은 5이나 3을 출력그러므로 이 테스트 케이스에서도 3에 해당하는 경로는중간에 왕이 있음에도 이동할 수 있는 경로라고 잘못 판단해 3을 출력한 것이었다.따라서 BFS 로직에서 상이 이동할 수 있는 다음 8개 방향의 위치에 대해서도이를 감안한 로직 수정이 필요했다.😀 위의 규칙을 반영해 수정된 전략 및 코드 맨 처음 큐에 상의 초기 위치와 이동 횟수 0을 넣고 초기화 큐 맨 앞에서 요소를 빼서 판단2-1. 상의 위치가 왕의 위치와 같다면 이동 횟수를 return하고 종료2-2. 8개 방향에 대해서 \"경로 중간에 왕이 있지 않으면서\"visited 리스트에 기록된 값보다 현재 이동 횟수 + 1이 적다면 큐에 삽입 큐가 빌 때까지 2로 반복 큐가 비었는데도 return이 발생하지 않았다면상의 위치에서 왕의 위치에 도달할 수 있는 방법이 없다고 판단하고 -1 출력8개 방향에 대해서 기존에는 최소 이동 횟수 갱신이 가능한 경우에만이동할 수 있다고 판단했지만 이제는 각 방향으로의 경로 중간에왕이 위치한 경우를 제외하고 큐에 삽입하도록 조건을 추가했다.위 그림으로 보면 예시로 상 바로 위에 만약 왕이 위치한다면,그 칸으로부터 대각선으로 이동할 수 있는 2가지 경로 전부가 이동할 수 없게 된다.따라서 기존에 좀 더 계산을 쉽게 하기 위해 direction 리스트를offset으로 사용했던 방식보다그냥 8개 방향에 대해 if문을 중첩으로 사용하는 것이좀 더 직관적으로 구현할 수 있는 부분이라고 생각했다.# 상이 다음에 이동할 수 있는 8개 방향에 대한# 11시 방향부터 시계 방향으로 돌아가는 offset 리스트 정의direction = [[-3, -2], [-3, 2], [-2, 3], [2, 3], [3, 2], [3, -2], [2, -3], [-2, -3]]# =============== 추가된 부분 =============== ## 상이 direction[i]번째 방향으로 이동할 때 검사해야 할# 왕이 존재해서는 안 되는 좌표들의 offset 리스트 정의wang_direction =\\ [[[-1, 0], [-2, -1]],\\ [[-1, 0], [-2, 1]],\\ [[0, 1], [-1, 2]],\\ [[0, 1], [1, 2]],\\ [[1, 0], [2, 1]],\\ [[1, 0], [2, -1]],\\ [[0, -1], [1, -2]],\\ [[0, -1], [-1, -2]]]# ======================================== #기존에 상이 이동할 수 있는 8개 방향으로의 좌표를 계산하기 위해 사용했던현재 좌표 대비 이동할 좌표로의 offset 리스트 direction과 같은 원리로,direction[i] 번째 경로로 향할 때 왕이 있으면 안 되는좌표들의 offset을 담고 있는 wang_direction 리스트를 만들었다.def bfs(): while len(q) != 0: ... # 이동할 수 있는 8개 방향에 대해 장기 판을 벗어나지 않는 경우만 필터링 moves = ((i, h, w) for i, (h, w) in enumerate(direction) if y + h &gt;= 0 and y + h &lt; 10 and x + w &gt;= 0 and x + w &lt; 9) # 장기판 내에서 이동할 수 있는 방향들에 대해서 처리 for i, h, w in moves: # =============== 추가된 부분 =============== # # 해당 이동할 수 있는 방향으로의 경로 상에 왕이 존재하는지 검사 wang_on_route = False for wang_y, wang_x in wang_direction[i]: # 만약 경로 상에 왕이 존재한다면, if y + wang_y == wang_r and x + wang_x == wang_c: # 해당 경로로로는 BFS 탐색을 수행하지 않음 wang_on_route = True break if wang_on_route: continue # ======================================== # # 해당 칸에 방문했던 이전 기록보다 최단 거리를 갱신할 수 있다면 if visited[y + h][x + w] &gt; cnt + 1: # 해당 칸의 최단 거리를 갱신하고 큐에 추가 visited[y + h][x + w] = cnt + 1 q.append((y + h, x + w, cnt + 1)) return -1그 다음으로, 상이 direction[i] 를 i = 0 ~ 7까지 순회하며접근 가능한 좌표를 찾을 때 wang_direction[i] 내의 좌표들 중하나라도 왕이 있는 좌표를 가리키는 경우,해당 방향으로는 BFS 탐색을 수행하지 않도록 했다.추가로 짚고 넘어갈 점 하나는, 위의 코드에서 상이 이동할 수 있는8개 방향에 대해서만 장기 판의 크기를 벗어나지 않았는지 검사하고,왕이 있을 법한 좌표들에 대해서는 비슷한 조건을 필터링하지 않았는데,그 이유는…어떤 좌표로 상이 이동할 수 있다면, 해당 경로 중간에 위치한왕 또한 장기 판 안에 무조건 위치할 것 을 알 수 있으며,만약 상이 이동할 수 없는 장기 판 밖으로의 경로일 경우어차피 왕이 경로 상에 있는지 판단할 필요가 없기 때문이다.위 그림을 통해 좀 더 직관적으로 이해할 수 있는데,상이 이동할 수 있는 경로의 모양이 전부 직사각형의 모서리 부분처럼 위치하므로일단 상이 이동하려는 좌표가 벗어나는지만 검사하면다른 좌표들까지 장기 판을 벗어나지 않는다고 알 수 있는 구조이다.처음엔 쉬운 BFS 문제 중 하나라고 느껴졌는데,상이 가져갈 수 있는 움직임과 가져갈 수 없는 움직임의 조건을BFS에 반영하려다 보니까 문제 알고리즘 분류 상구현도 함께 붙어 있는 이유를 알 것 같다고 생각했다…💻 코드📒 연관 개념 BFS(너비 우선 탐색) Implementation(구현) Simulation(시뮬레이션) " }, { "title": "📄 백준 14499번 - 주사위 굴리기 (구현)", "url": "/posts/algorithm-boj-14499/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, implementation", "date": "2022-07-18 16:14:04 +0900", "snippet": "📄 문제 소개백준 14499번 : 주사위 굴리기링크 : https://www.acmicpc.net/problem/14499입력 N, M에 따라 N * M 크기의 지도가 주어지고주사위의 초기 위치가 주어졌다고 할 때,주사위가 정해진 명령 및 규칙에 따라 굴려지면서변화하는 매 순간의 주사위의 윗 면을 출력하는 문제이다.📗 문제풀이 과정🧐 일단 생각해 볼 것지도의 정보가 주어져 있다고 했을 때,주사위를 굴리는 명령에 따른 주사위의 동작을Pseudo Code로 작성해 봤다. 명령에 따른 주사위의 동작을 나타낸 Pseudo Code 주사위를 굴릴 방향을 입력받는다. 명령에 따라 주사위를 굴릴 수 있다면, 해당 칸으로 주사위를 굴린다.2-1. 주사위가 놓인 지도의 칸이 0이라면,주사위의 아랫 면의 눈금을 지도의 칸에 복사한다.2-2. 주사위가 놓인 지도의 칸이 0이 아니라면,지도의 칸에 적힌 값을 주사위의 아랫면으로 덮어 씌우고지도의 칸은 0으로 만든다.2-3. 주사위의 윗 면 눈금을 출력한다. 잘못된 명령이라면 (지도를 벗어나거나 등의) 무시한다.명령의 갯수 K가 최대 10^3으로 주어졌기 때문에,각 명령에 대해 처리할 수 있는 동작만 10^4 안에 마무리해주면문제의 시간 제한 2초 내에는 문제 없이 들어올 수 있을 것으로 판단했다.🤔 주사위의 상태 정보 저장에 대한 고찰주사위는 왼쪽 전개도와 같은 모양으로 이루어지며,지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있다고했으므로 오른쪽 그림과 같이 나타낼 수 있다.# 주사위의 현재 놓인 상태를 가리키는 6개 방향의 눈금 값front, back, top, bottom, left, right = 0, 0, 0, 0, 0, 0주사위가 놓인 상태를 가장 간단하게 표현하려면,바라보는 방향에 따라 6개의 변수로 저장할 수 있다.이러한 상황에서 주사위를 굴리는 동작은해당 방향으로 1칸만 굴리는 것을 의미하므로변화하는 4개 눈금에 대해서만 이전 주사위 상태에서가져올 수 있게끔 하는 것만으로 동작에 따른 변화를 구현할 수 있다.left, top, right, bottom = bottom, left, top, right예를 들면, 동쪽으로 굴리는 동작에 대해서는 위 그림처럼파이썬의 Tuple Swap을 이용해 간단하게 표현할 수 있다.주사위가 굴러갈 수 있는 방향이 4개 뿐임을 감안하면코드로 표현해야 하는 동작이 비교적 적다는 것을 확인할 수 있다.😉 바로 코드로 표현해 보자!# sys.stdin.readline() 사용import sys# 지도의 세로 크기 N, 가로 크기 M, 주사위의 세로 좌표 x, 가로 좌표 y, 명령의 개수 k 입력N, M, x, y, k = map(int, sys.stdin.readline().rstrip().split())# 지도의 정보를 2차원 리스트 형태로 입력maps = [list(map(int, sys.stdin.readline().rstrip().split())) for _ in range(N)]문제의 입력으로 주어지는 지도의 정보 및주사위의 위치에 대한 정보를 저장한다.# 주사위의 상태를 6개 방향에서 바라본 눈금을 저장하는 변수들 초기화# (가장 처음에 주사위에는 모든 면에 0이 적혀져 있다.)top = 0bottom = 0left = 0right = 0front = 0back = 0# k개 명령 입력 (동쪽은 1, 서쪽은 2, 북쪽은 3, 남쪽은 4)commands = list(map(int, sys.stdin.readline().rstrip().split()))주사위의 상태를 나타내는 6개 변수 (top, bottom, …, back)을모두 문제에서 제시한 초기 상태의 눈금 0으로 세팅한다.추가로, k개의 명령을 commands 리스트에 저장한다.# 1. 주사위를 굴릴 방향(direction)을 입력받는다.for direction in commands: # 2. 명령에 따라 (동쪽으로) 주사위를 굴릴 수 있다면, if direction == 1 and y &lt; M - 1: # 해당 칸으로 주사위를 굴린다. y += 1 left, top, right, bottom = bottom, left, top, right # 2. 명령에 따라 (서쪽으로) 주사위를 굴릴 수 있다면, elif direction == 2 and y &gt; 0: # 해당 칸으로 주사위를 굴린다. y -= 1 left, top, right, bottom = top, right, bottom, left # 2. 명령에 따라 (북쪽으로) 주사위를 굴릴 수 있다면, elif direction == 3 and x &gt; 0: # 해당 칸으로 주사위를 굴린다. x -= 1 front, top, back, bottom = bottom, front, top, back # 2. 명령에 따라 (남쪽으로) 주사위를 굴릴 수 있다면, elif direction == 4 and x &lt; N - 1: # 해당 칸으로 주사위를 굴린다. x += 1 front, top, back, bottom = top, back, bottom, front ...k개의 명령에 따라 해당 방향으로 지도 칸이 존재한다면주사위의 좌표를 업데이트한다.또한 4개 방향 (동, 서, 북, 남)으로의 굴려졌을 때의주사위의 눈금 변화를 반영한다. ... # 3. 잘못된 명령이라면 (지도를 벗어나거나 등의) 무시한다. else: continue # 2-1. 주사위가 놓인 지도의 칸이 0이라면, if maps[x][y] == 0: # 주사위의 아랫 면의 눈금을 지도의 칸에 복사한다. maps[x][y] = bottom # 2-2. 주사위가 놓인 지도의 칸이 0이 아니라면, else: # 지도의 칸에 적힌 값을 주사위의 아랫면으로 덮어 씌우고 bottom = maps[x][y] # 지도의 칸은 0으로 만든다. maps[x][y] = 0 # 2-3. 주사위의 윗 면 눈금을 출력한다. print(top)만약 주사위의 좌표 상 주어진 방향으로의 이동이 불가능하다면해당 명령을 무시하도록 처리해 준다.주사위가 이동하고 난 후엔 놓인 지도의 칸의 값이 0인 경우와0이 아닌 경우를 나누어 주어진 동작대로 처리한다.마지막으로는 명령이 무시된 경우를 제외하고각 명령이 끝난 시점에 주사위의 윗면 눈금을 출력한다.💻 코드📒 연관 개념 Implementation(구현) Simulation(시뮬레이션) " }, { "title": "📄 백준 14503번 - 로봇 청소기 (구현)", "url": "/posts/algorithm-boj-14503/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, implementation", "date": "2022-07-18 14:55:32 +0900", "snippet": "📄 문제 소개백준 14503번 : 로봇 청소기링크 : https://www.acmicpc.net/problem/14503입력 N, M에 따라 N * M 크기의 지도가 주어지고로봇 청소기의 위치 및 방향이 주어졌다고 했을 때,로봇 청소기가 동작을 마친 시점 기준 청소한 칸의 개수를 출력하는 문제이다.📗 문제풀이 과정🧐 일단 생각해 볼 것구현/시뮬레이션 문제를 해결할 때는 문제에서 요구한어떠한 환경의 규칙이나 물체의 동작을 Pseudo Code로 작성해 보고그대로 코딩으로 구현해 보려 하는 편인데,이번 문제 같은 경우는 로봇 청소기의 동작을 잘 정리해서문제에서 제공했기 때문에 Pseudo Code로 가공하기 편리했다. 로봇 청소기의 동작을 나타낸 Pseudo Code 현재 위치를 청소한다. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향부터 차례대로 탐색을 진행한다.2-1. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.2-2. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.2-3. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.2-4. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.N과 M이 최대 50으로 주어진 관계로 테투리 부분이 벽임을 포함하지 않아도최대 로봇 청소기가 동작하는 횟수가 10^8번 이내에는 아주 충분히이루어질 것으로 생각했기 때문에 이 문제가 구현 알고리즘인 것을 모르고실제 코테에서 마주쳤더라도 완전 탐색까지는 생각하지 않아도 되었겠다 생각했다.한 가지 신경써야 할 점은 로봇 청소기의 위치에 따른 4개 방향 좌표 검사가로봇 청소기가 바라보는 방향을 반영해서 이루어져야 한다는 것인데,이는 문제에서 초기 위치 d에 대해 값을 준 것을 힌트로 이용해서offset 변수로 현재 방향을 설정하고북 -&gt; 동 -&gt; 남 -&gt; 서 순서대로 0, 1, 2, 3 을 할당한 후코드로 표현했다.😉 바로 코드로 표현해 보자!# sys.stdin.readline() 사용import sys# 방의 세로 크기 N, 가로 크기 M 입력N, M = map(int, sys.stdin.readline().rstrip().split())# 로봇 청소기의 세로 좌표 r, 가로 좌표 c, 초기 방향 d 입력r, c, d = map(int, sys.stdin.readline().rstrip().split())# 방의 비어있는 칸과 막혀 있는 칸에 대한 정보 입력maps = [list(map(int, sys.stdin.readline().rstrip().split())) for _ in range(N)]# 방의 각 칸의 청소(방문) 여부를 기록하기 위한 cleaned 리스트 선언cleaned = [[False for _ in range(M)] for _ in range(N)]입력으로 주어지는 정보들을 잘 저장해 둔다.방의 칸들에 대한 정보를 저장함과 동시에방문 여부를 저장하는 리스트도 함께 초기화한다.# 바라보는 방향에 따른 좌표 계산 쉽게 하기 위한 방향 설정front = [[-1, 0], [0, 1], [1, 0], [0, -1]]back = [[1, 0], [0, -1], [-1, 0], [0, 1]]left = [[0, -1], [-1, 0], [0, 1], [1, 0]]# 로봇 청소기가 바라보는 초기 방향 -&gt; offset 변수offset = d# 현재 위치 r, c에 대해 사용 예시...# 현재 위치 r, c일 때 바라보는 앞 방향 좌표maps[r + front[offset][0]][c + front[offset[1]]]# 현재 위치 r, c일 때 바라보는 왼쪽 방향 좌표maps[r + left[offset][0]][c + front[offset[1]]]위에서도 언급했듯이 로봇 청소기의 현재 위치를 기준으로바라보는 방향까지 고려해 주위 칸들의 좌표를 계산하고자 할 때좀 더 쉽게 추상화하기 위해 offset 변수를 사용했다.이렇게 offset 변수를 사용할 때의 장점은% 연산자를 통해 Rotation 동작을 관리하기 편리하다는 점인데,예를 들면 왼쪽 방향으로 돌아가는 동작에 대해offset = (offset + 4 - 1) % 4 와 같이 간단하게 처리할 수 있다.# 로봇 청소기의 작동 과정flag = Truewhile True: # 1. 현재 위치를 청소한다. if flag: cleaned[r][c] = True # 2. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향부터 차례대로 탐색을 진행한다. flag = False for _ in range(4): # 2-1. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, if cleaned[r + left[offset][0]][c + left[offset][1]] == False and \\ maps[r + left[offset][0]][c + left[offset][1]] != 1: # 그 방향으로 회전한 다음 offset = (offset + 3) % 4 # 한 칸을 전진하고 1번부터 진행한다. r, c = r + front[offset][0], c + front[offset][1] flag = True break # 2-2. 왼쪽 방향에 청소할 공간이 없다면, else: # 그 방향으로 회전하고 2번으로 돌아간다. offset = (offset + 4 - 1) % 4 # 이번에 도달한 칸이 청소할 수 있는 칸이면 flag가 True if flag: continue ...실제 로봇 청소기의 동작에 대한 부분은위에서 작성한 Pseudo Code에 따라 그대로 코드로 표현했다.2-4번의 조건에 의해 동작을 멈추는 경우 break를 사용할 수 있으므로기본적인 동작은 무한 루프로 이루어지도록 했다.추가적으로 청소할 수 있는 칸을 찾아서 이동하는 경우에는이동한 후 청소를 해야 하지만,네 방향 모두 청소가 되어 있거나 막혀 있어서 후진하는 경우에는청소를 생략하고 바로 2번에 따른 탐색을 이어가야 하므로이에 따른 동작을 분리해서 수행하기 위해 flag 변수를 사용해서 나타냈다.(flag가 True면 이동한 후 청소하도록 함)while True: ... # 2-3. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, if maps[r + back[offset][0]][c + back[offset][1]] != 1: # 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다. r, c = r + back[offset][0], c + back[offset][1] continue # 2-4. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 else: # 작동을 멈춘다. break# 방 안의 모든 칸에 대해 청소한 칸의 개수를 검사cnt = 0for i in range(N): cnt += cleaned[i].count(True)# 정답 출력print(cnt)4개 방향에 따른 탐색 끝에 후진하거나 동작을 종료하는 경우에 대해서도Pseudo Code를 그대로 표현했다.마지막으로 동작을 끝내고 나면 간단하게 cleaned의 모든 칸을 검사하면서True로 표시된 칸의 개수를 세서 출력하도록 했다.while True: ... for i in range(N): for j in range(M): if i == r and j == c: if offset == 0: print('^', end=' ') elif offset == 1: print('&gt;', end=' ') elif offset == 2: print('v', end=' ') elif offset == 3: print('&lt;', end=' ') elif maps[i][j] == 1: print('#', end=' ') elif cleaned[i][j]: print('X', end = ' ') else: print(' ', end = ' ') print() print() input() # 너무 휙휙 넘어가지 않게 일시정지 용도 ...추가로, Pseudo Code를 실제 파이썬 코드로 표현하는 과정에서로봇 청소기의 동작이 의도와 다르게 이루어지는 경우버그를 잡아내기 쉽게 하기 위해서 위와 같이 게임처럼로봇 청소기가 방 안을 이동하는 모습을 확인해 볼 수 있도록 했는데,실제 코딩 테스트에서 이렇게 할 일은 시간 관계 상절대 없을 것을 염두에 두자…📖 참고한 테스트 케이스 모음5 51 2 31 1 1 1 11 0 0 0 11 0 1 0 11 0 0 0 11 1 1 1 1정답 : 85 52 1 01 1 1 1 11 0 1 0 11 0 1 0 11 0 0 0 11 1 1 1 1정답 : 67 72 2 21 1 1 1 1 1 11 0 0 0 0 0 11 0 0 1 0 0 11 0 0 1 0 0 11 0 0 1 0 0 11 0 0 0 0 0 11 1 1 1 1 1 1정답 : 217 74 2 11 1 1 1 1 1 11 0 0 0 1 0 11 0 1 1 0 0 11 0 0 0 0 1 11 0 0 1 0 0 11 0 0 0 0 0 11 1 1 1 1 1 1정답 : 119 77 3 01 1 1 1 1 1 11 0 1 0 1 0 11 0 1 0 1 0 11 0 0 0 0 0 11 0 0 1 0 0 11 0 0 1 1 0 11 0 0 1 0 0 11 0 0 0 0 0 11 1 1 1 1 1 1정답 : 259 73 4 21 1 1 1 1 1 11 0 1 0 1 0 11 0 0 0 0 0 11 0 0 0 0 0 11 0 0 1 1 0 11 0 0 0 1 0 11 1 0 1 1 1 11 0 0 0 0 0 11 1 1 1 1 1 1정답 : 179 76 2 11 1 1 1 1 1 11 0 1 0 1 0 11 0 1 0 0 0 11 0 1 0 1 0 11 0 1 1 1 1 11 0 0 0 0 0 11 0 0 1 1 0 11 0 0 0 0 0 11 1 1 1 1 1 1정답 : 13💻 코드📒 연관 개념 Implementation(구현) " }, { "title": "📄 백준 4179번 - 불! (BFS)", "url": "/posts/algorithm-boj-4179/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, bfs", "date": "2022-07-09 21:33:19 +0900", "snippet": "📄 문제 소개백준 4179번 : 불!링크 : https://www.acmicpc.net/problem/4179주어진 2차원 형태의 미로에서 지훈이의 위치와 불의 초기 위치가 주어졌을 때,불이 퍼져나가는 동안 지훈이가 불을 피해 미로를 탈출할 수 있는최소 거리를 출력해 주는 문제이다.만약 미로의 구조 상 지훈이가 탈출하지 못하고 불에 타게 되면그에 따라 예외 출력도 해 주어야 한다… ’#’ : 벽 ’.’ : 지훈이와 불 모두 지나갈 수 있음 ‘J’ : 지훈이의 초기 위치 ‘F’ : 불의 초기 위치R * C 크기의 미로에 대한 입력은 위와 같은 문자들로 해당 칸의 상태를 나타내며,만약 지훈이가 불을 피해 미로의 가장자리에 위치하는 경우다음 타이밍에 미로를 탈출할 수 있다고 가정한다.중요한 점은, “J는 미로에서 하나만 주어진다”는 말로 미루어 보아불을 가리키는 F는 여러 개 주어질 수 있다는 점이다.📗 문제풀이 과정🧐 일단 생각해 볼 것입력으로 주어진 미로의 가로와 세로가 각각 최대 10^3으로 주어지므로미로의 모든 칸을 탐색하는 데는 10^6만큼의 시간이 소요된다.만약 매 시간마다 불이 퍼져 나가는 것과 지훈이가 이동할 수 있는 칸을동시에 고려하며 미로에 반영하는 경우,초기 미로에 불이 10^2개만 놓여지더라도문제의 시간 제한 1초 내에 들어올 수 없다.😀 BFS(너비 우선 탐색)를 이용한 전략문제를 간단히 보기 위해서 지훈이가 아닌, 불이 퍼져 나가는 모습만 살펴보자.불은 4방향으로 퍼져 나갈 수 있으며, 불이 퍼져 나가는 것을 BFS로 나타내는 경우특정 칸에 방문한 기록을 나타낼 때 해당 칸에 불이 도달하는 데 걸리는 시간으로 기록하며 나갈 수 있을 것이다.이와 동시에 어떠한 칸에 이미 불이 도달했더라도그보다 더 빨리 불이 도달할 수 있는 시간을 갖고 접근할 수 있다면해당 칸의 방문 기록을 더 짧은 시간으로 갱신할 수 있다.불에 대한 BFS를 수행한 후 방문 기록 배열은 미로의 칸들에 대해불이 해당 칸에 도달하는 데 얼마의 최소 시간이 걸리는지를나타내고 있을 것이다.지훈이도 마찬가지로 4방향으로 이동 가능하지만어떤 칸에 불이 붙을 예정이라면 만약 지훈이가 불보다 해당 칸에먼저 도달할 수 있다면 그 칸을 지나갈 수 있고,아니라면 해당 칸은 탈출 경로에 포함될 수 없는 칸이 된다.따라서 지훈이의 위치를 가지고 다시 BFS를 수행하는 동시에지훈이가 갈 수 있는 칸에 하나의 조건, 바로“지훈이가 해당 칸에 도달할 수 있는 BFS 레벨보다해당 칸에 불이 붙기까지의 시간이 작을 경우” 에만 지나갈 수 있도록 해서미로의 가장자리에 도달할 수 있는지의 여부로 문제를 풀 수 있다. 미로에 대한 정보 및 지훈이의 초기 위치, 불(들)의 초기 위치를 입력받음 [불의 초기 위치, 도달 시간]을 큐에 삽입 큐 맨 앞에서 요소를 뺌3-1. 해당 칸에 도달한 시간을 갱신3-2. 해당 칸으로부터 이동할 수 있는 주변 칸 중에도달할 수 있는 시간이 더 짧게 되는 경우만 큐에 추가3-3. 큐가 빌 때까지 위 과정을 반복 [지훈이의 초기 위치, 도달 시간]을 큐에 삽입 큐 맨 앞에서 요소를 뺌5-1. 해당 칸이 미로의 가장자리라면 현재 도달한 시간 + 1을 정답으로 출력5-2. 그렇지 않다면 현재 칸으로부터 이동 가능한 칸 중에해당 칸에 불이 붙기까지의 시간보다 현재 시간이 더 짧은 경우 큐에 추가5-3. 큐가 빌 때까지 위 과정을 반복 5를 반복한 후 정답이 출력되지 않고 큐가 비었다면 탈출 불가 출력😉 코드로 나타내면..? (큐 사용)# collections.deque 사용from collections import deque# sys.stdin.readline() 사용import sys# 미로의 행 R, 열 C 입력R, C = map(int, sys.stdin.readline().rstrip().split())# 미로 정보 2차원 리스트로 입력maze = [list(sys.stdin.readline().rstrip()) for _ in range(R)]미로에 대한 정보를 2차원 리스트로 입력받음# 지훈이와 불에 대한 좌표 초기화jihoon = Nonefires = []# 미로의 모든 칸을 순회하며 지훈이와 불에 대한 위치를 저장for i in range(R): for j in range(C): if maze[i][j] == 'J': jihoon = (i, j) elif maze[i][j] == 'F': fires.append((i, j))# BFS 방문 기록을 위한 visited 2차원 리스트를 충분히 큰 값으로 초기화visited = [[10**6 for _ in range(C)] for _ in range(R)]미로 정보를 입력받고 나서는 BFS 초기 세팅에 용이하도록지훈이의 위치와 불(들)의 위치를 따로 저장해 둠..BFS에 따른 방문 기록을 저장할 visited 리스트를충분히 큰 값인 10^6으로 초기화하는 이유는BFS를 통해 어떠한 칸에 불이 도달하는 경우 더 짧은 시간으로 갱신하기 위함이다…이렇게 하면 불이 퍼져나가는 것을 BFS로 기록할 때 “불이 도달하지 못한 곳은초기화 값 그대로 남아 지훈이가 해당 칸들로 이동하는 데 제한이 없다” 라고생각할 수도 있지만… 불이 갈 수 없는 곳은 지훈이도 갈 수 없으며큐에 넣을 때 해당 칸이 막혀 있는 칸(#)이 아닌지를 먼저 검사하기 때문에 ㄱㅊ다.def bfs_fire(): global visited # 큐 초기화 q = deque() # 초기 미로에 존재하는 불들에 대해서 도달 시간 기록 후 큐에 삽입 for i, j in fires: visited[i][j] = 0 q.append((i, j, 0)) # 큐가 비어 있지 않을 동안 반복 while len(q) != 0: # 맨 앞 요소(불의 위치..., 도달 시간)을 추출 i, j, cnt = q.popleft() # 불이 갈 수 있는 4개 방향에 대해 조건 검사 # 조건 1. 미로의 인덱스를 벗어나지 않을 것 # 조건 2. 막혀 있는 칸(#)이 아닐 것 # 조건 3. 해당 칸에 불이 붙는 더 짧은 시간을 갱신할 수 있는 경우 # 위 조건에 부합한다면 해당 칸에 대해 방문 기록 후 큐에 삽입 if i &gt; 0 and maze[i - 1][j] != '#' and visited[i - 1][j] &gt; cnt + 1: visited[i - 1][j] = cnt + 1 q.append((i - 1, j, cnt + 1)) if i &lt; R - 1 and maze[i + 1][j] != '#' and visited[i + 1][j] &gt; cnt + 1: visited[i + 1][j] = cnt + 1 q.append((i + 1, j, cnt + 1)) if j &gt; 0 and maze[i][j - 1] != '#' and visited[i][j - 1] &gt; cnt + 1: visited[i][j - 1] = cnt + 1 q.append((i, j - 1, cnt + 1)) if j &lt; C - 1 and maze[i][j + 1] != '#' and visited[i][j + 1] &gt; cnt + 1: visited[i][j + 1] = cnt + 1 q.append((i, j + 1, cnt + 1))BFS는 총 2번 진행하는데,먼저 불이 미로의 칸들에 도달하는 최소 시간을 기록하는 bfs_fire() 수행 후지훈이의 이동을 나타내는 bfs_jihoon을 수행한다.bfs_fire에서는 BFS로 도달하는 칸들에 대해더 짧은 시간으로 갱신 가능한 경우 큐에 추가하며 진행한다.def bfs_jihoon(): global visited # 큐 초기화 q = deque() # 지훈이의 초기 위치 받아옴 i, j = jihoon # 지훈이의 초기 위치 방문 기록하고 큐에 삽입 visited[i][j] = 0 q.append((i, j, 0)) # 큐가 비어 있지 않을 동안 반복 while len(q) != 0: # 맨 앞 요소(지훈이의 위치..., 도달 시간)을 추출 i, j, cnt = q.popleft() # 지훈이가 미로에 가장자리에 위치한 경우 현재 칸에 도달한 시간 + 1을 정답으로 return if i == 0 or i == R - 1 or j == 0 or j == C - 1: return cnt + 1 # 지훈이가 갈 수 있는 4개 방향에 대해 조건 검사 # 조건 1. 막혀 있는 칸(#)이 아닐 것 # 조건 2. 해당 칸에 기록된 불이 붙는 시간보다 지훈이의 현재 시간이 더 짧은 경우 # 위 조건에 부합한다면 해당 칸을 큐에 삽입 # 추가로 고려할 점 : visited[해당 칸]을 cnt + 1로 갱신함으로써 # 지훈이가 왔던 길을 다시 돌아가는 일이 없게 만듦 (메모리 초과 방지) if maze[i - 1][j] != '#' and visited[i - 1][j] &gt; cnt + 1: visited[i - 1][j] = cnt + 1 q.append((i - 1, j, cnt + 1)) if maze[i + 1][j] != '#' and visited[i + 1][j] &gt; cnt + 1: visited[i + 1][j] = cnt + 1 q.append((i + 1, j, cnt + 1)) if maze[i][j - 1] != '#' and visited[i][j - 1] &gt; cnt + 1: visited[i][j - 1] = cnt + 1 q.append((i, j - 1, cnt + 1)) if maze[i][j + 1] != '#' and visited[i][j + 1] &gt; cnt + 1: visited[i][j + 1] = cnt + 1 q.append((i, j + 1, cnt + 1)) # 만약 큐가 빌 때까지 BFS를 돌렸지만 정답이 반환되지 않았다면 # 지훈이가 불에 탔다는 의미이므로 -1 return return -1bfs_fire를 수행하고 나서 visited 리스트는해당 칸에 불이 붙을 수 있는 최소 시간을 저장하고 있으므로…bfs_jihoon에서 이동 가능한 칸들에 대해불이 붙은 시간보다 현재 시간이 작은 경우만 추가해 주며 BFS를 수행한다.만약 지훈이가 가장자리에 도달하면 다음 타이밍에 미로를 탈출하는 것이므로현재 도달 시간 + 1을 정답으로 출력하고,큐가 다 돌기까지 정답을 출력하지 못한 경우 지훈이가 불에 탔으므로-1을 출력해 주면 된다.짚고 넘어갈 점은 2가지인데,지훈이가 가장자리에 있는 경우는 정답 처리를 위해 앞서 검사하므로뒤에서 큐에 추가하는 부분은 별도로 조건 검사에 포함하지 않았다는 점과,지훈이가 이동하는 칸들에 대해 visited를 지훈이의 도달 시간으로갱신해 주면서 BFS를 진행해야 메모리 초과 를 피할 수 있다는 점이다…BFS를 두 번 수행하면서 visited 리스트를 활용한다는 점이인상깊었던 문제였다.만약 코딩테스트 스터디 팀원 분께서불이 지도 상에 여러 개 존재할 수 있다는 점을 알려 주시지 않았다면많이 헤맸겠다 싶은… 생각이 든다….. 감사합니다…..📖 참고한 테스트 케이스 모음5 5....F...J#....#....#...#.정답 : 43 3F.F.J.F.F정답 : IMPOSSIBLE7 7########J######.....##.#.#.##.#.#.#F.#.#.###F.#.#정답 : 10💻 코드📒 연관 개념 BFS(너비 우선 탐색) " }, { "title": "📄 백준 1939번 - 중량제한 (BFS, 이분 탐색)", "url": "/posts/algorithm-boj-1939/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, bfs, binary search", "date": "2022-07-09 20:01:48 +0900", "snippet": "📄 문제 소개백준 1939번 : 중량제한링크 : https://www.acmicpc.net/problem/1939N개의 섬과 M개의 다리로 이루어진 그래프 관계가 존재하고각 M개의 다리에 대한 중량 제한이 존재한다고 했을 때,A 지점부터 B 지점까지 중량 제한을 유지하면서도 옮길 수 있는최대 중량을 출력하는 문제이다.만약 A -&gt; B -&gt; C를 거쳐 물품을 옮기는 상황에서 E(A, B) = 2,E(B, C) = 3이라면 다리가 부서지지 않도록 옮길 수 있는 최대 중량은구성된 간선들의 중량제한들 중 최솟값, 그러니까 E(A, B) = 2로제한된다는 점을 고려해야 한다.하지만 이 경우는 A -&gt; C로 바로 가는 경로의 중량 제한이 3이므로해당 예시의 정답은 3을 출력할 수 있다.📗 문제풀이 과정🧐 일단 생각해 볼 것N개의 정점과 M개의 간선이 주어지고 각 간선마다 가중치가 주어지는 점에서는일반적인 Weighted Graph 문제로 판단할 수 있고,A 정점부터 B 정점까지 도달하는 최소 경로가 아닌 여러 경로들의 가중치를계산해야 하므로, BFS로 접근해볼 수 있다.😀 BFS(너비 우선 탐색)를 이용한 전략 M개의 간선 및 가중치 정보를 양방향 인접 리스트로 입력받음 [시작 정점, 방문 리스트, 최대 중량]을 큐에 삽입 큐 맨 앞에서 요소를 뺌3-1. 해당 정점이 도착점이라면 최대 중량을 비교 후 더 큰 값으로 갱신3-2. 해당 정점이 도착점이 아니라면 해당 정점으로부터 이동할 수 있는연결된 정점들에 방문 여부를 확인한 후 큐에 추가 큐가 빌 때까지 2~3을 반복 BFS가 끝나고 큐가 빈 상태라면 탐색 가능한 모든 경로를 검사했으며가능한 중량 제한의 상한을 찾아냈다는 의미이므로 정답 출력😉 코드로 나타내면..? (큐 사용)from collections import deque# 섬의 개수 N, 다리의 개수 M 입력N, M = map(int, input().split())# 다리와 중량에 대한 그래프 표현을 위한 links 리스트links = [[] for _ in range(N)]for _ in range(M): A, B, weight = map(int, input().split()) # 양방향 연결 관계 및 가중치 추가 links[A - 1].append((B - 1, weight)) links[B - 1].append((A - 1, weight))각 간선에 대한 가중치 정보를어떤 간선에 대한 정보 = (연결된 간선, 연결된 간선으로의 다리 중량 제한)형식으로 인접 리스트에 기록했다.start, goal = map(int, input().split())visited = [0] * Nvisited[start - 1] = 1# 큐 선언 후 시작 섬의 위치 삽입q = deque()q.append([start - 1, visited.copy(), 10000])그 다음으로는 N개 정점에 대한 방문 여부를 visited 리스트로 기록했는데각 BFS 탐색마다 다른 경로를 찾아가므로 visited 리스트를 복사해서큐에 매번 넣어주도록 했다.def bfs(): global goal answer = -1 # 큐가 비어있지 않으면 계속 탐색 while len(q) &gt; 0: # 큐에서 맨 앞 요소(현재 위치한 섬, 방문 기록 리스트, 최대 중량)를 pop current, visited, max_weight = q.popleft() if max_weight &lt; answer: continue # 목표 섬에 도달한 한 가지 방법 찾았을 때 -&gt; 그 때까지의 최대 중량 비교해서 갱신 if current == goal - 1: answer = max_weight if answer &lt; max_weight else answer continue for node, weight in links[current]: if visited[node] == 0: new_visited = visited.copy() new_visited[node] = 1 q.append([node, new_visited, weight if max_weight &gt; weight else max_weight])BFS 탐색은 큐가 비어있지 않은 동안 계속되며,탐색의 특성 상 지나가는 간선 중 가중치의 최솟값으로 최대 중량이 갱신되므로만약 이전에 찾은 최대 중량 값보다 이번 경로에서의 최대 중량이 어차피작아져 버리는 경우는 탐색을 끊어버리도록 조건을 추가했다.그렇지 않은 경우는 끝까지 탐색을 이어가다가 목표 정점에 도달하면기존에 찾은 최대 중량 값과 비교 후 갱신하도록 했다.😢 메모리 초과 발생…!위 로직으로 문제를 풀었을 때 정답은 잘 출력되는 듯 보이나…메모리 초과가 발생했다.메모리 초과가 큐의 길이가 너무 길어지면서 발생했는지,혹은 큐에 넣는 visited 배열의 복사 과정에서 발생했는지는 모르지만일단 이 문제는 BFS만으로 접근해서는 풀 수 없는 것으로 보인다..그 이유는 바로…주어진 정점의 개수 N과 간선의 개수 M이 각각 최대 10^4, 10^5으로주어지고, 그래프 탐색이 최소 가중치 경로를 찾는 것이 아니라시작 정점부터 목표 정점까지의 모든 경로를 찾아야 하는 경우 또한 존재하므로일반적인 BFS로는 시간 제한 1초 내에 들어올 수가 없는 구조이다.또한 모든 C에 대해 시작 정점부터 목표 정점까지의 중량 제한이 가능한지를검사해 C의 최대 가능한 값을 찾아내는 알고리즘으로 수정하더라도간선이 가질 수 있는 가중치 C가 최대 10^9라는 점을 다시 살펴보면메모리 초과의 여지가 문제에서부터 힌트로 주어진 셈이나 다름없다.그럼 어떻게 해야 할까?🧐 C의 값을 찾는 가장 바깥쪽 O(N)을 줄일 수 있다면..?“시작 정점부터 목표 정점까지 모든 경로를 고려하며 최소 가중치 거리”를알아내기 위한 BFS가 아니라, 단순히“시작 정점부터 목표 정점까지 어떠한 가중치로 도달하는 것이 가능한가?”를알아내기 위한 BFS는 O(N + M)의 시간이 소요된다.그런데 사실 이 문제를 풀기 위해서 최소 1부터 최대 10^9 사이에 있는어떠한 C 값을 찾아내기 위해 O(N)마다 BFS를 수행한다는 점을 생각해 보면,10^9 범위의 C 값을 찾아내는 과정을 1씩 증가시키면서 최댓값을 찾는 대신Binary Search를 이용해 가능한 BFS를 굴려 보면서 C를 조정하는 과정을O(log N) 안에 끝내도록 수정할 수 있다.😀 Binary Search(이분 탐색) + BFS를 이용한 수정된 전략 맨 처음 start를 1, end를 10^9으로 설정 middle을 start와 end의 중간 정수값으로 설정 A 정점으로부터 B 정점까지 middle의 중량을 옮길 수 있는지를 검사 (옮길 수 있다면) start를 middle + 1로, middle을(start + end) / 2로 조정하고 다시 BFS 실행 (불가능하다면) end를 middle - 1로, middle을(start + end) / 2로 조정하고 다시 BFS 실행 C를 찾을 때까지 2~5를 반복😉 코드로 나타내면..?...# 이분 탐색 초기화start = 1end = 10**9answer = -1while start &lt;= end: middle = (start + end) // 2 if bfs(middle): # 가장 마지막으로 탐색에 성공한 중량 최대값 갱신 answer = middle start = middle + 1 else: end = middle - 1정점 및 간선 정보를 입력받는 부분은 이전 코드와 같으므로 생략하고,달라진 부분은 이분 탐색을 진행하면서 middle의 중량을 A 정점부터B 정점까지 운반할 수 있는지의 여부를 bfs() 함수로 체크한다.만약 운반할 수 없다면 해당 중량보다 작은 범위 내에서 이분 탐색을 진행하고운반할 수 있다면 해당 중량보다 큰 범위 내에서 이분 탐색을 진행한다.추가로 운반할 수 있는 가장 큰 중량을 answer에 갱신해 준 후마지막에 출력해 주면 정답이 된다.def bfs(weight): # 정점 방문 여부 기록 visited 리스트 visited = [False] * N # 큐 초기화 q = deque() # 시작 정점에 대한 방문 여부 기록 및 큐에 추가 visited[A - 1] = True q.append(A - 1) # 큐가 비어있지 않으면 계속 탐색 while len(q) &gt; 0: # 큐에서 맨 앞 요소(현재 위치한 섬)을 pop current = q.popleft() # 목표 섬에 도달했을 때 true 리턴 if current == B - 1: return True # 목표 섬에 도달하지 못했다면 for vertex, edge_weight in links[current]: # 현재 정점에서 연결된 정점들로 방문 여부 체크 후 큐에 삽입 if not visited[vertex] and weight &lt;= edge_weight: visited[vertex] = True q.append(vertex)bfs() 함수에서는 전달받은 weight를 가지고A 정점부터 B 정점까지 이동할 수 있는지만 체크하면 되므로,큐에는 현재 위치만 추가해 주면서 visited 리스트를 함수 전역에서기록하도록 한다.이후 도달 시에 True를 리턴하고 큐가 빈 경우는 해당 경로는weight를 운반할 수 없는 경로이므로 False를 출력한다.이거 절대 골드 4짜리 문제 아니다……..처음 본 상황에서 전형적인 BFS 문제라는 인식에서 이분 탐색을 결합해서써 볼 생각을 떠올리기 쉽지 않을 것 같다…사실 어쩌면 10^9로 주어진 가중치 C의 최대 값에서소요 시간을 O(N)에서 O(log N)으로 한 단계 줄이라는힌트를 준 걸 캐치해야 문제 풀이가 수월했을 것 같다…실제 코테 문제에서는 이분 탐색이 다른 알고리즘과 결합되어문제 풀이를 유도하는 경우도 많기 때문에,이 기회로 이분 탐색을 떠올릴 수 있는 경험치를 얻은 것 같다.💻 코드📒 연관 개념 BFS(너비 우선 탐색) Binary Search(이분 탐색) " }, { "title": "📄 백준 7569번 - 토마토 (BFS)", "url": "/posts/algorithm-boj-7569/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, bfs", "date": "2022-07-08 15:06:37 +0900", "snippet": "📄 문제 소개백준 7569번 : 토마토링크 : https://www.acmicpc.net/problem/7569토마토 상자는 가로, 세로, 높이를 가진 3차원 배열 형태로토마토를 보관하고 있으며, 각 칸은 아래의 상태를 나타낸다. 1 : 익은 토마토가 있는 칸 0 : 아직 익지 않은 토마토가 있는 칸 -1 : 비어 있는 칸익은 토마토는 하루마다 상/하/좌/우/앞/뒤의 주변 6개 토마토에 대해익지 않은 토마토를 익도록 영향을 줄 수 있다.토마토 상자의 모든 토마토가 익기까지 최대 며칠이 걸리는지, 혹은익을 수 없는 토마토가 존재한다면 불가능함을 출력해 주는 문제이다.📗 문제풀이 과정🧐 일단 생각해 볼 것초기 상태에서 며칠이 흘렀는지를 증가시키면서토마토 상자의 모든 토마토가 익었는지를 검사하게 될 경우가로 M, 세로 N, 높이 H가 모두 최대 10^2이므로종료 조건을 판정하는 데에만 최대 10^6 정도의 시간이 소요된다.문제의 시간 제한이 1초임을 감안한다면,전체 토마토가 익기까지 날짜가 100일만 넘어가더라도10^8을 넘게 되므로 이는 문제에 접근하기에 좋은 방법은 아니라고 느낄 수 있다.뿐만 아니라, 이러한 접근의 경우 어떠한 특정 칸의 토마토에 대해주변 익은 토마토의 영향이 중복해서 적용될 경우도지나치게 연산량을 많이 가져가게 되므로 다른 방법을 찾아봐야 한다.😀 BFS(너비 우선 탐색)를 이용한 전략이 문제를 잘 생각해 보면, 어떠한 익은 토마토가 영향을 줄 수 있는 건6개 방향의 인근 토마토들이므로, 어떠한 정점들의 관계로 문제를 구체화할 수 있다.또한 어떠한 토마토가 주변에 영향을 주는 데 하루가 걸린다는 조건과모든 토마토가 익는 데 며칠 걸리는지를 구해야 하므로초기 상태의 익은 토마토를 따라 BFS를 수행해볼 수 있다. 맨 처음 큐에 초기 토마토 상자 내 익은 토마토들에 대해 visited를 체크하고[익은 토마토들의 좌표.., 날짜 0]을 추가 큐 맨 앞에서 요소를 빼서 주변 6개 방향의 토마토들에 대해서 판단 어떠한 방향의 토마토가 비어 있는 칸이 아님과 동시에현재 해당 토마토의 visited에 기록된 날짜보다 방금 큐에서 꺼낸 날짜가비교 상 더 작은 경우 큐에 추가 큐가 빌 때까지 2~4를 반복 BFS가 마무리되고 큐가 비워진 상태는 상자 내의 모든 토마토들이줄 수 있는 영향을 모두 전달한 상태이므로초기 상태에서의 익지 않은 토마토들에 대해서 검사5-1. 방문하지 않은 토마토가 있다면, -1 출력5-2. 모든 토마토를 방문했다면 가장 오래 걸리는 날짜를 출력위 알고리즘의 핵심은 어떤 특정 토마토의 visited 리스트 인덱싱이단순 토마토의 방문 여부가 아니라 해당 토마토가 익기까지 걸리는 날짜를의미한다는 점이다.어떤 위치의 토마토에 이미 방문했다고 해서 다시 방문하지 않도록 하는 것이 아니라,비교해서 더 짧은 날짜에 해당 토마토가 익을 수 없으면 visited를갱신해 주도록 하는 것이 알고리즘의 포인트이다.코드로 보면 좀 더 쉽다!!😉 코드로 나타내면..? (큐 사용)# 토마토 상자의 가로 M, 세로 N, 쌓여진 높이 H 입력M, N, H = map(int, input().split())# 익은 토마토, 안 익은 토마토, 그리고 빈 칸에 대한 정보 tomatoes 3차원 리스트 입력tomatoes = [[list(map(int, input().split())) for _ in range(N)] for _ in range(H)]# 토마토에 대한 BFS 방문 여부 visited 3차원 리스트로 초기화visited = [[[999999 for _ in range(M)] for _ in range(N)] for _ in range(H)]토마토 상자에 대한 입력이 3차원 리스트 형태로 주어지는데, 이를 파이썬의list comprehension 으로 받아서 tomatoes 리스트에 저장했다.visited 리스트 같은 경우는 tomatoes와 같은 형태를 가지지만충분히 큰 값(최대로 가질 수 있는 날짜 값)으로 초기화했다.q = deque()# 익지 않은 토마토들을 큐에 추가 및 visited 0으로 입력for i in range(H): for j in range(N): for k in range(M): if tomatoes[i][j][k] == 1: visited[i][j][k] = 0 q.append([i, j, k, 0])큐를 초기화한 후 초기 상태의 토마토 상자에서익은 토마토들에 대해 visited를 기록 후 큐에 넣어준다.이는 이어지는 로직에서 익은 토마토들이 자연스럽게 BFS에 의해주변 토마토들로 탐색을 이어갈 수 있도록 하기 위함이다.# 큐가 비어 있지 않은 동안 BFS 진행while len(q) &gt; 0: i, j, k, day = q.popleft() if 0 &lt; i and tomatoes[i - 1][j][k] != -1 and visited[i - 1][j][k] &gt; day + 1: visited[i - 1][j][k] = day + 1 q.append([i - 1, j, k, day + 1]) if i &lt; H - 1 and tomatoes[i + 1][j][k] != -1 and visited[i + 1][j][k] &gt; day + 1: visited[i + 1][j][k] = day + 1 q.append([i + 1, j, k, day + 1]) if 0 &lt; j and tomatoes[i][j - 1][k] != -1 and visited[i][j - 1][k] &gt; day + 1: visited[i][j - 1][k] = day + 1 q.append([i, j - 1, k, day + 1]) if j &lt; N - 1 and tomatoes[i][j + 1][k] != -1 and visited[i][j + 1][k] &gt; day + 1: visited[i][j + 1][k] = day + 1 q.append([i, j + 1, k, day + 1]) if 0 &lt; k and tomatoes[i][j][k - 1] != -1 and visited[i][j][k - 1] &gt; day + 1: visited[i][j][k - 1] = day + 1 q.append([i, j, k - 1, day + 1]) if k &lt; M - 1 and tomatoes[i][j][k + 1] != -1 and visited[i][j][k + 1] &gt; day + 1: visited[i][j][k + 1] = day + 1 q.append([i, j, k + 1, day + 1])BFS 탐색을 하면서 큐에 넣기 전 시점에 이미해당 정점이 탐색 가능한 정점인지 검사하고 넣기 때문에,큐에서 뽑고 나서는 해당 토마토에 대한 6방향 검사로 바로 이어진다.6방향의 토마토에 대해서 검사하는 조건의 내용은 인덱싱 범위 내에 있을 것 해당 칸이 비어 있지 않을 것 (!= -1) 해당 칸의 토마토에 대한 기존의 익기까지의 날짜보다새로 비교하는 익기까지의 날짜가 더 짧을 경우의 3가지이다.answer = 0for i in range(H): for j in range(N): for k in range(M): # 전체 토마토 상자 중 맨 처음 익지 않은 토마토들에 대해서만 검사 if tomatoes[i][j][k] == 0: # 만약 익지 않은 토마토인데 초기값 그대로 남아 있는 경우는 특정 토마토가 익을 수 없는 상황으로 가정 if visited[i][j][k] == 999999: print(-1) sys.exit() answer = visited[i][j][k] if visited[i][j][k] &gt; answer else answer# 정답 출력print(answer)BFS 탐색을 끝내고 전체 토마토 상자를 검사했을 때는 주어진 초기 토마토 상자의익지 않은 상태였던 토마토들에 대해서만 고려한다.만약 어떤 토마토에 대한 visited 리스트 값이 초기화 값으로 남아 있다면해당 토마토에 BFS가 도달하지 못했다는 의미이므로,영원히 익을 수 없는 토마토가 존재한다는 뜻이다…그렇지 않은 경우는 어쨌든 가장 익는 데 오래 걸리는 토마토의 날짜가정답이므로, 이를 찾아서 출력해 주면 된다.로직만 보면 아주 기초적인 BFS 문제들과 크게 다를 바 없는데정점의 데이터가 3차원으로 주어졌다는 점에서 약간 헷갈려서 오래 걸렸다.이 문제의 “가장 늦게 익는 토마토는 얼마 만에 익을까?” 를찾아내는 과정에서 토마토와 토마토 사이를 이동하듯이 추상화해BFS를 적용할 수 있었던 점이 신선했다.별개로, visited 리스트에 초기화하는 값을 맨 처음에는 301로 정했는데,그 이유는 직육면체 형태의 3차원 상자를 떠올렸을 때 가장 오래 걸리는 거리는한쪽 모서리에서 반대쪽 모서리라고 생각했기 때문에어떤 토마토가 익는 데 가장 오래 걸리는 발생 가능한 상황은가로 + 세로 + 높이의 최대 값 = M + N + H라고 생각했기 때문이다.그런데 이렇게 하면 틀렸습니다가 뜨기 때문에999999 정도로 초기화하니 통과했다.왜일까…💻 코드📒 연관 개념 BFS(너비 우선 탐색) " }, { "title": "📄 백준 5014번 - 스타트링크 (BFS)", "url": "/posts/algorithm-boj-5014/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, bfs", "date": "2022-07-08 09:48:22 +0900", "snippet": "📄 문제 소개백준 5014번 : 스타트링크링크 : https://www.acmicpc.net/problem/5014입력으로 주어지는 값들이 F, S, G 같은 이름이라서 헷갈릴 수 있지만그림으로 그려 보면 굉장히 쉬운 문제이다. F(Floors?) : 건물의 전체 층 수 S(Start?) : 시작 층 G(Goal?) : 목표 층 U(Up?) : 엘레베이터가 올라갈 수 있는 층 단위 D(Down?) : 엘레베이터가 내려갈 수 있는 층 단위U, D를 잘 생각해 보면 엘레베이터가 할 수 있는 동작은 아래 두 가지임을 알 수 있다. 현재 층 + U만큼 이동 현재 층 - D만큼 이동세상에 이런 엘레베이터가 어디 있단 말인가??어쨌든, 이에 따라서 현재 층 기준으로 목표 층에 도달할 수 있다면최소 몇 번 버튼을 눌러야 할 지,혹은 도달할 수 없다고 판단되면 별도의 출력을 해 주는 문제이다.📗 문제풀이 과정🧐 일단 생각해 볼 것현재 주어진 시작 층 수를 하나의 정점으로 생각하고,다음 방문할 수 있는 층은 현재 층 수로부터 +U 또는 -D한 층이 된 것이므로방문 여부를 체크하면서 다음 정점(이동 가능한 층)으로의 탐색을 진행하는BFS로 문제 풀이를 해 볼 수 있다.😀 BFS(너비 우선 탐색)를 이용한 전략 맨 처음 큐에 시작 층 수와 버튼 누른 횟수 0을 넣고 초기화 큐 맨 앞에서 요소를 빼서 판단2-1. 이미 방문한 층이라면, 넘어가기2-2. 방문하지 않은 층이라면 3으로 쭉 진행 목적 층에 도달했다면 정답을 출력하고 BFS 종료 도달하지 못했다면 현재 층 + U나 현재 층 - D를이동 횟수 + 1과 함께 큐에 삽입 큐가 빌 때까지 2~5를 반복 큐가 비었는데도 return이 발생하지 않았다면 도달할 수 없는 층이라고 판단 후별도 출력 해 주기😉 코드로 나타내면..? (큐 사용)# collections.deque 사용from collections import deque# 전체 층 수 F, 현재 위치 S, 목적 층 G, 증가 값 U, 감소 값 D 입력F, S, G, U, D = map(int, input().split())# 큐 선언 후 시작 층 삽입q = deque()q.append([S, 0])맨 처음 주어지는 입력 값들을 받은 후, 큐를 초기화한다.그 다음으로 큐에 [시작 층, 버튼 누른 횟수]를 삽입한다.def bfs(): # 층 수 방문 위치 기록을 위한 visited 리스트 초기화 visited = [False] * F # 1 ~ F (최대 1,000,000) answer = -1 # 큐가 비어있지 않으면 계속 탐색 while len(q) &gt; 0: # 큐에서 맨 앞 요소(현재 층 수, 버튼 누른 횟수)를 pop current, cnt = q.popleft() # 이미 방문한 층이면 넘어가기 if visited[current - 1]: continue # 목적 층에 도착했을 시 버튼 누른 횟수 answer에 업데이트하고 while문 bfs 중단 if current == G: answer = cnt break ...BFS 탐색에 의해 최초로 방문하게 되는 어떠한 층은해당 층을 방문할 때의 버튼 누른 횟수가 그 층에 도달하기 위한최소 버튼 누른 횟수임을 의미한다.따라서 한 번 방문한 층은 다시 방문하지 않도록 visited 리스트를 사용한다.만약 BFS 탐색 중간에 목표 층에 도달한 경우남아있는 큐의 요소들과 상관없이 정답을 출력하고 종료한다.def bfs(): ... ############################# # 아직 해당 층에 도착하지 못했을 경우 ############################# # 현재 층의 방문 여부를 visited에 기록 visited[current - 1] = True # U, D 값에 의해 다음 이동할 수 있는 층을 큐에 추가 if current + U &lt;= F: q.append([current + U, cnt + 1]) if current - D &gt;= 1: q.append([current - D, cnt + 1]) return answer# bfs 탐색 진행answer = bfs()# 정답 출력print(answer if answer != -1 else \"use the stairs\")BFS를 계속 진행해야 하는 경우는 현재 층 기준으로U만큼 위에 있거나 D만큼 아래 있는 층으로 탐색을 진행한다.만약 큐의 모든 요소를 뽑아낸 후 while문을 탈출하고 나서도bfs() 함수의 return이 발생하지 않았다는 것은도달하지 못한 층임을 나타낸다.따라서 이 때는 answer의 초기화 값인 -1이 반환된다.💻 코드📒 연관 개념 BFS(너비 우선 탐색) " }, { "title": "📄 백준 18112번 - 이진수 게임 (BFS)", "url": "/posts/algorithm-boj-18112/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, bfs", "date": "2022-07-07 15:18:31 +0900", "snippet": "📄 문제 소개백준 18112번 : 이진수 게임링크 : https://www.acmicpc.net/problem/18112이 문제의 이진수 게임에서는 1을 더하거나 1을 빼거나 (단, 0이 아닌 상태에서만) MSB를 제외한 나머지 Bit를 하나 Invert하는 3가지 방법으로 주어진 숫자를 한 번씩 바꿀 수 있다.어떠한 시작 이진수와 목표 이진수가 각각 주어졌다고 했을 때,시작 이진수부터 목표 이진수까지의 최소 변화 횟수를 구하는 문제이다.📗 문제풀이 과정🧐 일단 생각해 볼 것현재 주어진 이진수의 상태를 하나의 정점으로 생각하고,주어진 이진수로부터 변화할 수 있는 다른 이진수를 이어진 정점으로 생각했을 때문제를 보고 자연스럽게 떠올릴 수 있는 방법은 BFS를 수행해 보는 것이다.😀 BFS(너비 우선 탐색)를 이용한 전략 맨 처음 큐에 시작 이진수와 변화 횟수 0을 넣고 초기화 큐 맨 앞에서 요소를 빼서 목표 이진수에 도달했다고 판정되면 출력 후 종료 (목적지에 도달하지 못했다면) 현재 이진수에 방문 여부를 기록하고현재 이진수로부터 생성할 수 있는 이진수들을 검사 후 큐에 삽입 큐가 비어있지 않을 동안 2~4를 반복😉 코드로 나타내면..? (큐 사용)# collections.deque 사용from collections import deque# L 길이의 시작 이진수 start 입력start = int('0b' + input().strip(), 2)# K 길이의 목표 이진수 end 입력end = int('0b' + input().strip(), 2)# 큐 선언 후 시작 이진수 삽입q = deque()q.append([start, 0])맨 처음 시작 이진수와 목표 이진수를 입력받은 후, 큐를 초기화한다.그 다음으로 큐에 [시작 이진수, 변화 횟수]를 삽입한다.def bfs(): # 자연수 생성 기록을 위한 visited 리스트 초기화 visited = [False] * 1024 # 0 ~ 1023 # 큐가 비어있지 않으면 계속 탐색 while len(q) &gt; 0: # 큐에서 맨 앞 요소(생성된 이진수)를 pop number, level = q.popleft() # 목표 이진수에 도달했을 경우 이동 횟수 return if number == end : return level ...변화 과정에서 생성했던 이진수를 기록하기 위해서 visited 리스트를 사용한다.이 때, 시작 이진수와 목표 이진수의 크기는 최대 10자리라고 했기 때문에0부터 1023까지를 나타내기 위한 1024의 크기로 초기화한다.def bfs(): ... # 현재 자연수를 visited에 기록 visited[number] = True # 다음 생성할 수 있는 이진수를 검사 후, 이전에 생성한 적이 없다면 큐에 추가 # 1. 한 자리 숫자를 보수로 바꾸기 bin_number = bin(number)[2:] for i in range(len(bin_number) - 1): temp_number = number ^ (1 &lt;&lt; i) if not visited[temp_number] : q.append([temp_number, level + 1]) # 2. 현재 수에 1 더하기 if number + 1 &lt; 1024 and not visited[number + 1] : q.append([number + 1, level + 1]) # 3. 현재 수에서 1 빼기 if number &gt; 0 and not visited[number - 1] : q.append([number - 1, level + 1])이 문제를 해결할 때 생각했던 포인트 하나는, 이진수를 다룬다는 점 때문에string으로 큐의 노드들을 다뤄야 한다고 생각하기 쉽지만시간이 많이 걸리는 문자열 연산으로 알고리즘을 표현하기에는 위험 부담이 크다.대신에, int 형태로 노드들을 다루는 것이 문제 풀이 포인트라고 생각한다.이진수 게임의 원칙 중 하나인 &lt;MSB 제외 1 Bit Invert&gt; 를구현하기에 있어서도 string으로 바꾼 후 '0'과 '1'을 서로 조건에 의해바꾸는 등의 방법을 쓰기보다는 Bitwise XOR을 통해 해당 Bit만을반전시켜 주도록 연산을 적용하는 게 훨씬 나은 접근이다.☹️ 시간 초과 발생 - 약간 수정된 알고리즘 로직 적용위의 코드 제출 시 시간 초과 발생…하지만 위의 코드를 제출하면 시간 초과가 나는 것을 볼 수 있다.BFS 자체에는 문제가 없는 것 같고…아마 접근할 수 있는 노드들을 검사 후 큐에 넣는 부분에서지나치게 조건 검사를 많이 들어가는 게 원인인가 싶어 로직을 살짝 변경했다. 약간 수정된 알고리즘 로직 적용 맨 처음 큐에 시작 이진수와 변화 횟수 0을 넣고 초기화 큐 맨 앞에서 요소를 빼서 방문 여부를 판단 후 이미 생성했었다면 넘어가기 (처음 생성한 이진수라면) 목표 이진수 일치 여부 비교하고 정답이면 출력 (목표 이진수가 아니라면) 현재 이진수로부터 생성 가능한 이진수들을 전부큐에 삽입 큐가 비어있지 않을 동안 2~5를 반복def bfs(): visited = [False] * 1024 while len(q) &gt; 0: number, level = q.popleft() # ---------- 수정한 부분 ---------- # # 방문 여부를 큐에서 추출 후 검사하도록 변경 if visited[number]: continue # ------------------------------ # if number == end : return level visited[number] = True # ------------ 수정한 부분 ------------ # # 다음 생성할 수 있는 이진수를 검사 후 # 방문 여부를 체크하지 않고 일단 전부 큐에 추가 # 1. 한 자리 숫자를 보수로 바꾸기 bin_number = bin(number)[2:] for i in range(len(bin_number) - 1): q.append([number ^ (1 &lt;&lt; i), level + 1]) # 2. 현재 수에 1 더하기 if number + 1 &lt; 1024: q.append([number + 1, level + 1]) # 3. 현재 수에서 1 빼기 if number &gt; 0: q.append([number - 1, level + 1]) # ---------------------------------- #기존에는 현재 이진수에서 생성 가능한 이진수들의 visited 리스트를 검사 후한 번도 생성한 적 없는 이진수만 큐에 넣도록 했는데,이를 수정해서 일단 큐에 무조건 넣고 꺼낼 때 방문 여부를 검사하도록 코드를 살짝 바꿨다.이렇게 변경 후 채점을 통과할 수 있었다…!오히려 큐에 넣기 전 visited를 검사한 후 삽입해야메모리 초과 같은 문제가 발생하지 않는다고 생각해서 처음에 저렇게 접근했는데…약간은 찝찝하지만.. 일단 통과했다!!💻 코드📒 연관 개념 BFS(너비 우선 탐색) " }, { "title": "📄 백준 12851번 - 숨바꼭질 2 (BFS)", "url": "/posts/algorithm-boj-12851/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, bfs", "date": "2022-07-07 09:47:01 +0900", "snippet": "📄 문제 소개백준 12851번 : 숨바꼭질 2링크 : https://www.acmicpc.net/problem/12851 현재 위치 - 1 (바로 이전 칸) 현재 위치 + 1 (바로 다음 칸) 현재 위치 * 2 (2를 곱한 칸)수빈이의 위치와 목표물의 위치가 각각 주어지고,수빈이가 위와 같은 3가지 방법으로 다음 위치로 이동할 수 있다고 했을 때,목표물에 도달하는 최단 거리는 얼마인지를 구하는 문제이다.또한, 최단 거리를 구했을 시에 추가로 해당 시간 내에 도달할 수 있는다른 방법이 있다면 동시에 존재하는 방법의 수까지 함께 출력해야 한다.📗 문제풀이 과정🧐 일단 생각해 볼 것현재 수빈이의 위치를 하나의 정점으로 생각하고수빈이가 이동할 수 있는 최대 3개 정점으로 연결된 그래프로 문제를 표현한다면,큐를 이용한 BFS를 수행해서 문제를 풀 수 있겠다 생각할 수 있다. 백준 1697번 - 숨바꼭질백준 1697번 : 숨바꼭질사실 좀 더 찾아본다면.. 이 문제가 1697번 - 숨바꼭질 문제에서몇 가지 조건을 추가한 형태임을 알 수 있다.부가적인 요구사항을 제외하고 이전 문제만 들여다 보면BFS로 풀이할 수 있는 대표적인 문제 유형이라는 게 더욱 명확해진다.🤔 이전 문제(1697번 - 숨바꼭질)부터 풀어 나가 볼까요? 맨 처음 큐에 수빈이의 위치와 이동 횟수 0을 넣고 초기화 큐 맨 앞에서 요소를 빼서 목적지에 도달했다고 판정되면 출력 후 종료 (목적지에 도달하지 못했다면) 큐에서 뺀 요소에 대해 이동 가능한 3개 위치에 대해 방문 여부를 검사하고, 이동 가능하다면 각각 큐 뒤에 삽입 큐가 비어있지 않을 동안 2~4를 반복위와 같이 큐를 이용한 BFS로 문제 풀이 로직을 간단하게 구성할 수 있다.😉 코드로 나타내면..? (큐 사용)from collections import deque# 수빈의 현재 위치와 동생의 위치 입력subin, sister = map(int, input().split())# 큐 선언 후 수빈의 현재 위치 삽입q = deque()q.append([subin, 0])맨 처음 수빈과 동생의 위치를 받은 후, 큐를 초기화한다.그 다음으로 큐에 [수빈의 맨 처음 위치, 이동 횟수]를 삽입한다.참고로 문제 풀이를 할 때 파이썬에서 큐를 사용하기 위해서는일반 리스트를 사용하기보다 collections.deque를 사용하는 것을 추천한다.deque는 사용하기에 따라 스택처럼 쓸 수도, 큐처럼 쓸 수도 있지만이번 문제는 큐로써 활용한 경우이다. 참고 링크 - Python - 데크(deque) 언제, 왜 사용해야 하는가?def bfs(): visited = [False] * 100001 # 큐가 비어있지 않으면 계속 탐색 while len(q) &gt; 0: moved_subin, level = q.popleft() # 동생 찾았을 경우 이동 횟수 return if moved_subin == sister : return level ...BFS를 위한 함수 선언 부분이다.한 번 방문한 노드는 방문하지 않기 위해서 visited 리스트를 통해방문 여부를 체크한 뒤 큐에 삽입을 고려하게 되며, 이러한 동작이 BFS에서가지는 의미는 어떠한 위치에 도달했을 때 항상 최소 경로에 의해 그 위치에도달했음을 나타낸다.def bfs(): ... visited[moved_subin] = True # 수빈이 다음 이동할 수 있는 위치를 검사 후, 방문하지 않았다면 큐에 추가 if moved_subin + 1 &lt;= 100000 and not visited[moved_subin + 1] : q.append([moved_subin + 1, level + 1]) if moved_subin - 1 &gt;= 0 and not visited[moved_subin - 1] : q.append([moved_subin - 1, level + 1]) if moved_subin * 2 &lt;= 100000 and not visited[moved_subin * 2] : q.append([moved_subin * 2, level + 1])만약 큐에서 방금 추출한 현재 수빈의 위치가 목적지가 아니라고 판단한 경우는,visited 리스트에 체크한 후 다시 현재 위치로부터이동할 수 있는 3가지 정점을 큐에 삽입한다.수빈의 위치 N과 동생의 위치 K가 모두 0 ~ 100,000으로 주어져 있기 때문에항상 수빈은 최대 100,000번의 이동 횟수 내에 동생에게 도달할 수 있음이보장된다. 따라서 이렇게 1697번 - 숨바꼭질을 풀 수 있다.😀 다시 원래 문제(12851번 - 숨바꼭질 2)로 돌아와 볼까요?최소 이동 횟수에 추가로 찾는 방법의 개수까지 출력해야 한다12851번 - 숨바꼭질 2 문제가 원래 문제에서 추가된 점은 단 하나인데,바로 최소 횟수로 이동할 수 있는 방법의 가짓수까지 출력하도록 했다는 점이다.무슨 말이냐면, 만약 수빈의 위치가 1이고 동생의 위치가 2라고 했을 경우수빈은 1초만에 동생에게 도달할 수 있지만방법은 +1(걷기)와 *2(순간이동) 두 가지로 존재한다.따라서 이러한 상황을 고려해 최소 횟수로 도달할 수 있는 다른 방법이 있다면전부 세 주어야 한다.🤔 수정된 문제 풀이 전략 맨 처음 큐에 수빈이의 위치와 이동 횟수 0을 넣고 초기화 큐 맨 앞에서 요소를 빼서 목적지에 도달했다고 판정되면 출력 후 종료최소 횟수 및 방법의 가짓수를 업데이트 (목적지에 도달하지 못했다면) 큐에서 뺀 요소에 대해 이동 가능한 3개 위치에 대해 방문 여부를 검사하고, 이동 가능하다면 각각 큐 뒤에 삽입 큐가 비어있지 않을 동안 현재 이동 횟수 레벨에서의 모든 선택지를고려한 경우 BFS를 종료하고, 그렇지 않을 경우 2~4를 반복기존 문제에서 수빈이 동생에게 도달했다면 바로 출력하고 BFS를 종료했지만,이번 문제에서는 도달한 방법과 같은 탐색 레벨에 있는 정점들까지는 검사해 주고BFS를 종료해야 한다.이 부분만 고려해 주면 나머지는 크게 달라지는 부분은 없다.😉 코드로 나타내면..? (큐 사용)def bfs(): visited = [False] * 100001 #--------------# # 추가된 부분 answer = 100001 answer_cnt = 0 #--------------# while len(q) &gt; 0: moved_subin, level = q.popleft() #----------------------------# # 수정되기 전 코드 # if moved_subin == sister : # return level #----------------------------# # 수정된 부분 if answer &lt; level: return answer, answer_cnt if moved_subin == sister: answer = level answer_cnt += 1 continue #----------------------------# ...기존에 수빈이 동생에게 도달하자마자 BFS를 종료했던 것 대신에이동 횟수를 뜻하는 answer, 방법의 가짓수를 뜻하는 answer_cnt를업데이트하도록 한다.이후 같은 이동 횟수를 가진 큐의 요소들을 전부 빼내 마찬가지로 도달한 경우가있는지 체크해 주고, 만약 있다면 answer_cnt에 1씩 더해 준다.이후 BFS의 특성을 고려해 큐의 맨 앞 요소를 추출했을 때,이동 횟수가 더 큰 요소가 나왔다면 이는 고려해야 할 동일 레벨의 선택지를모두 고려했다는 의미이므로 BFS를 종료한다.def bfs(): ... # 수빈이 다음 이동할 수 있는 위치를 검사 후, 방문하지 않았다면 큐에 추가 if moved_subin + 1 &lt;= 100000 and not visited[moved_subin + 1] : q.append([moved_subin + 1, level + 1]) if moved_subin - 1 &gt;= 0 and not visited[moved_subin - 1] : q.append([moved_subin - 1, level + 1]) if moved_subin * 2 &lt;= 100000 and not visited[moved_subin * 2] : q.append([moved_subin * 2, level + 1]) return answer, answer_cnt# bfs 탐색 진행answer, answer_cnt = bfs()# 정답 출력print(answer)print(answer_cnt)고려해야 할 3개 이동 위치에 대해 큐에 삽입하는 부분은 이전 코드와 동일하다.다만, bfs() 함수 내부 while문에서 벗어났을 경우도 return문을 추가해 줘야100000 0 같은 테스트 케이스를 통과할 수 있다.💻 코드📒 연관 개념 BFS(너비 우선 탐색) " }, { "title": "📄 백준 15900번 - 나무 탈출 (DFS)", "url": "/posts/algorithm-boj-15900/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, dfs", "date": "2022-07-02 17:17:17 +0900", "snippet": "📄 문제 소개백준 15900번 : 나무 탈출링크 : https://www.acmicpc.net/problem/15900성원과 형석의 눈물 나는 스토리라인이 길게 설명되어 있어 복잡하지만요점만 정리하면 게임의 규칙은 아래와 같다. 게임은 N개의 트리의 리프 노드에만 게임말이 위치한 상태에서 시작 순서대로 한 개씩 게임말을 연결된 부모 노드로 옮길 수 있음(하나의 노드 위에 여러 게임말이 겹칠 수 있음) 루트 노드에 도착한 게임말은 제거되어야 함 마지막 남은 게임말을 루트 노드에 도달시킨 사람이 승리위의 게임 규칙을 기반으로 현재 트리 구성 정보가 주어졌을 때, 성원이의입장에서 게임을 먼저 시작해서 이길 수 있는지를 알아내면 되는 문제이다.📗 문제풀이 과정🧐 일단 생각해 볼 것게임 설명이 다소 난해하다고 느껴지는 면이 있어서 헷갈릴 수 있지만,아래 두가지 점을 주목하면 매우 간단하게 풀릴 수 있는 문제이다. 각 게임말은 한 노드에 겹쳐 놓을 수 있다. 각 게임말은 한 번에 한 칸(연결된 부모 노드)만 이동 가능하다. 성원이가 먼저 플레이한다.이 규칙에 의해서 몇 번 시뮬레이션을 돌려 보면,어떤 게임말을 먼저 건드릴지와 상관 없이 게임을 이기는 사람은결국 모든 리프 노드로부터 루트 노드로의 간선 합만큼 플레이하게 된다.그림을 그려 보면 더 명확해진다.위 &lt;예제 입력 2&gt;를 예시로 먼저 플레이하는 성원이의 입장에서 생각해 보면모든 리프 노드로부터 루트 노드로의 간선 합이 홀수가 되는 경우에무조건 이길 수 있으며, 그 밖에는 무조건 진다는 것을 알 수 있다.😀 DFS(깊이 우선 탐색)를 이용한 전략입력으로 최대 5 * 10^5만큼의 노드로 트리가 구성될 수 있다고 했으므로루트 노드로부터 리프 노드로의 DFS를 한 번 수행해 간선의 합을 계산하면문제를 해결할 수 있다.😉 코드로 나타내면..? (재귀 함수 사용)links = [[] for _ in range(N)]# 간선 정보 입력for _ in range(N - 1): node, link = list(map(int, input().split())) # 양방향 그래프로 구성 links[node - 1].append(link - 1) links[link - 1].append(node - 1)트리를 구성하는 링크를 받을 때 양방향 링크로 구성한다.어차피 dfs이기 때문에.. 루트 노드에서 출발하기만 한다면 상관 없다.참고로, 입력으로 주어진 노드의 번호는 1 ... N 이지만리스트 인덱싱에 편리하게 하기 위해 일부러 1씩 빼서0 ... N-1 로 범위를 조정했다.def dfs(current_node, link_sum): global total_link_sum # 현재 도착한 노드의 방문 여부 체크 visited[current_node] = True found = False for link in links[current_node]: # 현재 노드에 연결된 노드 중 방문하지 않은 노드를 골라 dfs 진행 if not visited[link]: found = True dfs(link, link_sum + 1) # 현재 노드에서 아무 것도 방문할 노드가 없는 경우 리프 노드로 판단 if not found : total_link_sum += link_sum재귀 함수로 dfs를 구현한 부분이다.잘 보면 재귀 함수의 종료 조건을 명시해서 return으로끊어내 주는 부분이 존재하지 않는데,그 이유는 애초에 for문의 반복 조건에 의해 links[current_node] 중방문 가능한 노드들만을 찾아가고 나머지는 방문하지 않기 때문이다.# 루트 노드부터 dfs 시작dfs(0, 0)print(\"Yes\" if total_link_sum % 2 == 1 else \"No\")루트 노드를 의미하는 0번 노드부터 dfs를 시작하며,1번 dfs를 진행하고 난 후의 total_link_sum 누적 값이홀수면 Yes를, 짝수면 No를 출력해 준다.추가로, 결국 total_link_sum이 홀수인 지 짝수인 지를판단해야 하는 부분이므로, 굳이 간선들을 다 누적해서 판단할 것이 아니라Boolean 으로 설정해 두고 토글하도록 로직을 짜는 것도 어떨까… 싶다.# 기본 재귀함수 깊이 10^5로 늘려서 설정import syssys.setrecursionlimit(10**5)이 문제 역시 재귀 함수로 dfs를 구현함에 따라RecursionError가 발생할 수 있다.따라서 위 코드를 추가해주어 제한을 늘려주도록 해야백준 채점 상에서 뜬금없이 컴파일 에러가 발생하지 않는다…!💻 코드📒 연관 개념 DFS(깊이 우선 탐색) " }, { "title": "📄 백준 14267번 - 회사 문화 1 (DFS)", "url": "/posts/algorithm-boj-14267/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, dfs", "date": "2022-07-01 19:53:30 +0900", "snippet": "📄 문제 소개백준 14267번 : 회사 문화 1링크 : https://www.acmicpc.net/problem/14267 사원 구조는 트리 형태로 구성됨 어떤 사원이 칭찬을 받으면 그 부하들도 칭찬을 물려 받음위의 규칙을 기반으로 트리 내부의 특정 사원에 대한 칭찬이 M회 이루어진 후전체 사원의 칭찬 누적 현황을 출력하는 문제이다.📗 문제풀이 과정🧐 일단 생각해 볼 것입력 예시를 확인해 보면, 사원 수 N과 칭찬 수 M이 모두최대 10^5으로 주어진다는 것을 알 수 있다.문제의 시간 제한이 2초이기 때문에,10^8 내에 들어오기 위해서는 10^5로 주어지는 모든 개별 칭찬에 대해서부하까지 도달하도록 하는 것은 시간 초과의 우려가 커 보인다.😀 DFS(깊이 우선 탐색)를 이용한 전략 모든 사원의 칭찬을 저장하는 N 길이의 goods 리스트 생성 M번 입력된 특정 사원에 대한 칭찬을 goods의 해당 사원에만 추가 DFS로 내려가면서 goods 리스트를 업데이트하며 아래로 누적 칭찬 전달현재 노드가 받을 최종적인 칭찬을 나타내 보면내가 받은 칭찬 + 선배로부터 내려온 칭찬= 내가 받은 칭찬 + 선배가 받은 칭찬 + 대선배로부터 내려온 칭찬임을 알 수 있다.따라서 입력받은 칭찬은 일단 달아만 두고 DFS를 한 번만 돌리면사장 직속부터 후배들까지 모든 칭찬을 업데이트할 수 있다.(사장은 칭찬을 받지 않는다고 하네요…)😉 코드로 나타내면..? (재귀 함수 사용)# 직원의 상사 정보 입력 -&gt; links 리스트links = list(map(int, input().split()))# links 리스트를 이용해 연결된 부하를 가리키는 down_links 리스트 생성down_links = [list() for _ in range(N)]for i in range(len(links)): if links[i] != -1: down_links[links[i] - 1].append(i)DFS를 쉽게 돌리기 위해서, 입력받은 자신의 선배 정보를 기반으로자신에게 달린 후배 정보를 담고 있는 down_links 리스트를 생성한다.goods = [0] * Nfor _ in range(M): # 입력받은 칭찬은 아래로 전달하지 않고 해당 사원에게만 달아놓음 person, new_good = list(map(int, input().split())) goods[person - 1] += new_goodgoods 리스트는 각 사원의 칭찬 받은 정도를 담고 있는데,문제 입력으로 들어오는 칭찬들에 대해서도각 사원의 칭찬에만 일단 추가해 둔다.def praise(idx, current_good): # 위에서부터 내려온 칭찬을 현재 사원의 칭찬에 합산 goods[idx] += current_good # 현재 사원에게 달린 후배들에게 모두 재귀함수 호출 for link in down_links[idx]: # 현재 사원까지 합산된 칭찬을 연결된 후배들에게 전달 praise(link, goods[idx])재귀 함수 praise를 통해 DFS를 구현한 부분인데선배로부터 전달된 칭찬을 current_good으로 받아현재 사원의 칭찬을 가리키는 goods[idx]에 업데이트한다.이후 현재 사원 기준 연결된 후배들에게 다시 재귀 함수를 호출한다.이렇게 하면 DFS 호출 한 번만에 문제를 해결할 수 있다.# 기본 재귀함수 깊이 10^5로 설정import syssys.setrecursionlimit(10**5)추가로 파이썬에서 재귀 함수 호출이 1000번을 넘어가면 발생하는RecursionError 때문에 백준 채점에서 런타임 에러가 뜰 수 있으므로위 코드를 추가하면 해결할 수 있다.💻 코드📒 연관 개념 DFS(깊이 우선 탐색) " }, { "title": "📄 백준 1759번 - 암호 만들기 (Bruteforcing)", "url": "/posts/algorithm-boj-1759/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, bruteforcing", "date": "2022-07-01 11:50:43 +0900", "snippet": "📄 문제 소개백준 1759번 : 암호 만들기링크 : https://www.acmicpc.net/problem/1759C개 문자가 주어지고 이 중에서 L개 문자를 골라 나열 가능한 암호 중에서정해진 규칙에 맞는 암호를 모두 출력하는 문제이다.암호의 규칙은 간단히 다음과 같다. 구성된 문자들이 사전식 알파벳 순서로 정렬될 것 적어도 자음 2개 이상, 모음 하나 이상으로 구성될 것📗 문제풀이 과정🧐 일단 생각해 볼 것입력 예시로 주어진 문자 집합 중에서 4가지를 골라문자열을 생성한다고 생각하는 대신, 좀 더 쉽게 생각해그냥 주어진 문자 집합의 모든 부분 집합을 생각해볼 수 있다.그 이유는, 암호문의 문자가 사전 순으로 정렬되어 있다는 조건 때문이다.따라서 각 문자를 포함하거나, 혹은 포함하지 않거나를 완전 탐색으로접근한다고 가정했을 때, 고려할 수 있는 경우의 수는C가 최대 15라고 했으므로 2^15 가지이다.모든 경우의 수를 고려하더라도 2^15 &lt; 1024 * 2^5 &lt; 10^8이므로충분히 시간 제한 2초 내에 들어온다고 판단할 수 있다.따라서 모든 경우를 일단 완전 탐색하도록 하고,중간에 C보다 문자열이 길어지거나 모음 및 자음 포함 조건을충족하지 않은 경우에 대해서 끊어내 주면 된다.😀 완전 탐색(Bruteforcing)을 이용한 전략 주어진 C 문자 집합을 사전식으로 정렬 재귀 함수를 통해 주어진 C 문자 집합의 첫 요소를 가리키도록 함 다음 문자를 고려할 때 해당 문자를 포함하거나 포함하지 않은 경우를 나누어서 재귀 함수 호출 크기가 L보다 길어지는 경우 검사해서 자음 및 모음 조건을 충족했는지 확인 후 정답 리스트에 추가😉 코드로 나타내면..? (재귀 함수 사용)letters = input().split()letters.sort()가장 먼저 letters 리스트를 사전식으로 정렬한다.def generate(cipher, current, mo, ja): # 마지막 문자까지 고려해 L 길이의 암호가 생성되었을 시 조건에 맞다면 출력 if len(cipher) == L: if mo &gt;= 1 and ja &gt;= 2: if cipher not in answers: answers.append(cipher) return elif current &gt;= C: return else: # 현재 문자를 포함하지 않은 암호 생성 고려 generate(cipher, current + 1, mo, ja) # 현재 가리키는 문자가 모음인 경우 if letters[current] in mos: # 현재 문자를 포함한 암호 생성 고려 generate(cipher + letters[current], current + 1, mo + 1, ja) # 현재 가리키는 문자가 자음인 경우 else: # 현재 문자를 포함한 암호 생성 고려 generate(cipher + letters[current], current + 1, mo, ja + 1)generate(\"\", 0, 0, 0)위의 문제 풀이 전략을 그대로 코드로 구현한 부분인데,눈여겨 볼 만한 부분은 재귀 함수가 모음의 개수와 자음의 개수를 파라미터로 계속 넘겨주도록 함으로써 조건을 벗어난 경우 탐색을 끊어내도록 한 점이다.answers.sort()# 정답 출력for ans in answers: print(ans)참고로, 생성 가능한 암호를 모두 찾아낸 뒤에이 암호문마저도 사전식으로 정렬한 후 출력하지 않으면오답 처리 나니까 조심하도록 하자…💻 코드📒 연관 개념 Bruteforcing(완전 탐색) " }, { "title": "📄 백준 3980번 - 선발 명단 (Bruteforcing)", "url": "/posts/algorithm-boj-3980/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, bruteforcing", "date": "2022-06-30 17:34:51 +0900", "snippet": "📄 문제 소개백준 3980번 : 선발 명단링크 : https://www.acmicpc.net/problem/398011명의 선수 정보가 주어졌을 때, 최대 능력치를 산출할 수 있는 포메이션으로스쿼드를 구성했을 때의 능력치 합산을 구하는 문제이다.각 선수 별로 능력치는 0부터 100까지 범위의 11개 값 리스트로 주어지는데이는 해당 선수가 각 포메이션에서 가질 수 있는 능력치들이 다를 수 있음을 의미한다.또한 선수 별로 적합한 포메이션은 최대 5개까지 주어진다는 것도 확인할 수 있다.📗 문제풀이 과정🧐 일단 생각해 볼 것# player 190 85 65 0 0 0 0 0 0 0 0# player 20 80 70 70 60 0 0 0 0 0 0# player 30 0 80 75 80 90 65 0 0 0 0# player N...선수들의 능력치가 다음과 같이 주어졌다고 했을 때, 스쿼드를 구성하는 방법은player 1을 배치할 수 있는 3개 자리마다 player 2를 배치할 수 있는4개 자리를 모두 테스트해 보는 것이다.이런 방식으로 이어서 선수 11명을 모두 배치하게 된다면각 선수마다 최대 배치 가능한 포지션은 5개까지 주어질 수 있다고 했으므로최대 고려할 수 있는 스쿼드의 경우의 수는 5^11가지이다.문제에서 주어진 제한 시간은 1초로,5^11 = 125^8 &lt; 10^8이므로 구성 가능한 모든 가짓수를 고려하더라도시간 제한 1초 내에 들어올 수 있다.따라서, Bruteforcing 방식으로 접근해도 풀 수 있는 문제이다.😀 완전 탐색(Bruteforcing)을 이용한 전략 재귀 함수를 통해 현재까지 고려한 선수의 idx를 가리켜 나갈 것 다음으로 가리킨 선수가 능력치가 0이 아니면서 현재 스쿼드 상에 비어 있는 자리가 있다면 재귀 함수로 호출해 나갈 것 마지막 선수까지 지정한 후엔 호출을 종료하고 최대 능력치와 비교 후 갱신 여부 결정😉 코드로 나타내면..? (재귀 함수 사용)def place(squad, current, score): # 스쿼드가 완성되었을 때의 최대 능력치 합산 추가 if current == 11: scores.append(score) return for i in range(len(stats[current])): # 해당 선수의 능력치가 0이 아니면서 배치 가능한 위치에 있다면 완전 탐색 if stats[current][i] != 0 and squad[i] == False: new_squad = squad.copy() new_squad[i] = True place(new_squad, current + 1, score + stats[current][i]) return재귀 함수 place는 현재까지 구성된 스쿼드 정보인 squad 리스트와어떤 선수까지 지정했는지를 가리키는 current,그리고 현재 스쿼드의 능력치 합산을 담는 score를 가지고 호출해 나간다.for _ in range(T): # ... place([False, False, False, False, False, False, False, False, False, False, False], 0, 0) # ...현재 구성된 스쿼드의 빈 자리를 나타내는 squad 리스트는 위와 같이구성했는데, 좀 더 공간을 절약하려면 Bit Masking을 활용해서나타내면 좋을 것 같다.💻 코드📒 연관 개념 Bruteforcing(완전 탐색) " }, { "title": "📄 백준 14225번 - 부분수열의 합 (Bruteforcing)", "url": "/posts/algorithm-boj-14225/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, bruteforcing", "date": "2022-06-30 16:17:09 +0900", "snippet": "📄 문제 소개백준 14225번 : 부분수열의 합링크 : https://www.acmicpc.net/problem/14225N개의 수로 이루어진 수열 S가 주어졌을 때,수열 S의 요소들을 더해 나올 수 없는 가장 작은 자연수를 찾아 내는 문제이다.그런데 입력 예시로도 확인할 수 있지만,S = [5, 1, 2]인 경우 5 + 2 = 7도 조합 가능한 자연수로 판단하기 때문에실제로는 수열이라는 용어보다는 조합이라는 용어가 더 정확한 해석이다.📗 문제풀이 과정🧐 일단 생각해 볼 것S = [2, 3, 4, 5]# 1 0 0 1 =&gt; 2 + 5 = 7N개의 수가 주어졌을 때, 이 수를 서로 다르게 조합해서 어떤 수를 생성하는 작업은위처럼 그 수를 포함하거나, 혹은 포함하지 않거나로 생각할 수 있다.이 때, 조합 가능한 경우의 수는 N개 수에 대해 2^N가지가 나온다.입력으로 들어오는 N을 확인했을 때 최대 20임을 알 수 있다.이 때, 최대 2^20 = 2^10 * 2^10 ~= 10^6 정도의 시간이 걸릴 수 있으므로그냥 풀어도 시간 제한 2초 내에 들어올 수 있겠다 싶다고 판단할 수 있다.실제 이런 난이도의 문제가 코딩테스트에서 나올 경우는 거의 없겠지만서도,최대한 효율적으로 어떤 알고리즘까지 적용이 필요하다고 판단할 것인지문제 이해 단계에서 전략을 세우는 습관이 중요한 이유는시간 절약을 위해서이다.따라서 이 문제는 그냥 Bruteforcing 방식으로 접근해도 풀 수 있다.😀 완전 탐색(Bruteforcing)을 이용한 전략 재귀 함수를 통해 S의 맨 처음 요소 앞을 가리키도록 할 것 다음 요소를 포함할 지, 혹은 포함하지 않을지를 두 가지로 나누어 호출 마지막 요소를 가리키게 되면 호출을 종료하고 자연수 리스트에 체크😉 코드로 나타내면..? (재귀 함수 사용)# S의 부분 합으로 만들 수 있는 자연수 여부 체크visited = [0] * 2000000우선 생성할 수 있는 자연수를 체크하기 위해 visited 리스트를 만든다.S가 최대 20개까지 이루어질 수 있고, 단일 요소기 최대 100000이므로길이는 20000000으로 생성했다.def visit(current, sum): # S의 마지막 요소에 도달했을 때 계산된 부분합을 기록하고 종료 if current == N: visited[sum] = True; return else: # S의 current번째 요소를 포함하지 않은 부분 합 visit(current + 1, sum) # S의 current번째 요소를 포함한 합 visit(current + 1, sum + S[current])재귀 함수 visit은 현재 S의 어떤 요소까지 고려했는지를 가리키는current와 그 때까지의 부분합 sum을 파라미터로 넘기며자기 자신을 호출하는 방식으로 구성된다.만약 current == N인 경우 S의 마지막 요소까지 고려한 상황이므로생성된 부분합을 자연수 리스트에 체크하고 호출을 종료한다.current = 0while visited[current] == True: current += 1# 정답 출력print(current)마지막에 위와 같이 visited 리스트의 처음부터 읽어 나가다가False인 값을 발견하게 된다면 그 값이 생성할 수 없는 가장 작은자연수이므로 출력한다.💻 코드📒 연관 개념 Bruteforcing(완전 탐색) " }, { "title": "✅ Jekyll Blog - Liquid Syntax Error 해결", "url": "/posts/jekyll-liquid-syntax-error/", "categories": "coding, troubleshooting", "tags": "jekyll, liquid exception, liquid syntax error", "date": "2022-05-04 17:25:00 +0900", "snippet": "1. Github Action으로 글 발행 시 에러 발생Github Blog로 발행할 글을 만지다가 push하고 기다리는데시간이 지나도 글이 업데이트되지 않는다.poodlepoodle.github.io의 Repository &gt; Actions 탭으로가 보니 위와 같이 뭔가 Build 과정에서 에러가 난 것으로 보인다.2. Liquid Exception: Liquid syntax errorLiquid Exception: Liquid syntax error (line 151): Unknown tag 'F' in ...들어가서 에러 메시지를 구체적으로 확인하면태어나서 처음 보는 Liquid Exception: Liquid syntax error... 라는 에러가 발생한 것을 볼 수 있다.이전에 발행한 글 2개는 문제 없이 발행된 것을 보니ruby dependency와 관련된 것은 아닌 것 같고..뭔가 싶어 일단 검색창에 에러 메시지를 그대로 쳐 봤다. Jekyll Liquid TemplateLiquid는 ruby로 만들어진 템플릿 언어이며당연히 Jekyll에서도 이를 지원한다.그리고 보면 Liquid로 템플릿을 규정하는 표시는{ + {나 } + }로 지정함을 알 수 있다.그렇다면 만약에 markdown 파일 중간에 위의 지정 문자가 등장하면의도와 다르게 Liquid로 인식해 위의 에러가 날 수 있겠다… 싶다.3. 에러 해결 https://iamheesoo.github.io/blog/gitblog-sol-jekyll02 http://jmjeong.com/escape-in-liquid-syntax/ https://gloriajun.github.io/etc/2017/04/11/github-blog-liquid-syntax.html에러가 난 markdown 포스트를 뒤지다가뭔가 굉장히 에러 원인으로 의심되는 코드 블록을 발견했다.이를 위 링크들을 참고한 대로 { + % + raw + % + }~ { + % + rawend + % + } 블록으로 감싸 줘서자칫 Liquid로 인식될 수 있는 부분을raw text로 인식하도록 해 줬다.이후 commit 전에 bundle exec jekyll serve를 통해테스트해 보면 에러가 뜨지 않는 것을 확인할 수 있다.😙" }, { "title": "🛠 Mac OS 처음부터 세팅하기 - 개발", "url": "/posts/mac-os-setting-devs/", "categories": "coding, mac os", "tags": "mac os, xcode, vscode, zsh", "date": "2022-05-04 02:55:00 +0900", "snippet": "0. 기본 사용자 설정까지 끝낸 단계저번 포스팅에서 대부분의 Mac OS 사용자 환경 설정을 완료했다.이제 사용하던 개발 환경을 복구해 보자…..1. XcodeXcode는 Mac 앱스토어에서 설치할 수 있다.업데이트를 잘 안 하고 써서 몰랐는데 최신 버전은 Mac OS 12.0 Monterey 이상을 필요로 한다고 한다.내 맥북이 Big Sur까지만 지원하는 걸 어떻게 하리… 그냥 이전 버전 다운로드 누른다…1-1. Command Line Tools 설치xcode-select --installXcode를 설치하지 않고 git, gcc 등의 여러 도구들을 사용하기 위한 방법으로는 Command Line Tools 설치가 있다. 물론 Xcode를 설치하면 자동으로 설치되는 것으로 확인했기 때문에 본인 선택에 따라 방법을 고르면 될 것 같다. 나는 RN 개발 시 시뮬레이터 사용이나 OpenCV 개발환경 등등 고려해서 Xcode를 아예 설치하는 게 더 나을 것으로 판단했다.Xcode 프로젝트 생성 시 Command Line Tool 옵션이 뜨면 잘 설치된 거임1-2. Xcode OpenCV-C++ 개발환경 설정예전에 작성한 블로그 글 참고2. ITerm 2설치 링크Mac OS의 기본 터미널을 사용할 수도 있지만,ITerm 2를 사용하는 경우 좀 더 Appearence 면에서 커스터마이징이 가능하다.막 설치한 Vanilla 상태의 ITerm 2이제부터 터미널 명령어로 설치하고 설정해야 하는 경우들은 모두 기본 터미널이 아닌 ITerm으로 진행하겠다.2-1. ITerm 2 테마 설정2-1-1. Color Scheme 설정 - Afterglowcolor scheme 둘러보기위의 링크에서 .itermcolors 파일을 다운받은 후Preference &gt; Profile &gt; Colors 설정에서 Color Presets…를 눌러 불러와준 후 적용한다.2-1-2. 폰트 설정 - Naver D2coding설치 링크위 링크에서 폰트 설치 후 Profiles &gt; Text에서 적용폰트 크기는 한 13px 쯤 설정하면 괜찮은듯2-1-3. Word jump 단축키 설정 - Natural Text EditingITerm 2에서 기본적으로 option + 방향키나 cmd + 방향키 혹은 삭제 단축키가 안 먹혀서 추가로 Keys 탭 가서 설정하고 있다가 Stackoverflow에서Profiles &gt; Keys &gt; Preset… 에서 Natural Text Editing으로 수정하면 된다는 걸 알았다.2-1-4. 기타 설정 General &gt; Closing &gt; Confirm “Quit ITerm 2” 체크 해제 Appearence &gt; General &gt; Theme - Mininal로 설정 Profiles &gt; Text &gt; Cursor - Vertical Bar 체크 및 Blinking cursor 체크 Profiles &gt; Window &gt; Transparency 관련 설정 모두 해제2-2. Homebrew 설치설치 링크/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"Homebrew : Mac OS 전용 프로그램들을 설치할 수 있는 패키지 관리자설치하는데 시간 좀 걸림위에서 Xcode 깔면서 Command Line Tools 설치된 걸로 알았는데 또 설치할거냐고 물어본다. 왜일까…?일단은 무지성 엔터 치고 좀 기다리면 설치가 완료된다brew install wget당장 생각나는 게 없으니 wget 정도만 설치해 주고 넘어감2-3. Oh-my-zsh 설치 및 zsh 설정설치 링크sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"다음으로는 oh-my-zsh을 설치해 줄 차례이다.oh-my-zsh은 zsh 설정을 관리해 주는 오픈소스 프레임워크이다.Catalina 이후부터인가 Mac OS의 기본 터미널이 bash에서 zsh로 바뀌었다고 하는데원래부터 zsh을 사용하던 사람들에게는 익숙한 이름이다.어차피 깡통 상태에서 깐다고 생각해 ~/.zshrc 의 내용은 비어 있다고 가정하고 백업 없이 그냥 설치함설치가 완료되면 굉장히 알록달록해진 걸 볼 수 있는데 이대로 쓸 건 아니니까 몇 가지 추가 설정을 해줘야 함2-3-1. zsh 테마 설정 - powerlevel10k테마 둘러보기powerlevel10k 설치 안내위의 테마 둘러보기 가면 적용할 수 있는 다양한 zsh 테마들이 있다.어떤 걸 고르느냐에 따라 색상이나 모양을 꾸밀 수 있지만 특별히 기능이 강력해서 많이 선택받는 몇 가지 선택지가 있다.나는 그 중에서 powerlevel10k를 설치해보려고 함git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k다운받아 준 다음 ~/.zshrc 파일 내부의 ZSH_THEME=\"powerlevel10k/powerlevel10k\" 부분을 수정해주면 된다.이후 source ~/.zshrc 혹은 ITerm 재 실행자동으로 powerlevel10k의 configuration script가 실행된다.취향에 맞게 적당히 골라주면서 넘어가면 됨만약 설정을 마쳤는데 다시 고르고 싶다면 p10k configure 실행 ㄱㄱ2-3-2. zsh 추가 커스터마이징 명령어 실행 시마다 앞에 붙는 사용자 및 컴퓨터 없애기prompt_context() { \tif [[ \"$USER\" != \"$DEFAULT_USER\" || -n \"$SSH_CLIENT\" ]]; then \tprompt_segment black default \"%(!.%{%F{yellow}%}.)$USER\" fi }~/.zshrc 아래 부분에 위 내용을 붙여 주면 없앨 수 있다. zsh Syntax Highlighting 및 auto-suggestion 설치 후 적용# install zsh syntax highlighting plugingit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting# install zsh auto-suggestion plugingit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions# ~/.zshrc 파일 내에 수정plugins=( git zsh-syntax-highlighting zsh-autosuggestions) 터미널 실행 시 뜨는 last login : ....일시 On ttys.. 안 뜨도록 설정touch .hushlogin터미널 실행 후 root 경로에서 빈 .hushlogin 파일 생성 후 터미널 다시 시작하면 적용됨3. VScode설치 링크Stable build로 설치3-1. VScode 테마 설정 - Shades of Purple예전에 쓰던 테마가 뭔지 기억이 안나서 그냥 괜찮아 보이는 걸로 설치했다3-2. zsh에서 code 명령어로 실행하도록 설정Cmd + Shift + P 누른 다음Shell Command: Install ‘code’ command in PATH 선택4. Gitbrew install git git-lfs기본으로 설치되어 있으나 최신 버전으로 업그레이드git config --global user.name \"poodlepoodle\"git config --global user.email \"chammal97@naver.com\"git config --global core.precomposeunicode truegit config --global core.quotepath false계정 설정 및 한글 관련 몇가지 추가 설정을 해 준다.5. Github Bloggit clone https://github.com/poodlepoodle/poodlepoodle.github.io.git먼저 github에 올린 내용들을 clone해 온다5-1. rbenv를 통한 ruby 버전 변경brew install rbenv ruby-buildrbenv versionsrbenv install 3.1.2위 명령어를 치면 현재 Mac OS에 깔려 있는 ruby가 system 버젼을 사용하고 있음을 알 수 있다.그대로 bundle 명령어를 수행하게 되면 오류가 발생하기 때문에,rbenv install -l 명령어로 설치 가능한 stable 버전들을 확인한 후 골라서 깔아준다.(2022-05-04 기준으로 3.1.2 설치)# ruby 버전 방금 설치한 3.1.2로 지정rbenv global 3.1.2# ~/.zshrc 내 아래 내용 추가[[ -d ~/.rbenv ]] &amp;&amp; \\ export PATH=${HOME}/.rbenv/bin:${PATH} &amp;&amp; \\ eval \"$(rbenv init -)\"설치한 버젼을 글로벌 버전으로 지정해 준 다음,위의 내용을 ~/.zshrc 마지막에 추가해 준다.이후 bundle 명령어를 실행하면 자동으로 패키지들이 잘 깔린다.# 로컬에서 블로그 실행bundle exec jekyll serve# 포스트 올릴 때 commit message 양식git commit -m \":memo: [docs]: edit some posts\"git push origin main굳이 로컬에서 안 돌려봐도 typora 같은 마크다운 에디터로 미리 보고 발행할 때만 push해도 될 듯..6. React, Typescript하드 날라가면서 프론트엔드 과제 때 Prettier 다시 세팅해야겠다는걱정이 들었는데 정작 Node 날라간 건 생각 못했다….6-1. Node.js 설치설치 링크왼쪽의 LTS로 선택해서 다운로드 후 설치sudo npm install npx -g위 명령어를 통해 npx 최신 버전 설치이미 파일이 있다는 둥 에러가 뜨는데 ㄱㅊ다고 함node -v # v16.15.0npm -v #8.5.5npx -v #8.5.522-05-06 기준 설치된 버젼 체크React 개발 시 node 버전은 13 이하, 17은 피해서 설치하라고 한다…npm installreact-scripts: command not found 에러 보고 싶지 않다면프로젝트 실행하기 전에 잊지 말자…6-2. Styled-Components 설치npm install styled-componentsCss 스타일링 방식 중 Styled-Components를 사용하기 위해 설치VScode에서 Styled-Components 자동 완성 기능을 사용하기 위한 확장임6-3. Prettier 설정Extentions 탭에 들어가 Prettier를 설치Settings &gt; Prettier: Config Path에 .prettierrc 입력이렇게 하면 VSCode로 여는 모든 폴더의 .prettierrc 파일을 반영하여 에디터에서 파일을 저장할 때마다 적용됨그 다음으로 Settings &gt; Default Formatter를Prettier - Code formatter로 설정이어서 Settings &gt; Format On Save 체크{ \"trailingComma\": \"es5\", \"tabWidth\": 2, \"semi\": true, \"singleQuote\": true}마지막으로 프로젝트 루트 폴더에 .prettierrc 파일 생성 후위처럼 prettier 적용 규칙을 작성해 주면이제 저장할때마다 서식이 정리되어 적용된다.# 1. Prettier를 글로벌로 설치sudo npm i -g prettier# 2. Prettier를 이용하여 폴더 혹은 파일을 검사prettier --check . # .(현재 디렉토리)# 3. 폴더 혹은 파일 내 전체 파일을 포맷팅하여 저장prettier --write . # 전체 디렉토리가 수정되니 주의물론 Command Line으로 위와 같이 Prettier를 사용하는 방법도 있으나,위처럼 VScode 확장을 이용해 설정하면 저장 시 자동 포맷팅이 적용되므로따로 commit 때마다 신경쓰지 않아도 된다는 점이 편리함6-4. Gitmoji-cli 설정sudo npm i -g gitmoji-cliGithub commit message를 작성할 때 gitmoji를 활용하면 보기도 좋고단위 commit의 목적을 명확하게 나타낼 수 있어서 좋다.설치할 때 sudo 안 붙으면 에러남git commit -m \"메시지\"# 대신...gitmoji -cgitmoji-cli를 사용하면 gitmoji 홈페이지에 매번 들락날락 거리지 않아도적당한 키워드에 맞는 gitmoji를 추천해 준다.매우 편리하다… 나만 매번 들락날락 했나??7. Python영상 처리부터 시작해서 딥 러닝, 코딩 테스트 문제 풀이 등파이썬을 사용할 일도 많기 때문에, 관련 환경 설정 또한 필요하다.7-1. Anaconda 설치Mac OS에는 기본적으로 파이썬이 설치되어 있다.다만, 3.0 이상의 버젼은 python3 명령어로 실행해야 하는 귀찮은부분들도 있고, 여러 프로젝트에서 쓰일 환경을 애초부터 분리해관리하는 게 여러 모로 편리하기 때문에 Anaconda를 설치한다.설치 관련 포스트Anaconda의 설치에 관해서는 예전에 정리한 포스트가 있기 때문에따로 중복되는 내용을 다시 적지는 않겠다. 터미널 실행 시 자동으로 (base) 환경 자동 활성화 해제conda config --set auto_activate_base falseAnaconda를 설치하고 나서 터미널을 새로 켤 때마다(base) 환경이 활성화된 채로 열리는 것을 확인할 수 있다.위의 명령어를 통해 자동 활성화를 해제하면매번 새로운 세션이나 터미널을 열 때딜레이가 눈에 띄게 덜 걸리는 것을 확인할 수 있다.기타. 참고 링크 종합적으로 정리 잘 되어 있는 포스팅 ITerm 2폰트 Naver D2coding으로 수정 zshITerm 2로 터미널 커스텀하기Mac OS 터미널을 이쁘게 꾸며보자macOS: 기본 쉘 (shell) 이 된 zsh 설정하기 VScode터미널에서 명령어로 VScode 열기 Github BlogMac OS Ruby 버젼 관련 이슈 rbenv로 해결 Prettier프리티어(Prettier) 설정 안내대충 이정도로 일단 마무리..생각나는 거 있을 때마다 추가로 기록 예정😓" }, { "title": "🛠 Mac OS 처음부터 세팅하기 - 기본", "url": "/posts/mac-os-setting-basics/", "categories": "coding, mac os", "tags": "mac os", "date": "2022-05-03 23:43:00 +0900", "snippet": "0. 깡통 상태막 따끈따끈하게 OS만 깔린 시점부터 세팅을 시작해 보자1. Mac OS 사용 관련 설정1-1. 키보드 설정Fn 고정 해제 (ex : 음량 조절 시 fn + F11 또는 F12 작동)추후 Spotlight 단축키를 단독 F12로 지정하기 위한 빌드업임사소한 건데 자동 수정 관련 옵션들 모두 체크 해제1-2. 트랙패드 설정탭하여 클릭하기 필수 적용그냥 캡쳐해 봄전체 화면 쓸어넘기기나 mission control, launchpad 띄우기 등전부 네 손가락으로 변경 (추후 세 손가락 터치를 드래그로 설정하기 위한 빌드업)조금 전까지는 시스템 환경설정 &gt; 트랙패드에서의 적용 내용이었고세 손가락 드래그는 별개로 손쉬운 사용 &gt; 포인터 제어기 항목에서 설정할 수 있음트랙패드 사용을 압도적으로 편하게 해 주는 핵심 설정 중 하나1-3. 일반 설정다크 모드 선택강조 색상 핑크 (별 이유는 없음)1-4. 단축키 설정Spotlight 단축키 F12로 설정 (아까 Fn키 고정 해제했기 때문에 암때나 F12만 누르면 Spotlight 튀어나옴)아래는 윈도우처럼 Cmd + E로 Finder 새 창 띄우기 위한 설정사항한영 전환 Cmd + Space로 설정 (가장 익숙함)1-5. Dock 설정Dock 크기는 적당히 설정해 주고 Dock 방향은 화면 오른쪽으로 붙이기 (익숙함)1-6. Mission control 설정Spaces를 최근 사용 내역에 따라 자동으로 재정렬 체크 해제2. 필수 프로그램들 설치launchpad에서 실제로 안 쓰는 앱들이랑 자주 사용하는 프로그램들을 나눠서 폴더로 정리했다.2022-06-27 최신화poodleapps에는 추가로 설치한 프로그램들을 분류했다.(하드 날라가기 전에 깔았던 프로그램들 중 까먹은 것들이 있을 수도…) Zoom : 비대면 강의 준비물 Itsycal : 기본 작업 표시줄 시계보다 조금 더 예쁘게 생긴 시계, 캘린더 표시 가능하다는 점이 편리 카카오톡, 텔레그램 : 메신저 벅스 플레이어 : 유일하게 구독하는 음악 플레이어 Appcleaner : Mac OS에서 프로그램 삭제할 때 필수품 Keka : 압축 프로그램, Windows랑 파일 왔다갔다 할 때 편리함 Mac Fan Control : 맥북 팬 도는 강도 강제로 조절하는 프로그램(10년차 맥북 사용자에게 필수품, 설치하지 않으면 도서관에서 제트기 날라가는 지옥 펼쳐짐) Slack : 업무용 메신저로 사용 중 Amphetamine : 맥 작업 도중 꺼지지 않도록 해 줌, 이름이 아주 맘에 듦 Keynote : 프레젠테이션 제작 / 재생 Polaris Office / 한글 뷰어 : 과제 제출할 때 PPT나 한글 파일 열고 편집하기 위핢 iMovie : 영상 편집 프로그램, 명예교수님 강의 촬영 후 편집해서 드릴 때 사용함(주로 렌더링 돌리고 잠) Photoshop : 1년짜리 월 11,000원 구독 플랜 가입해 놔서 울며 겨자 먹기로 쓰는 중 Chrome : 사파리를 편하게 쓰고 있음에도 크롬을 써야 하는 상황이 분명 존재한다… 개발 관련 프로그램들은 다음 포스트에서 언급했으므로 제외함원래 앱 별로 설치 링크 포함해서 정리하려고 했으나어차피 내가 나중에 볼 용도기도 하고 귀찮아서 위에처럼 정리만 함참고로 Itsycal 적용 화면은 위와 같다…3. 배경화면 설정mesh gradients4. 현재까지 결과대충 이전에 쓰던 Mac OS 설정대로 껍데기는 어느 정도 복구된 것 같다.다음 포스팅에서는 개발 관련 툴 &amp; 개발 환경 설정 위주로 진행해 보려고 한다.그리고 방금 하드 날라가면서 모아놓은 에비츄 사진들도 같이 날라갔다는 걸기억해내서 너무 슬퍼졌다…..🥲" }, { "title": "🧱 하드 날라감", "url": "/posts/hard-disk-crashed/", "categories": "life", "tags": "fuck", "date": "2022-05-02 14:17:00 +0900", "snippet": "왜 인생의 시련은 예고 없이 찾아올까?사건의 발단 : 지난 주 화요일에 소프트웨어공학 시험을 보고 있었는데, 당시 데스크톱으로 시험을 치고 맥북 캠으로 측면 모습을 비추고 있는 상태였다. 그러다가 어느 순간 왼쪽을 봤는데 노트북 화면이 꺼져 있는 것이었다. 스페이스바나 전원 버튼을 눌러도 반응하지 않았다. 부정행위로 오해 받을까봐 놀라서 일단 바로 시험을 제출하고 맥북을 살펴봤다. 강제 종료 후 다시 전원을 넣자 시동 디스크를 인식할 수 없다는 표시가 떴다. 침착하게 디스크 유틸리티를 통해 OS 재설치를 시도하자 장착되어 있는 하드 디스크가 없다고 표시된다. 이 시점에서 뭔가 크게 잘못되었다는 것을 느꼈다.사건의 전개 : 가까운 맥북 전문 수리 센터를 알아봤다. 학교 주변 마포역에 엄청 유명한 전문가 분이 계시다는 사실을 들었는데, 연락해 보니 일주일 치 예약이 밀려 있었다. 당장 코딩 과제도 다담날까지 2개 내야 했고 블로그 포스트나 프론트 과제 복습 등 해야 할 게 많았기 때문에 일산 쪽 수리 센터에 가능한 대로 다음 날 찾아뵙기로 했다. 다음 날에 알바를 마치자마자 수리 센터에 찾아갔다.사건의 위기 : 10년 가까이 2012년형 에어를 사용하면서 말버릇처럼 “이제 바꿔야지…” 했지만 진짜로 올해 말에는 M2 에어 신형이 나오면 갈아탈 생각이었는데… 대체 뭐가 하드 디스크 인식 불량의 요인일까? 혹시 내 1300사이클을 넘어선 배터리가 살짝 팽창하면서 하드 케이블 부분의 접촉이 약간 어긋나게 된 거고 배터리만 교체하면 마법처럼 다시 돌아가는 게 아닐까? 오만가지 생각이 다 들었다. 사설 수리 센터에 찾아가서 맥북을 뜯어보자 배터리는 너무 멀쩡했고 하드 디스크와는 너무 멀리 떨어져 있었다. 수리하시는 분이 여분 하드를 연결하자 부팅이 너무 잘 이루어졌고 내 하드는 복학 후부터 저장된 2년 반의 데이터를 모두 안고 사망 선고를 받았다…. 일단 당장 사용해야 했으니 하드 디스크 교체 및 내부 청소를 20만원 주고 부탁드렸고, 하드 디스크 데이터 복구에 대해 여쭤봤으나 최소 몇십의 비용과 법원 근처 포렌식 센터로 보내질 거라는 말을 듣고 깔끔하게 떠나 보내주기로 했다. 수리를 맡기고 맥북이 없는 상태에서 4시 반 수업에 아이패드로 얼굴만 비출까 하는 생각이 들었으나 부질없는 짓이라는 생각이 들어 그냥 제꼈다.사건의 결말 : 항상 곁에 있어서 익숙한 것들은 사라지고서야 그 존재를 깨닫게 된다. 아직 push하지 않은 블로그 포스팅 마크다운 파일들, 미뤄놓고 보지 못한 최소 3주치 강의 녹화본들, 터미널부터 시작해 모든 개발 환경들 및 push하지 않은 수많은 코드들, 바탕화면 및 다운로드 폴더의 파일들 등이 벌써부터 그리워졌다. 하지만 이를 전화위복의 기회로 삼으면 좋겠다는 생각이 들었다. 어차피 고치긴 했어도 1년 안쪽으로 새 맥북으로 또 갈아타야 할 텐데, 이번에 깡통 단계부터 내가 사용하던 설정들, 프로그램들, 개발 환경 세팅 등을 나중에 따라하기 좋도록 기록해 놓으면 좋겠다는 생각이 들었다. 어차피 React-native CLI랑 Xcode 시뮬레이터도 이상하게 꼬여 있었는데 마침 깔끔하게 밀고 새로 설치하면 잘 돌아갈까 싶은 생각에 갑자기 기분이 좋아졌다. 근데 이 글을 쓰면서 폰트들이랑 anaconda 환경들도 날라갔다는 사실이 새삼 추가로 기억나서 다시 기분이 안 좋아졌다…..3줄 요약 하드 날라감 20만원 냈지만 데이터 복구 불가 정신이 피폐해짐" }, { "title": "💡 신촌 연합 IT 창업동아리 CEOS 15기 활동 시작", "url": "/posts/ceos-15th-first/", "categories": "life", "tags": "ceos", "date": "2022-04-11 20:45:00 +0900", "snippet": "개요이번 학기에는 취업에 필요한 여러 가지를 본격적으로 준비하려고 했고,그 중 하나로 다른 사람들과 장/단기 프로젝트 개발을 경험하고 싶어동아리나 학회 혹은 개발 부트캠프에 꼭 신청하고자 했다.3월 초에 에타나 교내 커뮤니티 모집 게시판을 통해여러 가지 들어가고 싶은 후보들을 뽑아서 정리해 놨었는데, 대표적으로 신촌 연합 IT 창업동아리 교내 컴퓨터공학과 프로젝트 학회 멋쟁이사자처럼 서강대등등이었다.모집 일정이 약간씩 다르고 전체적으로 보면 2주 정도 기간에 걸쳐 있어서빨리 다가오는 것부터 지원해 보며 가장 먼저 붙는 게 나오면나머지 지원은 취소하고 그거에만 전념하려는 생각이었는데,운 좋게 3월 첫 주 가장 먼저 모집한 신촌 연합 IT 창업동아리의프론트엔드 개발 파트에 최종 합격을 했고 활동을 시작하게 됐다.CEOS 15기 프론트엔드 파트 활동 시작신촌 연합(연대, 이대, 홍대, 서강대) IT 창업동아리 CEOS https://www.ceos.or.kr지원을 계획한 단체 중 CEOS에 가장 붙고 싶었던 이유는 첫 번째로 홈페이지가 굉장히 예쁘게 만들어져서그 디테일 때문에 프론트쪽에서 보고 배울 사람이 많을 것 같다는근거 없는 믿음이 있었고,두 번째로는 면접 때 들어온 질문이 기술적으로 나름 파고드는 질문이기도 했고(React Native 개발 경험과 Javascript 작동 원리에 대한 질문)면접 자체도 짜임새 있게 진행돼서 뭔가 체계적으로 돌아가는 동아리라는 느낌을 받아서였다.첫 2주를 보내고너무너무너무 바빴다.지금 이 포스팅을 쓰는 시점이 4월 둘째 주 월요일인데동아리 붙고 나서 얼마 안 되고서부터 매주 수요일 정기세션,매주 일요일 프론트엔드 스터디 세션, 그리고 아이디어톤 준비까지 해서시간을 쪼개고 쪼개서 쓰다가 이제 잠시 중간고사 휴회 기간이라틈이 생겨서 드디어 이렇게 정리해 본다.첫 2주 동안 받은 느낌을 간단히 정리하자면… 굉장히 열정적인 사람들과개발/디자인/기획에서 롤모델로 삼을 만한 사람들이 굉장히 많이 모여있다는 느낌이었다.나는 프로젝트에 대한 생각만으로 지원했는데 다른 파트의 사람들은창업에 관심이 있거나 실제로 창업을 준비하던 과정에서 지원한 사람들도 많았다.또 프론트 스터디를 진행하면서 처음으로 Vanilla JS부터 React,Typescript 등의 순서로 체계적인 미션을 수행했는데그 과정에서 처음 Github의 코드 리뷰 기능도 사용해 보고다른 프론트 동기들의 코드를 보면서 배운 점도 짧은 기간이었지만 엄청 많았다.대신 시간이 정~~~~말 많이 들어가는 동아리라서당장 1과목 드랍하고서도 최근 3주 정도는 매일 2~3시간밖에 못 잤다.그래도 그만큼 많이 얻어 가는 느낌이 들어서이제 중간고사 기간이 지나고 본격적인 팀 단위 서비스 개발 시작인데최대한 건강과 시간을 갈아넣어서 열중해보려고 한다.생각 외로 얻어가게 된 것 : 사람들나는 CEOS에 들어와서 활동하고 나서 여러 파트의 사람들과 섞여어울리고 알아가는 술자리나 모임을 네트워킹이라고 부른다는 사실을 처음 알았다.친구들이 거의 졸업하고 이제 본격적으로 혼자 학교에 다니게 된 시점에서공교롭게 새로운 친구들, 존경할만한 동생들을 많이 만나고 친해졌는데뭔가 다시 새내기 때로 돌아간 기분도 들고내 인간관계에다가 git checkout -b CEOS를 수행한 느낌이다.내가 쉽게 사람들한테 마음을 주고 친해지는 스타일이라 그런지는 모르겠지만,짧은 기간이면서도 진심으로 좋은 사람들이라고 느껴서아낌없이 이 사람들에게 빠져도 되지 않을까…. 싶다ㅎ마치며지난 한 달 반동안 이것 저것 활동하면서이거는 꼭 블로그에 남겨야지, 이거야말로 꼭 남겨야지 생각했던 게 산더미인데프론트에서 수행한 미션에 대한 포스팅은 물론이고기획 쪽에서 그룹 활동한 내용들에 대해서도 블로그에 정리하는 게내가 바라는 중간고사 휴식 기간 내의 최대 목표이다.동아리 맨 처음 들어가고 첫 전체 세션 때 자기 PR 진행하면서마지막에 덧붙였던 말인데,나는 “지금까지 내 인생에서 나를 크게 성장시키거나 크게 바꿨던 사건들은전부 우연한 호기심에서 시작됐다” 고 생각한다.아직 한 달 반밖에 지나지 않았지만, CEOS가 벌써부터 나라는 사람을정말 많이 바꿔 놨고 아직도 많은 일들이 기다리고 있는 것 같아 기대된다 ㅎㅎ😉" }, { "title": "💻 OpenCV C++ 개발환경 설정 (Windows/Mac OS)", "url": "/posts/opencv-installation-windows-mac/", "categories": "coding, c++", "tags": "coding, c++, opencv, visual studio, xcode", "date": "2022-03-17 02:43:00 +0900", "snippet": "개요2022-1학기에 디지털영상처리개론 수업을 들으면서OpenCV를 이용한 과제들을 수행할 필요가 생겼다.작년 여름방학에 연구실 DIP 세미나 준비하면서 한 번 Xcode로 개발 환경을 세팅한 적이 있긴 했는데Windows보다는 몇 가지 자잘하게 세팅해야 하는 부분들이 있었다.그래서 이번에 다시 과제 제출용으로 프로젝트 생성하면서Windows/Mac OS에서의 OpenCV 개발환경 세팅 방법을포스팅으로 정리해보기로 했다.OpenCV?OpenCVOpenCV는 Real-Time Image Processing과Computer Vision 기술들을 다루는 데 있어서매우x3 편리한 C++ 라이브러리이다.C++로 구현되어 있지만 Python, Java로도 Full Interface를 제공한다.Image Processing 관련 코드 구현이나관련 질문 글들을 구글링해보면 거의 모든 코드가OpenCV에서 제공하는 함수들을 가져다 사용하는 걸 볼 수 있다.그만큼 편리한데 성능도 매우 빠르다.Installation (Windows)1. Microsoft Visual Studio 2022 설치Microsoft Visual Studio Visual Studio 2022 다운로드 (공식)Windows 환경에서는 Microsoft Visual Studio를 사용하는 것으로 권장된다.위의 공식 홈페이지에서 Community 2022 버젼을 다운로드받는다.설치를 선택하면 위의 워크로드 항목에서설치할 개별 구성 요소를 선택하는 부분이 있는데C++을 사용한 데스크톱 개발만 체크해주고 넘어가면 된다.기본 IDE에 구성 요소 설치까지 용량이 꽤 크기 때문에자기가 여유 있다고 생각하는 파티션으로 설치 위치를 변경해주면 좋다. (기본은 C드라이브)설치에는 평균 한 20~30분 정도가 소요된다.설치가 완료되면 Microsoft 계정으로 로그인하라는 메세지가 뜬다.당장은 로그인을 하지 않아도 문제가 없으나30일 뒤부터는 Community 라이센스가 만료되었다는 알림과 함께 로그인을 해야만계속 무료로 사용 가능하므로 귀찮지만 지금 로그인해 두는 게 낫다…2. 새 CMake 프로젝트 생성설치가 완료되면 새로운 프로젝트를 생성한다.프로젝트 형식은 CMake 프로젝트를 골라 준다.잠시 기다리면 헤더(.h) 파일과 소스 파일(.cpp)를 포함한프로젝트 폴더가 생성된다.3. OpenCV 라이브러리 설치 OpenCV 라이브러리 다운로드그 다음으로는 잠시 Visual Studio를 내려 놓고위의 OpenCV 공식 홈페이지로 들어간다.맨 위에 Latest Release의 Windows 버튼을 통해인스톨러 프로그램을 다운받는다.인스톨러를 실행시키면 선택한 경로에 라이브러리 패키지가 압축 해제된다.압축 해제된 폴더는 크게 source와 build 2개인데,당장 필요한 건 이미 빌드된 라이브러리 파일이므로 build 폴더만 복사한다. C:₩opencv-sources₩buildC드라이브 바로 하위에 opencv-sources라는 빈 폴더를 만든 후그 안에 아까 복사한 build 폴더를 붙여넣기한다.build 폴더의 크기가 1GB를 좀 넘기 때문에 용량 문제로 대신D드라이브에 만들겠다 싶은 사람들은 상관 없지만,프로젝트 빌드 설정 파일들(예시 : CMakeList.txt)에서 경로를 일치하도록 신경 써야 한다.4. CMake 프로젝트에서 OpenCV 라이브러리 불러오기cmake_minimum_required(VERSION 3.0)set(opencv_DIR \"C:/opencv-sources/build\")find_package(opencv)include_directories(${OpenCV_INCLUDE_DIRS})get_filename_component(ProjectId ${CMAKE_CURRENT_LIST_DIR} NAME)string(REPLACE \" \" \"_\" ProjectId ${ProjectId})project(${ProjectId} C CXX)set(CMAKE_CXX_STANDARD 11)file(GLOB SOURCES *.cpp)add_executable(${PROJECT_NAME} ${SOURCES})target_link_libraries(${PROJECT_NAME} ${OpenCV_LIBRARIES})이제 다시 Visual Studio로 돌아간다.그 다음 CMakeList.txt 파일의 내용을 위와 같이 수정한다.만약 바로 전 단계에서 용량 확보 등의 문제로C:₩opencv-sources₩build 대신 다른 경로로 붙여넣은 사람들은두 번쨰 줄 경로 부분을 그에 맞게 수정해 줘야 한다.이는 컴파일 및 빌드 단계에서 아까 옮겨놓은OpenCV 라이브러리 빌드 파일을 포함하기 위한 CMake 설정이다.5. 프로젝트 빌드#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;using namespace std;using namespace cv;int main(int, char**){ Mat img_in = imread(\"Test.tif\", IMREAD_GRAYSCALE); int H = img_in.rows; int W = img_in.cols; if (img_in.empty()) { cout &lt;&lt; \"Image does not exist.\" &lt;&lt; endl; return 1; } for (int i = 0; i &lt; H; i++) { img_in.at&lt;uchar&gt;(i, 20) = 255; } imwrite(\"Save.tif\", img_in); return 0;}Cameraman(Before) / Cameraman(After)Visual Studio 환경에서 OpenCV 라이브러리를 이용해컴파일 및 빌드를 진행할 수 있는 환경 구축을 모두 끝냈다.Control + F5로 간단한 예제 코드를 실행시키면OpenCV에서 제공하는 기능이 잘 동작함을 확인할 수 있다.Installation (Mac OS)1. Xcode 설치Mac OS 환경에서는 Xcode를 사용해서 프로젝트를 빌드하는 방법을 설명한다.Xcode가 깔려 있는 사람은 넘어가고깔려 있지 않은 사람은 App Store에서 설치해주면 된다.2. Homebrew를 통한 패키지 설치brew install gitbrew install opencvbrew install pkg-config Homebrew 설치그 다음으로는 Homebrew를 사용해서 OpenCV를 설치해주면 된다.Homebrew는 Mac OS에서 여러 패키지들을 편리하게 설치하고관리할 수 있는 패키지 관리자인데,만약 깔려 있지 않다면 위의 링크를 통해 brew를 먼저 설치해야 한다.Homebrew 설치가 끝나고 나면위의 명령어들을 통해 필요한 패키지들을 설치한다.설치가 끝나고 나면 brew list를 실행시켜패키지들이 잘 설치되었는지 확인한다.3. 새 Command Line Tool 프로젝트 생성Xcode 설치가 완료되었다면 Command Line Tool로 새 프로젝트를 생성한다.4. Xcode 프로젝트에서 OpenCV 라이브러리 불러오기 /usr/local/Cellar/opencv/o.o.o_o(본인 설치 버젼)/include/opencv4# OpenCV 설치 경로 확인ls /usr/local/Cellar/opencvXcode 프로젝트 생성 후 프로젝트명 - Build Setting으로 진입하면탭 바로 밑에 검색창이 있다.이 검색창에 Header Search Paths를 검색한 후해당 옵션이 나오면 위의 경로를 추가한다.중요한 점은 자신의 설치 버젼을 확인하고 경로에 그 버젼을 맞춰서 적어줘야 한다는 점인데,위 명령어를 통해 자신의 설치 버젼을 확인할 수 있다. /usr/local/Cellar/opencv/o.o.o_o(본인 설치 버젼)/lib이번에는 Library Search Paths를 검색한 후,옵션이 나오면 위의 경로를 추가한다.아까와 마찬가지로 본인 버젼에 맞게 경로에 포함한다.이번에는 검색창에 other linker라고 쳐 보자.Linking 항목의 Other Linker Flags 하위 항목을 발견할 수 있다.# 링크 플래그 확인pkg-config --cflags --libs /usr/local/Cellar/o.o.o_o(본인 설치 버젼)/lib/pkgconfig/opencv4.pc터미널에 위 명령어를 치면 링크 플래그들을 추출할 수 있다.출력되어 나오는 긴 텍스트들을 싹 긁어서 복사한다.그 다음 아까 Xcode에서 검색했던 Other Linker Flags 항목에복사한 값을 붙여넣기 해서 추가해 주면 된다.거의 다 끝났다.이번에는 상단 Product&gt;Scheme&gt;Edit Scheme를 클릭한 후,Options 탭의 Use custom working directory를 체크한다.아래의 칸 오른쪽 버튼을 누르면 디렉토리 선택 창이 열리는데,쭉 타고 들어가다가 Xcode 프로젝트를 통해 생성된 main.cpp가 존재하는경로를 발견할 수 있다. 동일 디렉토리 안까지 타고 들어가서 선택 버튼을 누른다.여기까지 했으면 끝!!이어야 하지만… 컴파일 시 _abort_with_payload 에러가 자꾸 떠서 당황했다.구글링하니까 Signing &amp; Capabilities - Hardened Runtime 항목의Disable Library Validation을 체크하지 않아서 발생하는 문제라고 한다.해결하는 데 오래 걸리진 않았지만,포스팅을 보는 분들의 시간 낭비를 막기 위해 함께 적는다.5. 프로젝트 빌드Command + R을 통해 컴파일이 잘 이루어진 모습이다.참고 링크 https://www.vbflash.net/83 https://velog.io/@chy0428/opencv-install-for-mac끝으로…간단히 C++을 통한 OpenCV 개발 환경을 구축해봤다.인터넷에서 OpenCV에 관한 스택오버플로우 질문이나 포럼 글들을 읽다 보면요즘은 Python을 더 많이 쓰는 느낌이다.Python으로 OpenCV 환경을 설정하려면간단하게 Anaconda로 cv2를 설치하는 것만으로 간단하기도 하고,Vision 분야의 딥 러닝 연구 같은 경우Python 라이브러리들을 많이 쓰니까 그런가 싶기도 하다.어쨌든, 이 수업에서 C++을 사용하는 이유는간단히 라이브러리 기능을 이용해서 할 수도 있는 영상 처리 기법들을직접 함수로 구현하고 깨닫기 위함이 이 수업의 목적이고,그 목적에는 Python보다 C++이 적절하다고 교수님은 생각하신 게 아닐까..?어쨌든, 이걸로 인트로를 마치고추후 중요하다고 생각되는 개념들은 실습이 끝날 때마다따로 계속 포스팅할 예정이다.📷" }, { "title": "📚 2022년 봄학기의 공부/복습 플랜", "url": "/posts/study-plan-spring-2022/", "categories": "life", "tags": "2022년, study", "date": "2022-02-28 17:45:00 +0900", "snippet": "작년 이맘때쯤 이제 4학년이라는 포스트를 남겼던 것 같은데,많은 일들로 인해 어떻게 다시 또 4학년을 마저 보내게 됐다.얼마 전에 친구들 졸업식 사진에 끼러 다녀왔는데학위복을 입고 모자를 던지는 친구들을 보자 마음이 매우 허했다……….올해는 꼭 취업에 성공해보도록 하자..8학기의 시간표 (21학점) 2022.03.02 수정사항 프로그래밍언어 -&gt; 디지털영상처리개론 과학사 -&gt; 소프트웨어공학 2022.03.07 수정사항 캡스톤디자인1 수강취소 2022.03.08 수정사항 인공지능통신 수강신청 이번 학기부터는 정규 학기 기준으로 막학기 요건을 충족했기 때문에 (4학년 2학기)19학점을 넘어 22학점까지 수강이 가능하도록 풀렸다.나는 전자공학과의 전공 선택을 다 채웠기도 하고컴퓨터공학 쪽 전공 선택 학점이 좀 부족해서 이번 학기는 거의 컴퓨터공학과 학생처럼 지낼 예정이다.2학년 1학기 때 수업 시간에 잠만 자면서 명예교수님께 D0를 받은디지털회로설계를 재수강하기로 했다.마침 2학기 때 들어야 하는 컴퓨터공학실험2 과목이 디지털회로설계 기반이기도 하고 해서리뷰할 목적으로 겸사겸사 수강 신청했다.기초컴퓨터네트워크랑 데이터베이스시스템은 예전에 학점이 남으면 듣고자 했던 수업인데마침 이번 학기에 열려서 수강신청했다.소문으로만 들었던 컴공 소 교수님의 명강의를 들을 생각에 벌써 소름이 돋는다.고민하다가 3월 2일부로 수강 허가를 받아 프로그래밍언어를 버리고 같은 시간대의 DIP를 신청했다.수강신청 전부터 많이 고민하다가 컴공 전공 선택 학점을 채워야 하기도 하고프로그래밍언어 과목에서 다루는 각 언어 별 구조 차이나 디자인 패턴 등을 배우고 싶었는데졸업하고 나면 컴퓨터 비젼 과목 안 듣고 졸업한 게 진짜 너무 후회될 것 같아서 DIP로 최종 선회했다.그리고 생각보다 PL이 좀 예전 커리큘럼 위주로 다뤘다는 강의평 불만들도 있고컴파일 같은 궁금했던 부분들은 다음 학기의 기초컴파일러 과목으로 제대로 파고들자고 생각했다.대신 부족한 학점을 위해 과학사를 계절학기로 넘기고 소프트웨어공학을 추가 신청했다.캡스톤디자인1은 SwiftUI를 이용한 IOS 애플리케이션 설계 및 개발을 하는 프로젝트 과목이라는데,이번 1학기 가장 공들여 보고 싶은 과목이다.이전 2020년도 2학기에 수강했던 디자인프로젝트에서 개발했던 애플리케이션은딥러닝 모델 성능 향상에 시간을 많이 투자했기 때문에사실상 이번이 학교 프로젝트로는 처음 진행하는 개발 프로젝트인데,깃헙을 이용한 협업이나 개발 프로세스 등을 익힐 수 있는 좋은 기회라고 생각한다.3월 7일자로 캡스톤디자인1 과목을 수강 취소했다.IOS 프로젝트를 해 보고 싶어서 신청한 과목이었는데올해 커리큘럼이 안드로이드 개발로 바뀌었기도 하고,꼭 붙었으면 좋겠다 생각했던 신촌 연합동아리에 붙어서이번 학기에 진행하려던 프로젝트는 연합동아리 쪽에 전념해야겠다고 결정했다.3월 8일 수강신청 정정기간이 끝나기 3분 전에인공지능통신 과목을 수강신청했다.사실 이번 학기 수강 가능 최대 학점이 22학점인데저번 학기랑 마찬가지로 19학점만 신청하는 게 아깝게 느껴져서 신청한 것도 있고,전자과에 몇 없는 ML을 다루는 과목인데Backpropagation이나 Chain rule 같은 개념들에 대해서내가 수학적으로 이해가 부족하다고 생각해자연스럽게 짚고 넘어갈 수 있는 계기가 되었으면 하는 마음에서 신청했다.3월 8일 인공지능통신을 마지막으로 더 이상 신규 과목은 신청할 수 없게 됐다.듣고 싶은 과목은 다 담았기 때문에 후회는 없고,결론적으로 재수강 희망 과목, 전자과 전선, 컴공 전선을모두 안고 가게 됐는데 최대한 효율적으로 학기를 마쳐서최대한 많이 이해하고 머릿속에 남았으면 좋겠다.드랍 안하고 학기 마쳤을 때 평균 B0 이상에 A0 두어 개 섞여 있으면 행복할듯…📚 공부 계획 예습은 직전 수업에서 다뤘던 분량만큼만 강의자료 미리 숙지해보는 정도 복습은 주차별로 나눠서 강의자료 필기 다시 읽어보고 정리하는 정도로 진행 중요 과목의 경우만 주차마다 복습한 진도를 블로그에 포스팅이전 학기에 복습 계획을 세워 놓고 잘 진행하지 못했던 점이모든 과목에 대해서 블로그에 복습 포스팅을 하려고 했던 것이라고 생각한다.이번 학기에는 현실적으로 주어진 시간 내에 중요한 과목 한 두개 정도만 블로그에 정리하고 (DIP, 네트워크, 캡디1 고려 중..)나머지는 아이패드에 필기한 내용을 다시 읽어서 각인시키는 정도로 복습을 진행하고자 한다.위에서 최대한 줄인 시간을 코딩 테스트 준비나 개인 사이드 프로젝트에 투자하는 게 목표다.지난 학기를 막 끝낸 시점의 내가 개강을 앞두고 있는 나에게하고 싶은 말을 몇 가지 정리하는 것으로 포스트를 마치겠다. 완벽하게 하려고 미루지 말고 엉성해도 일단 완료에 목적을 두자 뭐 하나 디버깅/빌드 돌려놓고 쉰다고 유투브 틀지 말자 카페에서 공부하다가 이 정도면 오늘은 쉬어야지 지1랄 하지 말고 마감 시간까지 남도록 노력하자제발 시간좀 아껴써!!" }, { "title": "💻 코딩 테스트를 위한 C++ 정리 0. 개요", "url": "/posts/cpp-for-coding-test-0/", "categories": "coding, c++", "tags": "coding, c++, coding test", "date": "2022-02-23 20:11:00 +0900", "snippet": "개요작년 2학기부터 알고리즘 문제풀이 스터디를 계기로본격적으로 코딩테스트를 위한 알고리즘 공부를 시작했는데,그 동안에는 거의 파이썬으로만 문제풀이를 시도했다.그러면서 느낀 게, 스터디 멘토님도 그렇고교내 알고리즘 동아리나 개인적으로 알고리즘 공부를 한 경험이 있는 스터디원들은문제풀이에 C++을 많이 사용한다는 걸 느꼈다.OpenFramework나 OpenCV로 C++ 코딩을 해본 적은 있었는데스터디원들이 C++로 작성한 알고리즘 코드들은코드를 감싸고 있는 부분이나 선언 부분이 (나는 처음 보는데) 굉장히 비슷한 구성을 가지고 있었다.그래서 알고리즘을 풀 때 C++을 사용하는 경우사용하는 틀이나 선언 부분이 있나? 싶어서 개인적으로 궁금해졌다.뿐만 아니라, Map 같은 C++ 자료구조나 STL이문제풀이에서 자주 활용되는 걸 보고한번 블로그에 리뷰하는 느낌으로 정리 글을 작성해보고 싶었는데방학이 끝나기 직전에 첫 글을 시작해 보기로 한다.순서먼저 C++의 문법을 요약해서 빠르게 훑은 후,문제풀이에 사용되는 C++ 코드들의 관용적인 부분이나자료구조 활용 등으로 시리즈를 마무리할 예정이다.포스팅의 목적 내가 앞으로 코딩테스트 주 언어로 C++에 익숙해지기 위함 이미 다른 한 가지 이상의 언어에 익숙한 사람이 빠르게 읽고 받아들일만한 코딩 테스트용 C++ 핵심 정리추후 문제 풀이지금 이 블로그에 작성하는 알고리즘 &amp; 문제풀이 내용들로는크게 문제풀이와 알고리즘 소개 카테고리가 있는데,코딩 테스트를 위한 C++ 시리즈 정리를 마치고 나면앞으로 작성하는 문제풀이나 알고리즘 소개 글들은왠만한 경우 C++로 코드를 첨부할 예정이고,실제로 문제 풀이도 C++을 우선적으로 사용하려고 한다.끝으로…집에서 짜투리 시간이 생길 때마다 쌓아 놓은 문제 풀이를 시도하고 있다.나름대로 생각한 전략이,문제에 아예 무작정 부딪히는 게 아닌,문제에서 어떤 알고리즘 전략을 사용하는지 정도는 알고 푸는 것이다.그 동안 코딩이나 개발 경험에서 벽을 느낄 때마다무작정 삽질하는 게 깨달음을 얻는 경우가 많았는데,알고리즘 같은 경우는 좀 다르게 접근하려고 한다.간단한 예시로, 부분합에 관련된 문제들을 처음 접했을 때아무것도 모른 채 거기서부터 삽질을 시작했다면내가 스스로 깨우치더라도 오랜 시간이 걸린 뒤이며그런 방법들로는 수많은 문제 풀이 개념들을 이해하는 데 너무 비효율적일 것이다.아직 내가 문제풀이에서 사용되는 알고리즘 기법들에 대해많이 모르기도 하고, 많은 문제를 풀어 본 것도 아니라는 걸 인정해야 한다.새로운 개념을 접하는 순간 핵심 아이디어를 빠르게 이해하고그 전략을 사용한 대표 문제 -&gt; 활용 문제들 순서대로 풀어 보려고 한다.추가로, 알고리즘 스터디에서 멘토님이 알려주신 대로문제를 보자 마자 제공하는 제한 시간이라던지 입력 크기를 사용해최대한 시간 복잡도를 얼마나 줄여야 하는지에 대해 빠르게 분석하는 연습을 하고 있다.지금은 스스로 익숙해지기 위해시간 복잡도를 어디까지 줄여야 하는지 계산이 나오더라도일부러 하나씩 단계를 줄여 가면서 시간 초과가 나오는 걸 확인해 보고 있는데,코딩 테스트 같은 실전에서는 바로 계산된 시간 복잡도에 맞는 알고리즘을 적용하면이전보다 꽤 효율적으로 문제 풀이에 접근할 수 있을 것 같다.😎" }, { "title": "📄 백준 2003번 - 수들의 합 2 (Two Pointer)", "url": "/posts/algorithm-boj-2003/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, two pointer", "date": "2022-02-07 16:51:00 +0900", "snippet": "📄 문제 소개백준 2003번 : 수들의 합 2링크 : https://www.acmicpc.net/problem/2003N개의 자연수를 입력받아 배열을 구성하고,배열 내부에서 구간 (i, j)를 설정했을 때해당 구간의 합 A[i] + A[i + 1] + ... + A[j]가M이 되는 구간의 경우의 수를 구하는 문제이다.📗 문제풀이 과정🧐 일단 생각해 볼 것# N과 M 입력N, M = map(int, input().split())# 배열 A 입력A = list(map(int, input().split()))cnt = 0for i in range(N): # O(N^3) for j in range(i, N): _sum = 0 for k in range(i, j + 1): _sum += A[k] if _sum == M: cnt += 1print(cnt)문제를 보자 마자 가장 간단하게는 위처럼 모든 구간을 훑는반복문 구조로 구성할 수 있겠으나,이 경우 구간 (i, j)의 합을 구하는 데 O(N)이 걸린다고 가정하면전체 알고리즘의 시간복잡도는 O(N^3)이 된다.그리고 문제에서 N이 최대 10^4이고 시간 제한이 0.5초이기 때문에,시간복잡도가 O(N^2) 보다 커지는 위 알고리즘으로는문제를 절대 시간 내에 풀 수 없다고 생각해야 한다.😀 Two Pointer를 이용한 전략위 문제가 대표적으로 two pointer 알고리즘을 사용하는 예시이다.우선, left와 right 두 개의 포인터가맨 처음엔 배열의 첫 번째 요소를 가리키도록 한다.left와 right는 매 순간 어떠한 구간을 가리킨다.right가 1 증가하는 것은 구간이 오른쪽으로 늘어난다는 것을 의미하며,마찬가지로 left가 1 증가하는 것은 구간이 왼쪽으로부터 줄어든다는 것을 의미한다.우리가 목표로 하는 것은 구간의 합이 M이 되는 순간을 체크하는 것이며,문제에서 주어진 대로 배열 A의 모든 요소들은 30,000을 넘지 않는 자연수이다.따라서 구간의 합은 right를 증가시킬수록 늘어나며left을 증가시키면 줄어드므로이로부터 구간의 합이 주어진 기준 M보다 작다면 right를 1 증가시키고M보다 크다면 left를 1 증가시키는 방식으로구간 합을 검사해 나갈 수 있다는 것을 알 수 있다.또한, left나 right가 증가하는 순간마다그때까지의 구간 합을 sum에 저장하고 있으므로단순히 sum -= A[left]나 sum += A[right]를 수행함으로써구간 합의 변화를 상수 시간 : O(1) 내에 계산할 수 있다는 게 핵심이다.😉 코드로 나타내면..? (for 사용)# N, M 입력N, M = map(int, input().split())# 배열 A 입력A = list(map(int, input().split()))cnt = 0 # 경우의 수를 체크하는 카운터 변수left = 0 # left pointerright = 0 # right pointer_sum = 0 # 구간의 합을 저장하는 변수for left in range(N): # O(N^2) # right를 가능한 한 증가시키면서 늘어나는 구간의 합 반영 while _sum &lt; M and right &lt; N: # O(N) _sum += A[right] right += 1 # 구간의 합이 M인지 검사 if _sum == M: cnt += 1 # left를 증가시키면서 줄어든 구간의 합 반영 _sum -= A[left] print(cnt)left가 right보다 커질 수 없기 때문에,위처럼 for문을 이용해 left를 N만큼 반복하고right가 증가될 수 있는 조건만큼 최대한 커지도록 하면모든 가능한 구간의 합을 검사하는 데 O(N^2) 의 시간복잡도를 만족할 수 있다.위 알고리즘을 따라가다 보면생각과 다르게 left와 right가 모두 마지막 요소를 가리키기까지 기다리지 않고위 그림 같은 상황에서 수행을 완료해 버림을 알 수 있다.그 이유는 위처럼 포인터들이 가리키고 있는 경우 right는 N 이상 증가할 수 없으며left를 증가시켜 봤자 sum은 M보다 작아질 수 밖에 없으므로다음 단계들을 의미 없는 수행으로 판단하고 종료하기 때문이다.또한 이 코드를 보다 보면 left가 right보다 커지는,그러니까 반전된 구간까지도 중복될 수 있지 않나? 하는 의문을 가질 수도 있는데그런 경우는 left가 증가되면서 sum에 A[left]만큼 감소되므로구간의 합이 다시 만족될 때까지 right가 left 이상으로 다시 증가하므로문제가 되지 않는다.😉 코드로 나타내면..? (while 사용)# N, M 입력N, M = map(int, input().split())# 배열 A 입력A = list(map(int, input().split()))cnt = 0 # 경우의 수를 체크하는 카운터 변수left = 0 # left pointerright = 0 # right pointer_sum = 0 # 구간의 합을 저장하는 변수while True: # O(N^2) if _sum &gt; M: # 구간 합이 M보다 크면 left 증가 _sum -= A[left] left += 1 elif right == N: break else: # 구간 합이 M보다 작으면 right 증가 _sum += A[right] right += 1 if _sum == M: # 구간 합이 M이면 cnt 증가 cnt += 1print(cnt)만약 for문을 이용하지 않고 while 문을 이용해 구현하도록 하면,위처럼 코드를 구성할 수 있다.이 때는 구간 합을 M에 비교해 가며 각 상황마다 left와 right를 증가시키며,right가 N보다 커지는 순간을 탈출 조건으로 설정해 주어야 한다.💻 코드📒 연관 개념 Two Pointer(투 포인터) " }, { "title": "🏠 Tistory -> Jekyll Blog로 이사", "url": "/posts/jekyll-blog-move/", "categories": "life", "tags": "blog, jekyll, github blog", "date": "2022-01-26 20:11:00 +0900", "snippet": "블로그 이사?지난 21년 2월에 Tistory를 선택 후 본격적으로 블로그 포스팅을 시작하고 나서(참고)연초 목표나 각 학기 개강/종강마다 다짐을 적으면서 일년을 보람차게 보내는 데 적지 않게 도움이 됐다.그럼에도 언젠가는 꼭 Github Blog로 이사해야지 싶은 막연한 생각이 있었는데최근에 그 생각에 불을 지핀 계기가 몇 개 있었다.이유 1 - 마크다운 지원티스토리에서 글을 작성하다 보면 간혹 에디터에서 보는 모습과실제 포스팅을 게시했을 때의 문단 간격이나 폰트 크기가 차이났을 때가 많아서나중 가서는 에디터 설정을 마크다운으로 맞춰 놓고 사용했다.근데 에디터 기본 설정이 티스토리 글쓰기 디폴트로 설정되어 있어서마크다운으로 작성한 글을 수정하기로 눌렀을 때 다르게 보이기도 했고,티스토리에서 지원하는 마크다운으로 쓰는 경우 줄 바꿈이나 이런 부분에서 br 태그를 이용해야원하는 대로 보인다는 단점이 계속 신경쓰였다.이유 2 - Code Highlighting가장 큰 이유인데, 티스토리의 코드 인용이 별로 맘에 들지 않았다.알고리즘 문제 풀이 포스팅 같은 경우 포스팅 하나에 코드 블럭이 여러개 들어갔는데,가끔 파이썬으로 지정해 놓은 코드 하이라이팅이 C로 지정되어 보이거나 등의 오류가 있었다.또한 티스토리 마크다운으로 끼워 넣은 인라인 코드 하이라이팅도 맘에 안 들어서 벼르고 있었다.Jekyll Blog 그래서…-.github.io로 호스팅하는 블로그를 사용하기 위해서 최근 며칠 동안 작업했다.테마 적용 및 Github Action 연결 등의 자세한 설치 과정 은project &gt; blog 카테고리에 추가로 작성할 예정이다.Jekyll을 이용하기로 정하고 나서 어두운 테마로 꾸미고 싶어서Jekyll Theme을 한동안 뒤지다가 dark poole 등 후보를 몇 개 정했는데,그 중에서 지금 사용하고 있는 chirpy라는 테마가code highlighting도 독특하고옆에 마크다운으로 작성한 내용을 바탕으로 바로가기 띄워주는 것도 맘에 들었다.안 그래도 예전 맨 처음 블로그 플랫폼을 고르고 있었을 때velog의 바로가기 기능이 맘에 들어서 티스토리와 많이 고민했었는데..어쨌든 이러한 이유들로 chirpy 테마를 사용하기로 정하고며칠간 사소한 디테일들을 커스터마이징했다.결론이제는 티스토리에서 비공개로 남겨둔 글을 제외하고는 전부 이사 완료해서,앞으로는 쭉 여기서 포스팅을 이어가려고 한다." }, { "title": "📷 머선129 개발 로그 0. 연구 배경/디자인 시안 구상/프로젝트 초기 설정", "url": "/posts/ms129-devlog-0/", "categories": "projects, ms129", "tags": "project, ms129, react native, expo", "date": "2022-01-11 03:15:00 +0900", "snippet": "지난 2학기에 디자인프로젝트를 수행하기 전에방학때 진행했던 세미나 복습부터 디자인프로젝트 제안서, 중간보고서, 그리고 중간 연구 과정들도블로그에 포스팅을 해야겠다고 거창하게 목표를 세웠는데,중도 휴학 때문에 중간에 정신이 없었기도 하고당장 포스팅하기보다 개선 사항 찾아서 학습 돌리기 바쁘다 보니 포스팅을 아예 하지 못했다.디자인프로젝트가 모두 끝나고 방학을 맞은 이 시점에서개발 소스를 깃헙에 정리하는 동시에, 프로젝트에서의 애플리케이션 파트를 혼자 구현하면서어떠한 이슈들을 직면했고 어떤 접근으로 해결했는지 등을 다시 포스트로 남겨놓으면 좋겠다 하는 생각이 들었다.어차피 현재 API 서버 연결 부분을 제외하고 80~90% 정도 애플리케이션이 구현된 단계에서디자인프로젝트가 끝났다는 이유로 애정 담긴 프로젝트를 던져 버리고 싶지 않았기도 하고…이후 시간 날 때마다 개발을 이어나가 꼭 출시하고자 하는 게 올 해 목표에 있기 때문에우선 지금까지의 과정을 remind 차원에서 포스팅하고앞으로 이어서 개발하는 과정 또한 쭉 포스팅해 나가면 될 것 같다.첫 포스트는 주제 선택 동기, 앱 아이디어 구체화, 그리고 어떤 개발 환경을 구축했는지부터 정리해 보려고 한다.📋 1. 연구 배경🙂 A. 디자인프로젝트를 수강한 계기주제를 선정하게 된 배경을 설명하려면 내가 디자인프로젝트를 하게 된 계기부터 시작할 필요가 있다.원래 디프는 전자공학과 심화전공, 그니까 단일 전공으로 졸업하게 되는 경우필수 설계 학점을 채우기 위해 들어야 하는 과목이었다.그래서 컴퓨터공학을 다전공하는 나는 디자인프로젝트가 필수가 아니었고,굳이 다른 친구들이 말리지 않아도 애초에 이수할 생각조차 없었다.그러다가 2021년도 1학기에 어느 교수님께서 진행하시는 마이크로프로세서 수업을 듣고 나서교수님의 열정, 말씀해주시는 공학자로써의 태도 등 교수님께 반해버리고디자인프로젝트를 교수님이 계시는 영상처리 연구실에서 진행하기로 결심했다.별개로 이맘때 쯤에 개인 프로젝트를 진행해보고 싶은 생각이 있었는데디자인프로젝트를 통해 맘에 드는 주제를 선정하고 그 프로젝트를 3~4개월 간 진행하면서교수님과 석사 분들의 피드백을 받고 연구실 서버 등 리소스를 사용할 수 있는 환경이어떻게 보면 너무 좋은 프로젝트 환경이 아닌가 싶어서 결과적으로 디자인프로젝트를 수강 신청하게 됐다.🔥 B. 주제 선정 동기재작년, 작년 우리 연구실에서 진행한 주제들을 확인해 봤을 때영상처리를 통한 축구 오프사이드 판독기나 시각 장애인을 위한 점자 블록 인식기 등이 있었다.보통 전자공학과 졸업 작품이라는 특징 때문에 학술제에 출품되는 주제들이반도체나 회로, 통신 관련 연구주제들이 많은데,이런 점에서 영상처리, 딥러닝 기술을 활용하면서도 실제 결과물이 와닿는 주제를 하기로 마음먹었다.팀원은 나를 포함해 전부터 친했던 친구들 3명으로 구성됐는데,처음에 제안했던 블랙박스 영상을 통한 교통사고 과실 비율 판독기,CCTV 영상을 이용한 도서관 자리 점유 판독 시스템 등은 여러가지 이유로 석사 형들 선에서 리젝당했다.그 과정에서 GAN, Generative Adversarial Network를 이용한 주제는 어떻겠냐는 피드백이 있었고최종적으로 개강을 일주일 정도 앞두고 추려진 주제인 강아지 영상을 통한 감정 분석 애플리케이션과셀카를 이용한 증명사진 생성 애플리케이션 중 후자를 고르게 됐다.석사 형들의 조언대로 주제를 선정하면서 크게 고려했던 요인인“학습에 사용되는 데이터셋의 확보”에 대해서는 AI-Hub에서 제공하는한국인 안면 데이터셋과 한국인 헤어스타일 데이터셋을 사용하면 해볼만 하지 않을까 생각했고,세명 중 나를 제외한 두 명은 StarGAN-v2와 StyleGAN을 연구한 모델 개선 방향을,나는 모델 배포 및 애플리케이션 구현을 중점으로 역할을 배분했다.📋 2. 네이밍 및 스토리텔링 선정Concept Idea Sketching애플리케이션의 이름을 정하면서 가장 먼저 기존에 존재하는 카메라 및 사진 애플리케이션들의 이름을 나열했다.가장 많이 사용되는 애플리케이션들 중에서는 B612, SODA, Ulike, SNOW 등이 있었다.이러한 이름들을 보고 난 후엔, 직관적으로 우리 애플리케이션만의 개성을 나타내면서머신러닝, 사진, GAN 처럼 우리 주제를 반영할 수 있는 단어가 포함되면 좋겠다고 생각했다.주제와 연관 있는 단어들을 연상해 나가는 과정에서 우연히 “머선129” 라는 유행어가 하나 떠올랐다.머선129는 보통 사투리로 “무슨 일이야?” 의 의미를 가진 “머선 일이고~~”를소리나는 대로 뒤의 글자들을 숫자로 치환한 형태의 유행어인데,엄청 막 핫하고 그런 유행어는 아니지만 종종 쓰이고 광고 배너에도 포함되는 그런 단어였다.나는 이 단어의 “머선” 부분에서 “머신러닝”을 연상했고 (?)전체적인 이름 구조가 “B612”와 비슷하다는 점에서 꽤 괜찮은 느낌의 네이밍이라고 생각했다.한번 이렇게 생각하자,“머선129” -&gt; “셀카만 넣었는데 헤어 스타일과 정장 스타일까지 선택한 증명사진이 생긴다구? 머선 일이고~~~~”…처럼 스토리텔링을 구성해야겠다고 생각이 술술 전개됐다.이렇게 애플리케이션 이름을 머선129 : ms129로 정했다.📋 3. 디자인 시안 구상사실 애플리케이션 개발에서 막혔던 시간보다 초기 디자인 컨셉을 정하는 데 시간을 더 많이 썼던 것 같다.일러스트레이터는 아예 모르고 포토샵만 조금 다룰 줄 아는 내게 UI/UX 디자인은 맨땅에 헤딩하기 같았다.그래도 평소에 유투브 디자인 채널을 보면서 어깨 너머로 익힌 UX 디자인과dribbble 디자인들을 참고해서 디자인 컨셉을 구성했다.아이콘 디자인 같은 부분은 네이밍을 마치고 “Face ID가 결합된 형태”로 대충 구상했었는데,셀카에 정장 이미지를 합성한다는 아이디어에 어울리게 애플 Face ID + 넥타이를 합친 형태로 만들어 봤다.메인 화면이나 선택 화면은 큰 스크롤뷰로 구성된 형태를 생각하고 디자인했는데,포토샵으로 디자인 소스들을 배치한 후 Adobe XD와 제플린을 이용해 마진이나 패딩을 설정했다.처음에는 내 아이폰 X에서만 테스트하다 보니 고정 픽셀값으로만 설정해 놨는데친구 11 pro에서 테스트해본 이후로는 Screen width, height를 얻은 후기기마다 스크린 비율을 반영해서 구성하도록 수정했다.(이 부분은 다음 포스팅에서 다시 정리할 예정)📋 4. 프로젝트 초기 설정어떤 기술로 애플리케이션을 개발해야 할까에 대한 부분은 큰 고민 없이 React native로 선택했는데,가장 크게 고려한 점은 2020년에 스타트업 인턴 도중 한번 다뤄본 경험이 있어서크게 처음부터 바닥에 부딪히면서 배우지 않아도 될 것이라는 생각에서였다.또한, 다뤄봤다고 해도 TabBar나 StackNavigation으로 스크린 이동 프로토타입만 구현해 봤던 정도라서이번을 계기로 라이브러리를 이용한 기능까지도 좀 구현해 보고 싶은 생각이 있었다.추가적으로, 디자인프로젝트가 9월~12월 초까지 진행되는데내가 주로 맡은 역할이 애플리케이션 개발이라고 해도온전히 이것만 진행하는 게 아니고 팀원들과 논문 리딩이나 모델 개선점 파악도 꾸준히 진행하고중간 보고서, 중간주차 발표 등등 시간을 골고루 써야 하다 보니최대한 빠르게 크로스플랫폼 개발 도구를 사용해야겠다고 생각한 점도 있었다.(Flutter도 초반에는 고려했는데, Dart를 새로 배우는 시간을 고려해 상대적으로 익숙한 React Native로 가기로 했다)🧐 A. React-native vs Expo What is the difference between Expo and React Native? [React Native] Expo CLI와 React Native CLIReact Native를 써서 애플리케이션을 개발하는 데는 크게 두 가지 방법으로 나눌 수 있다.하나는 React Native CLI를 이용하는 방법이고 다른 하나는 Expo CLI를 이용하는 방식이다.흔히 전자를 bare React Native라고 표현하고 후자를 Expo라고 부른다.두 방식의 차이점이나 장단점은 구글링해 보면 자세한 비교들이 많긴 한데 요약하자면Expo CLI는 개발자가 React Native를 개발하는 데 있어서 여러 편의성과 제약을 동시에 제공해 준다고 볼 수 있다.React Native CLI를 사용하는 경우 테스트 또한 안드로이드 스튜디오나 Xcode를 이용해서 돌리는 반면Expo CLI는 테스트 기기에 Expo 애플리케이션을 설치하는 것만으로 테스트를 수행할 수 있다.반대로 Expo를 사용함으로써 생기는 제한 중에서 대표적으로는Kakao 로그인 모듈 등의 네이티브 모듈을 사용할 수 없다는 점을 들 수 있다.보통 React Native를 처음 다루는 사람들에게 Expo를 이용할 것을 권유하고좀 더 나아가 네이티브 모듈을 수정하고 좀 더 세밀한 옵션들을 손댈 수 있는 개발자들에게는React Native CLI로 개발할 것을 권유하는 것 같아서, 처음에는 React Native CLI로 프로젝트를 초기화했는데자꾸 프로젝트 설정이라던지 이런 부분들에서 에러가 터져서..서너 번 대응을 시도하다가 Expo로 프로젝트를 초기화해 보고 잘 실행되는 걸 보고 나서는그냥 Expo CLI로 개발을 이어 나가자고 생각했다.디자인프로젝트 최종 발표 기한 내 프로토타입 구현에서 기본적인 UI나 네비게이션을 빼고 큼지막한 기능들로는카메라 촬영/앨범 접근/API Fetch 정도만 일단 사용할 생각이었어서.. Expo CLI로도 충분하겠다는 생각이 들었다.추가로, 만약 개발 도중 필요성을 느낀다면 expo eject 명령어로bare React Native 프로젝트로 확장이 가능했기 때문에 일단 시작해보자고 생각했다.📦 B. 프로젝트 초기화Expo 프로젝트 초기화# install expo-clinpm install -g expo-clinode가 설치되어 있다는 전제 하에, npm을 통해 expo-cli를 설치해 준다.설치가 완료된 후에 expo init [프로젝트 이름] 을 통해 프로젝트를 초기화할 수 있으며보통은 blank를 선택해 주면 된다.expo init 명령어에 --npm 이나 --yarn 옵션을 따로 줌으로써어떤 패키지 관리자로 node module을 설치할 지 지정할 수 있다.명령어를 실행하면 필요한 패키지를 구성하고 초기화하기까지 몇 분 정도 소요된다.프로젝트 초기화가 끝났다면 npm start 명령어를 통해 Metro Bundle 콘솔 웹을 실행할 수 있다.콘솔 웹이 띄워졌다면 테스트 기기로 활용할 스마트폰에서 Expo 앱을 설치한 후 (IOS는 Expo Go)회원가입 - 로그인을 하고 네이티브 카메라 앱으로 저 QR 코드를 찍어 링크로 이동하면 된다.이 과정에서 같은 무선 네트워크 상에 있어서 이상 없이 로딩이 가능한 것 같다.위와 같이 흰 배경에 Open ip App.js to ~… 문구가 뜨면 프로젝트 초기화가 성공적으로 이루어졌다는 의미이다.vscode 등으로 프로젝트를 열고 App.js 내용을 수정하면 스크린에 뜬 문구가Fast Refresh를 통해 바로 업데이트되는 것을 확인할 수 있다.개발하면서 가장 편리했던 기능이다.이 포스트를 시작으로 앞으로 기록할 내용들은 Expo를 통한 개발 튜토리얼보다는어떠한 라이브러리를 사용해 기능을 구현했고 어떤 이슈들을 해결했는지 정보 공유 등을 목적으로 하기 때문에앞으로의 포스트에서는 위처럼 자세하게 매 진행 단계를 기록하는 일은 없을 것 같다.만약 Expo를 통해 애플리케이션을 처음 개발해보고자 찾아온 분이 있다면,구글에 검색하면 좋은 튜토리얼들이 정말 많이 나올 테지만나는 노마드 코더 무료 강의를 추천한다.이전에 React를 접하지 않고 강의를 듣더라도 어느 정도 중간중간 검색하면서 개념을 보충하면Expo를 통한 개발에 필요한 Basic step들을 충분히 완수할 수 있을 것이다.핵심 기능들에 대한 구현은 다음 포스트부터 이어가기로 😋" }, { "title": "☀️ 2022년을 맞이하며...", "url": "/posts/start-2022/", "categories": "life", "tags": "2022년", "date": "2022-01-07 16:18:00 +0900", "snippet": "☀️ 2022년을 맞이하며…많은 것을 해냈고, 또 그만큼 많은 아쉬움이 있었던 2021년을 뒤로 하고.. 2022년을 맞이했다. 😄며칠 동안 올해 꼭 성취하고 싶은 목표들을 2022 버킷리스트로 정리했다.작년에 적었던 버킷리스트를 되짚어 보면, 성취하고 싶은 목표들을 분류해서 정리한 건 좋았지만목표는 무조건 최대한 높게 설정해야 한다는 생각을 하고 세웠다 보니실제로 1년을 마무리하고 리뷰하면서 보니 대부분 목표치에 도달하지 못한 경우가 많았다.그래서, 올해 버킷리스트는 실제로 달성할 수 있는 목표치들을 구체적으로 설정하는 것에 집중했다.📋 목표 1. 미국주식/비트코인 투자작년에는 주식 투자를 국내 장 위주로 운영하면서 미국 장은 찍먹하는 느낌으로 건드렸는데올해는 과감하게 국내 장을 버리고 미국 장 위주로만 운영해 보기로 했다.섹터는 기술 주 위주로 잡되 실제로 내가 사용해 보거나 개인적으로 비젼에 확신이 있는 종목들을 몇 개 골라서분할 매수로 들어가려고 한다. (대표적 : NET, UBER, AAPL, …)또한 미장이랑 비슷한 비중으로 코인 쪽에도 꾸준히 분할 매수를 들어갈까 싶은데알트코인 말고 비트코인이나 이더리움 두 개만 보아보기로 결정했다.📋 목표 2. CGPA 관리하기솔직하게 말하면, 학교 커뮤니티에서 성적 인증 글을 많이 봤지만나보다 낮은 사람은 거의 한 두명밖에 못 봤다…….학점이 모든 것을 나타내는 것은 아니지만 어느 정도 성실함의 척도를 반영한다는 것에 동의한다.그 동안 수업 내용을 필기하고 익히는 것과 별개로 시험에서 결정적으로 실수를 많이 해서 아쉬웠던 과목들이 많았는데졸업을 앞두고 마지막 두 학기인 만큼, 시험에서도 최대한 집중해 후회 없이 학부를 마무리하는 것이 목표이다. 8학기, 9학기 목표 - A- 이상 4개, A0 이상 2개, A+ 1개씩은 꼭 챙기기📋 목표 3. 개발 직무 구체적으로 설정 후 포트폴리오 쌓아가기그 동안은 그냥 마음 가는 프로젝트 위주로 개발했다면, 올해는 프론트엔드 쪽으로 직무를 구체적으로 정한 만큼최대한 내 경험을 어필할 수 있는 프로젝트에 집중하고자 한다.개발자로 취업을 준비하는 학교 사람들 글을 보면 종종 어떤 걸 개발해야 할지, 혹은 개발하고 싶은 게 없어서고민인 사람들이 있는데 그런 점에 대해서는 나는 적어도 만들고 싶은 게 너무 많아 다행이라고 생각한다.또, 그냥 무작정 개발하기보다 어떤 기능을 구현하는 데 어떤 이슈에 직면했는지, 또 어떻게 해결했는지 등의 내용을블로그에 꾸준히 포스팅하고, 그 외에 꾸준히 커밋 로그나 README 또한 구체적으로 작성하는 습관을 들이려고 한다.📋 목표 4. 꾸준한 알고리즘 공부구체적으로 코딩 테스트를 위한 알고리즘 공부를 시작한 건작년 2학기에 동아리에서 진행하는 알고리즘 스터디에 참가하고 부터였는데멘토분을 포함해서 문제풀이에 능숙한 다른 분들을 보면서 내가 얼마나 알고리즘에 미숙했는지 실감했다.올해는 코딩 테스트에 자주 나오는 개념들(DFS, BFS, DP, Graph, ..) 위주로 개념 설명을 포스팅하는 동시에꾸준히 매 주 관련된 문제들을 풀어서 블로그에 풀이했던 기록을 남겨보고자 한다.알고리즘 문제들은 백준에서 골드 V 이상 문제들로 많이 고르되,프로그래머스나 리트코드에서도 적당히 섞어서 가져오려고 한다.📋 목표 5. 독서, 영화 시청, 여행https://www.instagram.com/netpoodlelix/영화나 책을 읽고 해석을 찾아보고 생각을 정리하는 걸 좋아하는데,그동안은 왓챠피디아를 통해 정리했다면 아예 제대로 인스타그램으로 정리를 해보자 해서작년 초쯤 @netpoodlelix라는 계정을 만들었었다.첫 글을 보면 공부 때문에 바쁘더라도 꾸준히 남기자고 했는데…거의 부끄러울 정도로 일 년 동안 아무 포스팅도 못했다 ㅠ올 해는 목표를 현실적으로 1달마다 책 1권, 영화 1편씩은 포스팅하는 것으로 잡아 다시 이어나가보고자 한다.다행히 시기(2021.01 -&gt; 2022.01)가 맞아 이번 달부터 재개해 나가면사람들이 첫 글을 쓰고 나서 며칠 안돼서 포스팅을 이어 나간 것으로 눈치 채지 못할 것이다…..작년 한 해는 여름방학 끝나기 직전에 친구들이랑 제주도 다녀온 거 빼고는코로나때매 많이 사려서 집 - 학교만 반복했었는데, 올해는 적당히 눈치 봐서 여행을 좀 다녀보고 싶다.특히 아빠가 점점 나이 드시고 배 나오시는 걸 보면서올해는 꼭 아빠랑 둘이서 국내 여행을 몇 군데 다녀오는 게 가장 해보고 싶은 목표이다.📋 목표 6. 운동, 건강 관리작년에 운동한 거라고는 조기축구 꾸준히 나간 거 하나밖에 없었는데,백신 후유증으로 고생하고 나서 건강 관리의 중요성을 좀 많이 실감했다.한달 후쯤 날씨만 좀 풀리면 집 근처 트랙 뛰는 걸 시작으로 유산소도 꾸준히 챙기고,집에서는 맨몸 운동 위주로 근력 운동도 시작해야겠다.별개로 방문에 달아놓은 풀업 바가 삐그덕거리기 시작해서, 언제 무너져내릴까 요즘 좀 무섭다.📋 목표 7. 운전면허 따기진작에 수능 보고 나서 따놨어야 했는데…. 라고 후회하고 벌써 6년이 지났다.이제 가족들의 운전면허 따라는 말은 아무런 영향을 주지 못하게 됐는데,개인적으로는 취업 전 마지막 기회라고 생각해서이번 방학 내에 학원을 끊어서라도 강제적으로 면허를 좀 따 놔야겠다.그래야 가끔씩 부모님 힘드신 날에 내가 동생 학원 데려다주고 데려오고를 할 수 있지 않을까 싶다.😄 마치는 글…이번 한 해가 정말로 혼자와의 싸움이라고 할 수 있지 않나 싶다.같이 수업을 들었던 친구들이 취업해서 학교를 떠나고, 또 대학원을 가고원래부터 복전 때문에 수업을 많이 혼자서 들었지만 이번 년도야말로 혼자 보내게 되는 시간이 많을 것 같다.또 동생이 내년 수능을 다시 보기로 하고 학원에 들어간 지 얼마 안 됐는데,가족 모두가 함께 힘낸다는 느낌으로 응원하기로 한 만큼나도 수업이 오후에 시작하는 날이라도 일찍 일어나서 스스로 할일을 찾아 시작하고 일찍 자는 걸 목표로 노력해야겠다.대학생으로의 마지막 1년이지만, 내 일생에서 마지막 1년이라고 해도 후회가 없을 만큼보람차고 바쁜 한 해를 보내고 싶다.푸들푸들 화이팅!😎" }, { "title": "🌄 2021년을 마치며...", "url": "/posts/end-2021/", "categories": "life", "tags": "2021년", "date": "2021-12-30 20:32:00 +0900", "snippet": "2021년을 마치며…엄청 오랜만에 블로그에 글을 남긴다.2학기 중에 큰 일이 있어서 중도 휴학하기도 했고, 이후 블로그에 회의감이 느껴져서 잠시 글들을 대부분 비공개 처리했다가이제 좀 해결됐다 싶어 다시 포스팅을 시작하는 동시에 한 해를 떠나보내는 타이밍이 됐다.졸업 준비다 취업 준비다 해서 한해 한해가 소중한 시간인데2021년에도 연 초부터 시작해서 굉장히 많은 일로 바쁘게 보냈다.자잘한 것들 빼고, 나름 짚고 넘어갈 만한 일들로만 올해 있었던 일들을 정리해보고자 한다. 🙂블로그 및 포트폴리오 기록 시작 (2020 겨울방학)(블로그를 개설한 이유에 대해서는 이 포스트 참고)올해 초부터 본격적으로 포스팅 및 포트폴리오 정리를 시작했다. Good 🙂 : 어떤 블로그 플랫폼을 써야 할 지, 어떤 콘텐츠들을 기록해 나갈 지 고민을 오래 한 끝에드디어 블로그를 만들고 첫 걸음을 내딛었다.올해 참여했던 몇몇 활동들도 블로그 포스팅으로 정리하면서 더 많이 남고 이해할 수 있었다고 생각한다. Bad 🥺 : 생각보다 알고리즘 문제 풀이라던지, 학기 중 강의 복습이라던지계획한 내용에 비해서는 포스팅을 많이 올리지 못했다.그리고 포트폴리오는 맨 처음 React + Gatsby로 구상했던 내용이 있었는데어느 순간 포트폴리오에 담길 내용이 아직 많이 모자란데 너무 포트폴리오 자체에 매달리는 게 아닌가 싶은 생각이 들어 일단은 노션에 정리하고자 생각했다.관심 있는 인턴 활동, 부트캠프 등에 지원을 넣을 때마다 포트폴리오의 중요성을 매우 실감하고 있다.2022년에는 포트폴리오의 내용에 최대한 집중해서 의미 있는 내용들을 많이 포함시키고자 한다.마이크로프로세서/마이크로프로세서응용실험 수강 (2021 1학기)일 년 동안 수강한 여러 수업들 중에서 가장 인상깊게 들었던 과목이기도 하고, 가장 많은 시간을 소요했던 과목으로 기억에 남았다. Good 🙂 : 진도의 절반 정도는 ARM 어셈블리로, 나머지 절반은 C로 코딩해보며 직접 마이크로프로세서의 작동 및 Memory Alignment, Pipelining, Interrupt Service 등에 대해 바닥부터 이해해 볼 수 있는 수업이었다.이 수업을 듣기 전에 아키텍처, 어셈블리 수업을 들으면서 MIPS, X86 기발 어셈블리에 대해서는 짚고 넘어왔었는데, 마프를 통해 ARM 어셈블리 또한 많이 다뤄볼 수 있어서 차이점이라던지 그런 부분들에 대해서 이해할 수 있어서 좋았다.또한 OS 수업에서 커버했던 Interrupt Vector Table 같은 개념들에 대해서도 직접 구현해 보면서 이론 수업만으로는 부족했던 부분이 채워졌다.별개로, 이 수업을 통해 공학자로써 사용하는 용어에 대한 책임감이라던지, 접근하는 태도 등에 대해 느낀 바가 많았고 결정적으로 이 교수님이 계신 연구실에서 디자인프로젝트를 수행하기로 결심한 계기가 되었다. Bad 🥺 : 정말… 정말 많은 시간을 썼다ㅠㅠ매주 월요일마다 보고서 제출이었는데 40~50페이지씩 작성하면서 13주차 중에서 12주 정도는 날밤을 샜던 것 같다.(실험 스텝을 무지성으로 따라가기만 해도 구석구석 숨은 개념들을 이해할 수 있도록 꼼꼼히 구성되어 있었다..)그리고 들을 때는 꼼꼼히 이해했지만 포스팅으로 남겨놓지 않으니까 슬슬 까먹는 기분이 들어서ㅠㅠ 너무 아깝다.이 부분은 다음 학기에 개론만 청강 신청해서 진도 나가는거 맞춰서 예전 필기 보면서 포스팅할까 고민 중에 있다.현대모비스-서강대 SW 사전교육 참여 (2021 여름방학)2021년 1월 겨울방학 중에 현대모비스에서 재학생 4학년 위주로 교육생을 선발해2주 기간 동안 딥러닝을 간단하게 짚고, 주어진 과제를 해결하는 활동에 선발되었다. Good 🙂 : 딥러닝을 잘 모르는 상태에서 어느 정도 감을 잡을 수 있었던 교육이었다.또한 Nvidia의 Jetson Nano 보드에서 개발을 진행하고, Docker 환경을 불러오는 등의 경험도 할 수 있었다. Bad 🥺 : 아직까지도 후회되는 점은, 이 교육을 마치고 이어진 디자인프로젝트 연구실 세미나를 먼저 진행하고 교육을 수료했다면 더 많은 것들을 할 수 있었겠다 하는 아쉬움이다.짧은 기간동안 결과물을 내려다 보니 전이 학습 위주로만 배웠는데Train set, Test Set 등의 개념도 잡히지 않고 너무 서둘러서 하고자 했던 게 아닌가 싶다.결과물 자체도 목표는 높았지만 들인 시간에 비해 이렇다 할 성과를 내지 못한 것도 아쉬웠다.디자인프로젝트 DIP, ML 사전 세미나 (2021 여름방학)2021 2학기에 수행할 디자인프로젝트를 위해서 여름방학부터 개별 연구실 컨택이 있었는데 나는 영상처리 쪽 연구실을 선택했다.이 연구실에서 재작년, 작년에 선배들이 진행했던 주제들을 보면딥러닝 및 영상처리를 응용한 점자 블록 인식 내비게이션, 오프사이드 판독 시스템 등이 있었는데막 디자인프로젝트를 시작하는 학생들은 이런 부분에 대해서는 거의 지식이 없는 상태였다.석사 형들이 커리큘럼을 구성해서 DIP(Digital Image Processing), ML(Machine Learning) 등에 대해약 7주 동안 교육을 진행했고, 이에 참여해 바쁜 방학을 보냈다. Good 🙂 : 커리큘럼이 아주 세세한 것부터 구성되어 있어 그대로 따라가면서 개념을 이해하기 좋았다.가령, 딥러닝에 대해서 배운다고 하면 온라인에서의 많은 자료들은 당장 Pytorch 등을 이용해유명한 몇몇 데이터셋에 대해 학습을 진행하는 코드 위주로 구성되어 있는데,석사 형들이 가르치는 내용은 Dataloader의 필요성이라던지 Perceptron에서 MLP에 이르기까지개념들을 순차적으로 차곡차곡 쌓아 가는 느낌이 들어서 굉장히 도움이 많이 됐다. Bad 🥺 : 아쉬웠던 건 내 완벽주의와 게으름 때문에 많은 주차 내용을 완벽하게 100% 발표하지는 못했다는 점이다.총 7명의 학부생들이 똑같이 그 주의 주제에 대해 발표를 준비하고,발표 직전 랜덤하게 3명의 학생을 뽑아 발표를 진행하는 룰이었는데매 주마다 나는 너무 모든 걸 발표하고자 하다 보니 그 주차에 발표하기로 한 내용을 전부 담지 못해매번 부정적인 피드백이 있었던 것이 많이 아쉽다.차라리 함께 했던 친구처럼 큰 틀에 대해서 진행하고 디테일을 다루는 방식으로 진행하는 편이 나았을 거라고 생각한다.디자인프로젝트 수강 (2021 2학기)디자인프로젝트를 한다고 했을 때 사실 많은 친구들이 의문을 가졌었는데나는 복수전공생 학적으로 등록되어 졸업 요건에 디자인프로젝트 필수 수강이 제외되었기 때문이다.하지만 한 학기 동안 원하는 주제로 프로젝트를 수행한다는 점과이를 옆에서 도와주는 멘토(교수님, 석사 형들)이 있다는 점이 너무 매력적이었고 이에 최종적으로 수강을 결심했다.주제 선정에도 굉장히 시간이 많이 걸렸는데,나랑 친구 2명을 포함해서 3명이 한 팀이다 보니 왠만한 가벼운 주제들은 석사 형들 선에서 reject 당했다.나 포함 팀원들 또한 어쨌든 영상처리 연구실에서 진행하는 만큼 다른 소자라던지, 통신 연구실보다 좀 더직관적으로, 또 실생활에 와 닿는 주제들을 선택하고 싶었고 이왕이면 애플리케이션 형태의 최종 결과물을 원했다.그래서 선택하게 된 주제가 “딥러닝을 통한 셀카 -&gt; 증명사진 변환 모델 및 응용 애플리케이션” 이었다. Good 🙂 : 4개월 동안 진행하는 프로젝트라고 하지만, 사실 방학때부터 준비했던 걸 포함하면거의 반년 동안 열심히 프로젝트를 수행했다.팀원들 간에 역할 배분도 어느정도 그럴듯하게 나누어져 나는 학습 데이터 전처리와 애플리케이션 구현을 맡았는데,예전에 스타트업 인턴 때 살짝 다뤄보고 까먹었던 React Native를 다시 이용해여러 기능들을 가져다 쓰고 React 내부 구조에 대해 이해할 수 있는 정도까지 다뤄볼 수 있어서 만족스러웠다. Bad 🥺 : 초반 생각했던 것에 비해서 결과물이 많이 축소된 점이 아쉬웠다.셀카 사진의 옷 부분을 증명사진에서 요구하는 양복 사진으로 변환하는 과정도양복 데이터들을 충분히 학습시켜 이 또한 GAN 네트워크를 통한 도메인 변환으로 이루어지도록 하고 싶었지만충분한 데이터셋을 수집하지 못해 Segmentation Map을 조작해 이어 붙이는 방식으로 타협했다.이외에도 헤어스타일 변환 등을 계획했던 단계까지 완성도를 끌어올리지 못했던 점이 아쉽다.프로젝트를 진행하면서 최종 목표를 앱스토어 런칭까지 잡았었는데,현재는 디자인프로젝트 발표가 끝나고 잠시 어느 정도 중지된 상태이다.발표가 끝났다고 해서 프로젝트를 그냥 날리기는 아쉬운 만큼,2022년 내에 다시 학습에 활용 가능한 GPU 리소스를 확보해 부족했던 점들을 구현한 후 서비스 런칭까지는 가 보고 싶다.중도 휴학(질병) (2021 2학기)사실 올 해 있었던 가장 큰 사건이었는데.. 2학기 수강 중 화이자 2차 백신을 맞고 나서 2주 후부터 두통 증상이 심해졌다.2학기 수강한 과목들 중에서 꼭 이번 학기에 수강했어야 하는 과목들도 많았고디자인프로젝트도 참여하고 있던 와중이라 많은 고민을 했지만, 도저히 학업을 지속할 수 없어서 중도 휴학했다.주변에 반년~1년씩 휴학하는 친구들을 많이 보면서 사실 별 생각이 들진 않았지만적어도 복수전공을 하는 나로썬 이번 생은 휴학은 없겠구나 싶었는데, 스스로도 당황스러웠다.사실 가장 증상이 심했던 기간에는 휴학이라던지 이런 문제보다도혈전이라던지 뇌 쪽 문제가 생긴 건 아닌지, 앞으로도 이런 증상을 달고 살면 어떻게 하나 싶은 생각이 더 컸던 것 같다.정밀 검사에서는 뇌 혈관 쪽 문제는 없는 것으로 나왔지만 그래도 증상이 지속되어 한동안 병원에 이틀 간격으로 들락날락했는데다행히 증상 발현 한달쯤부터 갑자기 증상이 사라졌다.아직도 두통의 정확한 원인이 뭔지는 잘 모르겠지만 만약 과로라던지 스트레스 등의 요인이라면너무 몸을 혹사시키는 것보다는 휴식하면서 오래 가는 게 낫다라는 깨달음을 얻는 정도로 넘어갔겠지만백신 때문에 그랬던 게 맞다면, 부스터샷 접종이라던지 이런 부분들에 대해서 아직도 고민이 많다.마치는 글…원래는 2021년 2학기가 횟수로 따지면 정규학기 마지막(8학기)이고이후 추가학기로 내년 상반기만 다니고 졸업 요건을 채울 예정이었지만,2학기 중도휴학을 하게 되면서 내년 1, 2학기를 전부 풀학점으로 채워야 졸업할 수 있게 됐다ㅠㅠ어떻게 생각하면 컴파일러같은 관심있던 과목들을 추가로 들을 수 있게 되었으니 다행이라고도 생각해야겠다.주변 친구들이 벌써 절반 이상 취업한 와중에 느끼는 바가 많은 요즘인데,내가 전자과 친구들 사이에서 다른 분야로의 취준을 하는 만큼어떤 게 나한테 진짜 도움이 될 지 판단하고 선택과 집중을 하는 방향으로 보낼 수 있는 내년이 되었으면 한다.어쨌든, 올 해 정말 많은 일이 있었고 잘 노력해낸 내게 스스로 따봉 하나를 날리고 싶다. 👍🏻Adios 2021." }, { "title": "📄 백준 20913번 - Mixtape Management (Constructive)", "url": "/posts/algorithm-boj-20913/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, constructive algorithm", "date": "2021-10-07 03:29:00 +0900", "snippet": "📄 문제 소개백준 20913번 : Mixtape Management링크 : https://www.acmicpc.net/problem/20913영어 원문으로 설명되어 있고, 읽을 부분이 많아 당황스러울 수도 있지만핵심은 Numerical Order, 그리고 Lexicographical Order이다.입력으로 배열의 개수 N을 첫 줄에 받고그 다음으로 N개의 배열을 입력받는데 이는 1 ~ N까지의 자연수를 임의로 나열한 형태이다.출력은 임의의 N개 수들을 생성한 후 Lexicographical Order, 즉 사전식 순서로 배열한 형태인데동시에 입력받은 배열의 Numerical Order를 따라야 한다는 조건 또한 충족해야 한다.즉, 입력받은 Numerical Order를 충족하면서 앞에서부터는 Lexicographical Order대로 나열되어 있는임의의 수들을 순서대로 출력하는 것이 문제의 핵심이다.📗 문제풀이 과정🧐 일단 생각해 볼 것일단 특이한 점은, 입력받는 배열의 크기 n이 최대 100으로 굉장히 작다.따라서 왠만한 경우는 시간 복잡도를 만족할 수 있지 않나…? 라는 생각을 하고 넘어갈 수가 있다.😀 구성적 알고리즘을 적용해 보면?이 문제는 조건 2가지에 맞는 숫자들을 생성해 나열하면 되기 때문에 정답이 정해져 있지 않다.따라서 풀 수 있는 방법도 여러 가지인데 내가 사용한 방법을 설명하자면(1) 먼저 100부터 시작해 1씩 증가하는 n 크기의 리스트를 만든 후(2) (Numerical Sequence로 입력받은 정해진 순서 값 - 1)만큼 숫자 뒤에 0을 붙여 주는 것이다.(1)을 통해서 100부터 1씩 증가해 가며 리스트를 만드는 이유는 사전식으로 증가해여 한다는 조건을 만족하기 위해서이며,생성하는 숫자는 0으로 시작할 수 없다는 조건에 의해 000~099 대신 100~199의 범위를 사용한다.이에 따라 n의 가능한 최댓값 100까지 사전식 순서를 만족하는 배열을 만들 수 있다.그 다음으로 (2)를 통해서 뒤에 0을 붙여 주는 작업을 통해 Numerical Order까지도 만족하도록 처리할 수 있는데,그 이유는 0을 뒤에 붙이는 행위가 사전식 순서를 해치지 않으면서 온전히 해당 수를 크게 만들 수 있기 때문이다.만약 n이 최대 100까지 주어지는 경우까지 고려하더라도 배열의 요소가 제한된 10^1000을 넘지 않음이 보장된다.그렇다고 해도, 문제를 풀 당시에는 뒤에 0이 100개 가까이 붙는 큰 수를 처리하는 과정에서시간 초과나 메모리 초과가 나지 않을까 걱정했는데…실제 코드로 옮겨 보니 뒤에 0을 붙인 후 다시 정수로 변환할 필요가 없기 때문에사실상 문자열 연산으로 생각해도 무방할 것 같다.💻 코드📒 연관 개념 Constructive Algorithm(구성적 알고리즘) Constructive Algorithm 문제는 처음 풀어봐서 당황스러운 것도 있었지만명확한 풀이법이 딱 나와있지 않다는 점이 까다로운 것 같다.그래도 이 블로그에 설명해 주신 문제들을 보면 필요조건과 충분조건으로 접근하는 방법이 있는 걸 보니아주 직관으로만 접근하는 유형은 분명 아닌 것 같긴 하다.조만간 먼저 정리하기로 한 BFS/DFS나 DP 개념 정리가 끝나고 나면포스트로 꼭 다뤄봐야겠다.🧐" }, { "title": "📋 알고리즘 개념 - Prefix Sum(구간 합, 누적합)", "url": "/posts/algorithm-prefix-sum/", "categories": "algorithm", "tags": "algorithm, prefix sum", "date": "2021-10-04 18:09:00 +0900", "snippet": "📋 알고리즘 소개🧐 적용 가능한 상황출처 : 유투브 “동빈나” - 코딩 테스트 &amp; 알고리즘 대회 핵심 노트 - 투 포인터(Two Pointers), 구간 합(Prefix Sum)N개 요소로 구성된 배열이 주어졌을 때, 배열 내부에서 길이가 1 &lt;= M &lt;= N인 구간을 설정해그 구간의 합이 K가 되는 경우의 수를 구하는 알고리즘을 생각해 보자.출처 : 유투브 “동빈나” - 코딩 테스트 &amp; 알고리즘 대회 핵심 노트 - 투 포인터(Two Pointers), 구간 합(Prefix Sum)# using Brute Force Method# N과 K를 입력받았다고 가정N = 5K = 5# 리스트 arr에 주어진 배열의 요소들을 입력받았다고 가정 -&gt; O(N)arr = [1, 2, 3, 2, 5]# arr 배열을 구성하는 N개 요소에 대해 N개의 가능한 조합을 계산하는 데 N번의 명령 수행 -&gt; O(N^3)cnt = 0for i in range(N): for j in range(i, N): temp = 0 for k in range(i, j + 1): temp += arr[k] # 구간의 합이 주어진 값 K와 같을 경우 카운팅 if temp == K: cnt += 1# 카운팅한 값 출력print(cnt)위와 같이 N = 5인 예시를 생각해 보면, Brute Force Method로 접근했을 때중복을 제외하고 가능한 연속 수열의 조합을 모두 확인하려면 우선 배열의 N개 요소에 대한 접근이 이루어진다.각 N개 요소에 대해 인덱스 i ~ i, i ~ i + 1, ... , i ~ N - 1까지 최대 N개의 가능한 조합을 생각할 수 있고각 조합의 구간 합을 계산해 비교하는 데 한 번 더 N번의 반복이 이루어지기 때문에 전체 알고리즘의 시간복잡도는 O(N^3)이 된다.하지만 O(N^3)의 경우 N이 1000만 넘어가더라도 채점 기준에서 대략적으로 1초 내에 절대 통과할 수가 없다.위와 같은 상황에서 문제를 해결하기 위한 방법들로는prefix sum 혹은 two pointer 알고리즘을 대표적으로 사용하는데, 이번 포스트에서는 prefix sum 알고리즘을 사용해서 해결해 보자.😀 Prefix Sum을 사용한다면…prefix sum의 핵심 아이디어는 미리 구간합 배열을 전처리 과정에서 계산해 놓는 것이다.출처 : 유투브 “동빈나” - 코딩 테스트 &amp; 알고리즘 대회 핵심 노트 - 투 포인터(Two Pointers), 구간 합(Prefix Sum)# using Prefix Sum# N과 K를 입력받았다고 가정N = 5K = 5# 리스트 arr에 주어진 배열의 요소들을 입력받았다고 가정 -&gt; O(N)arr = [1, 2, 3, 2, 5]sum_arr = [0]# 미리 계산된 prefix sum 리스트를 구성 -&gt; O(1)for i in range(len(arr)): sum_arr.append(sum_arr[i] + arr[i])# sum_arr 배열을 구성하는 N개 요소에 대해 N개의 가능한 조합을 계산하는 데 N번의 명령 수행 -&gt; O(N^2)cnt = 0for i in range(N): for j in range(i + 1, N + 1): # 구간의 합이 주어진 값 K와 같을 경우 카운팅 if sum_arr[j] - sum_arr[i] == K: cnt += 1# 카운팅한 값 출력print(cnt)위 알고리즘은 같은 문제를 반복문 하나를 덜 쓰고 해결할 수 있다.핵심은 Prefix Sum 배열을 만드는 과정인데, 맨 처음에 Prefix Sum 배열에 0을 삽입하고 그 다음 요소부터는Prefix Sum[i] = Prefix Sum[i - 1] + Original Array[i]로 나타낼 수 있기 때문에Prefix Sum 배열의 값을 채우는 코드는 O(N) 내에 전처리가 수행될 수 있다.이에 따라 기존 arr 배열의 Index 0부터 N - 1까지의 구간 합을 구하는 코드가 원래는 O(N)에 수행되었으나Prefix Sum 배열을 통해 나타내면 Prefix Sum[N] - Prefix Sum[0]으로 O(1)에 계산할 수 있으므로이에 따라 모든 구간의 합을 O(N^2) 내에 전부 계산할 수 있게 된다.물론 Prefix Sum은 미리 배열에 대해 정해진 누적 합 배열을 전처리로 초기화해 놓는 것이기 때문에Original 배열의 i번째 요소가 변경되는 경우 Prefix Sum 배열의 i + 1번째 ~ N - 1번째 요소가 모두 업데이트되어야 한다는 단점이 있다.따라서 Prefix Sum은 값을 변경하지 않는 경우(immutable)에 효율적인 알고리즘이다.💻 대표적인 문제 풀이📄 백준 11441번 : 합 구하기백준 11441번 : 합 구하기링크 : https://www.acmicpc.net/problem/11441이 문제를 봤을 때 가장 간단하게 풀 수 있는 코드를 생각해 보면,아래와 같이 N개의 수를 입력받고 난 후 M개의 구간에 대해i와 j가 주어지면 구간을 계산하는 방법을 떠올릴 수 있다.# N 입력N = int(input())# N개의 수 입력numbers = list(map(int, input().split()))# M 입력M = int(input())answers = []for _ in range(M): # 구간 i, j 입력 (i, j) = list(map(int, input().split())) Sum = 0 # 구간 i부터 j까지의 합 계산 for k in range(i - 1, j): Sum += numbers[k] answers.append(Sum)for ans in answers: print(ans)이렇게 코드를 작성하면 각 케이스에 대해 올바른 출력을 계산하지만,정해진 시간 1초 내에 들어올 수 없다.# N 입력N = int(input())# N개의 수 입력numbers = list(map(int, input().split()))# M 입력M = int(input())# prefix sum 배열 초기화sum_numbers = [0]for k in numbers: sum_numbers.append(sum_numbers[-1] + k)answers = []for _ in range(M): # 구간 i, j 입력 (i, j) = list(map(int, input().split())) # 구간 i부터 j까지의 합을 prefix sum 배열로 계산 answers.append(sum_numbers[j] - sum_numbers[i - 1])for ans in answers: print(ans)위처럼 코드를 약간 수정해, Prefix Sum 배열을 만들어 놓은 후각 구간 값 i와 j가 입력될 때마다 구간 i부터 j까지의 합을prefix[j] - prefix[i - 1]으로 계산하면전체 코드를 O(N * M)에서 O(M)내에 해결할 수 있다.📄 백준 2829번 : 아름다운 행렬백준 2829번 : 아름다운 행렬링크 : https://www.acmicpc.net/problem/2829쉽게 말해서, N * N 크기의 Square Matrix가 주어졌을 때 그 Matrix가 포함하는 모든 부분 Square Matrix 중(왼쪽 위에서 시작하는 대각선 성분의 합 - 오른쪽 위에서 시작하는 대각선 성분의 합)이 최대가 되는 경우의 값을 찾으라는 내용이다.# 행렬의 크기 N 입력N = int(input())# 행렬 값 입력matrix = []for _ in range(N): matrix.append(tuple(map(int, input().split())))matrix = tuple(matrix)# prefix matrix 초기화prefix_left_up = []prefix_right_up = []for _ in range(N + 1): temp = [] for _ in range(N + 1): temp.append(0) prefix_left_up.append(temp.copy()) prefix_right_up.append(temp.copy())for i in range(1, N + 1): for j in range(1, N + 1): prefix_left_up[i][j] = prefix_left_up[i - 1][j - 1] + matrix[i - 1][j - 1] for j in range(N): prefix_right_up[i][j] = prefix_right_up[i - 1][j + 1] + matrix[i - 1][j]# calculating Max value of Square Matricesmax_beauty = -800000 # Minimum Value if N == 400for M in range(2, N + 1): for i in range(0, N - M + 1): for j in range(0, N - M + 1): main_diagonal = prefix_left_up[i + M][j + M] - prefix_left_up[i][j] sub_diagonal = prefix_right_up[i + M][j] - prefix_right_up[i][j + M] max_beauty = main_diagonal - sub_diagonal if max_beauty &lt; main_diagonal - sub_diagonal else max_beautyprint(max_beauty)이 문제 또한 단순히 Brute Force Method로 접근하면 O(N^4)가 소요되어 시간 제한에 걸린다.여기서 두 방향의 대각선 합에 대해 각각의 2D Prefix Sum을 사용하는 경우특정 부분 Square Matrix가 주어졌을 때 대각선 요소들의 합을 구하는 시간을 O(N) -&gt; O(1)로 줄일 수 있다.📄 백준 16713번 : Generic Queries백준 16713번 : Generic Queries링크 : https://www.acmicpc.net/problem/16713N개 수열이 주어지고, Q개의 쿼리에 의해 구간 (i, j)가 주어졌을 때 수열의 i번째 요소부터 j번째 요소까지의 XOR Sum을 구한다.결과적으로 모든 쿼리의 XOR Sum끼리의 XOR을 한 결과가 출력이 된다.# 수열 길이 N과 쿼리 갯수 Q 입력(N, Q) = tuple(map(int, input().split()))# 수열 입력arr = list(map(int, input().split()))# prefix sum 배열 전처리xor_arr = [0]for item in arr: xor_arr.append(xor_arr[-1] ^ item)# 쿼리 별 처리total_xor = 0for _ in range(Q): (i, j) = list(map(int, input().split())) temp = xor_arr[j] ^ xor_arr[i - 1] total_xor = total_xor ^ temp# 결과 출력print(total_xor)덧셈이 아닌 XOR 연산 또한 A ^ B ^ B = A가 되는 성질을 이용해 Prefix Sum 알고리즘을 적용할 수 있다.만약 구간의 합을 구하는 것이 아닌, 구간의 곱을 구하는 문제 또한Prefix Sum 배열의 요소에서 나누어 주는 방식으로 알고리즘을 활용할 수 있다.😎" }, { "title": "📄 백준 16713번 - Generic Queries (Prefix Sum)", "url": "/posts/algorithm-boj-16713/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, prefix sum", "date": "2021-10-04 17:51:00 +0900", "snippet": "📄 문제 소개백준 16713번 : Generic Queries링크 : https://www.acmicpc.net/problem/16713N개의 수를 입력받고, Q개의 (i, j) 구간 쌍을 입력받아 각 쿼리 별 XOR Sum을 구한 후,모든 쿼리의 XOR Sum을 다시 XOR해 결과를 출력하는 문제이다.📗 문제풀이 과정🧐 일단 생각해 볼 것만약 Brute Force Method로 접근하면 Q개의 쿼리가 주어져서 각 구간을 입력받고,입력받은 구간마다 최대 N번의 계산이 이루어지므로 시간복잡도는 O(NQ)가 된다.N이 최대 10^6, Q가 최대 10^6라고 주어졌으므로 대략적으로 10^12만큼의 시간이 걸린다면문제 풀이 기준 2.5초(대략 2 * 10^8) 안에 들어올 수가 없다고 생각해야 한다.또한, N이나 Q 둘 중 하나를 O(1)로 줄인다면 시간 제한을 통과할 수도 있겠다는 생각도 할 수 있다.😀 Prefix Sum을 이용한 전략이 문제 또한 Prefix Sum만을 통해 푸는 종류의 유형인데단지 구간 합이 아니라 구간 XOR을 계산한다는 점만 다를 뿐 똑같다.XOR 연산 또한 A ^ B ^ B = A가 성립하기 때문에(i, j) 구간의 XOR Sum에 대해서 j까지의 xor_sum 배열 값 ^ i까지의 xor_sum 배열 값으로 O(1) 내에 구할 수 있다.결론적으로 전체 시간복잡도 O(Q) 내에 문제를 해결할 수 있고이는 10^8보다 작으므로 주어진 문제 시간 2.5초 내에 문제를 해결할 수 있는 코드임을 알 수 있다💻 코드📒 연관 개념 Prefix Sum(구간 합) " }, { "title": "📄 백준 2829번 - 아름다운 행렬 (Prefix Sum)", "url": "/posts/algorithm-boj-2829/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, prefix sum, bruteforcing", "date": "2021-10-04 00:44:00 +0900", "snippet": "📄 문제 소개백준 2829번 : 아름다운 행렬링크 : https://www.acmicpc.net/problem/2829N과 N * N 크기의 Square Matrix 각 요소를 입력받은 후, 입력받은 Square Matrix의 부분 집합인 Square Matrix 중에서아름다운 정도, 즉 (왼쪽 위 방향으로의 대각선 요소들의 합 - 오른쪽 위 방향으로의 대각선 요소들의 합) 의 최솟값을 구하는 문제이다.예제 입력 3을 가져와서 설명해 보면 위와 같은 Matrix의 입력에서는가장 작은 아름다운 정도의 값이 오른쪽 아래 4개 요소로 만든 Square Matrix인 경우이므로 5가 된다.📗 문제풀이 과정🧐 일단 생각해 볼 것간단히 생각해서 모든 아름다운 정도를 비교하기 위해서는,크키가 N인 Square Matrix에 몇 가지의 부분 Square Matrix가 존재할 수 있는지를 짚고 넘어갈 수 있다.직접 N = 2, 3, 4인 경우에 대해서 그려서 알아보니, 크기가 N인 Square Matrix에서의 부분 Square Matrix는k = 1부터 N - 1까지 k^2을 더한 것만큼 존재한다는 것을 알 수 있다.시그마에 제곱이 결합된 공식을 구글링해 보면 N(N + 1)(2N + 1) / 6이므로일단 이 부분만 시간복잡도로 나타내면 O(N^3)이라고 할 수 있다.결과적으로 Brute Force Method로 아름다운 정도의 최솟값을 계산하는 알고리즘은 O(N^4)라고 할 수 있는데,문제에서 N은 최대 400으로 주어졌기 때문에 400^4 = 2^8 * 10^8로 짐작해 보면절대 시간 내에 이 알고리즘으로는 통과할 수가 없을 것이라고 예상할 수 있다.그렇다면 만약 알고리즘을 O(N^3)으로 줄이게 된다면…?2^6 * 10^6의 시간 정도가 소요되며, 이는 10^8보다 작으므로어쩌면 Polynomial의 차수를 하나만 줄이는 것으로충분히 제한시간 내에 들어올 수 있겠다 ..는 생각을 할 수 있다.😀 Prefix Sum을 이용한 전략Prefix Sum을 사용해 미리 전처리를 하면 N의 차수를 하나 줄일 수 있다.이 경우에는 대각선 방향의 누적 합을 계산해야 하므로, 2-Dimensional 형태의 Prefix Sum 을 활용한다.또한 아름다운 정도를 계산하기 위해서 두 개의 대각선 방향 당 각각의 2D Prefix Sum 배열이 필요하다.각 대각선 방향에 따라 column이 1인 경우와 row가 1 or N-1인 경우 1로 Padding이 처리된 것을 볼 수 있는데문제풀이에서 Prefix Sum을 활용하는 경우 이렇게 0을 Padding하는 것은반복 처리에서 형태를 보다 일관되고 쉽게 처리할 수 있게 해 준다.결과적으로, 입력된 Square Matrix에서 가능한 모든 부분 Square Matrix를 O(N^3)에 완전 탐색하면서아름다운 정도를 O(1)에 계산할 수 있으므로 총 O(N^3)의 알고리즘으로 문제를 제한 시간 내에 해결할 수 있다.💻 코드📒 연관 개념 Bruteforcing(완전 탐색) Prefix Sum(구간 합) " }, { "title": "📄 백준 11441번 - 합 구하기 (Prefix Sum)", "url": "/posts/algorithm-boj-11441/", "categories": "algorithm, baekjoon", "tags": "algorithm, baekjoon, prefix sum", "date": "2021-09-30 21:47:00 +0900", "snippet": "📄 문제 소개백준 11441번 : 합 구하기링크 : https://www.acmicpc.net/problem/11441N개의 수를 입력받고, M개의 (i, j) 구간 쌍을 입력받아 각 구간 합을 출력하는 문제이다.📗 문제풀이 과정🧐 일단 생각해 볼 것만약 Brute Force Method로 접근하면 M개만큼 구간을 입력받고, 입력받은 구간마다 최대 N번의 계산이 이루어지므로 시간복잡도는 O(MN)이 된다.N과 M이 각각 최대 10^5라고 주어졌으므로 대략적으로 10^10만큼의 시간이 걸린다면문제 풀이 기준 1초(대략 10^8) 안에 절대 들어올 수가 없다.😀 Prefix Sum을 이용한 전략위 문제에서 Prefix Sum을 통해 미리 전처리를 하는 경우,각 입력받은 구간마다의 합을 계산하는 데 O(1), Linear Time이 소요되므로전체 시간복잡도 O(M) 내에 문제를 해결할 수 있고이는 10^8보다 작으므로 1초 내에 문제를 해결할 수 있는 코드임을 알 수 있다.💻 코드📒 연관 개념 Prefix Sum(구간 합) " }, { "title": "📚 2021년 가을학기의 공부/복습 플랜", "url": "/posts/study-plan-autumn-2021/", "categories": "life", "tags": "2021년, study", "date": "2021-09-02 03:22:00 +0900", "snippet": "8학기가 개강했다.오늘 수업 2개 연강이 있어갖고 듣고 왔는데,오랜만에 수업을 들을려니까 죽을 맛이다.방학동안 박살난 생활 패턴을 빠른 시간 안에 비교적 정상적으로 돌릴 필요가 절실하다…현재 시점으로 이번 학기 시간표는 위와 같다.전자공학 쪽 전공필수를 채우기 위해 물리전자공학/공학수학을 컴공 수업들과 병행하게 됐다.원래 2학년~3학년 과목이긴 한데.. 복전을 하면서 더 급한 과목들을 들어오다 보니까 지금 와서야 듣게 됐다.그 외에는 마지막 전자과 실험 과목인 고전실을 제외하고는 크게 부담이 있는 과목은 없다.이번 학기의 주력 1순위는 뭐라 해도 디자인프로젝트인데따로 시간이 정해져 있는 게 아니면서도 꾸준히 진행은 해야 하다 보니까 일주일 당 얼마나 시간을 쓸 지 정하는 게 핵심일 것 같다.이 부분은 같이 프로젝트를 진행하는 팀원 친구 2명이랑 얘기해 보기로 했다.또 알고리즘 수업도 개인적으로 예전부터 듣고 싶었는데수업에서 배운 이론적인 내용을 바탕으로 백준이나 프로그래머스에서 해당 유형 알고리즘 문제를 좀 많이 풀어보고블로그 포스팅으로 공유해 보면 어떨까 싶다… 가 아니고 꾸준히 코테를 준비하기 위해서는 그래야만 할 것 같다.📚 공통 예습은 특별히 따로는 안함 복습은 주차별로 몰아서 진행 주차마다 복습한 진도를 블로그에 포스팅📚 물리전자공학1/고급공학수학2/이산구조 굿노트로 필기한 내용 위주로 이론 복습 교재 연습문제 짝수, 혹은 홀수 위주로 풀어보기 중간이나 기말 앞두고 최대한 족보 보면서 교수님 문제 유형에 익숙해질 것 공학수학처럼 매주 퀴즈 보는 경우 퀴즈 내용도 따로 모아서 정리할 것📚 알고리즘 굿노트로 필기한 내용 위주로 이론 복습 이론 기반으로 백준/프로그래머스 등 코딩테스트 유형 별 문제풀이 진행 (하나의 이론 당 적어도 5개 이상) 나간 진도로 구분하기보단, 알고리즘 유형 별로 구분해서 복습 내용 및 문제풀이 블로그 포스팅 강의 녹화본이 사캠에 올라오므로 최대한 교수님 설명을 내 설명으로 풀어낼 수 있도록 참고할 것📚 고급전자회로실험 최소 실험 강의는 이틀 전에는 듣기, 실험 전에 레포트 족보 보고 실험 흐름 파악하기 보고서는 최대한 실험 진행 당일 밤~다음날 오전 안쪽으로 작성해서 제출할 것 미리 프로젝트 족보 읽어보기📚 디자인프로젝트 팀원들끼리 정한 시간대에 일주일마다 꾸준히 참여하는 게 중요 노션, 깃헙으로 프로젝트 관리 효율적으로 수행하기대충 현실적으로 할 수 있을 것 같은 수준으로 공부 계획을 정리해 봤다.아직 수강신청 변경 기간이 남아 있어서 저 위의 과목들 중에서 드랍하거나 추가되는 과목이 생기면 게시글 수정으로 반영하려고 한다.비대면 수업을 3학기째 들으면서 느끼는 점은,비대면이라고, 그리고 고학번이라고 해서 무조건 공부에만 매달리는 것은 오히려 동기부여를 깎아먹는 길이라는 것이다.쉴 때 쉬고, 거리두기 조심하면서 밖에도 좀 다니고 해야 오랫동안 꾸준히 공부 의지를 유지할 수 있을 것 같다.(물론 수업 시간에 집중하는 것을 당연히 전제로 한 다짐이다)이번 학기 과목들 위에 세운 목표대로 후회 없이 잘 마무리하고디자인프로젝트도 꾸준히 시간 분배해서 결과물보다도 과정에서 스스로 얻어가는 게 많았으면 좋겠고그 와중에도 시간 조금씩 할애해서 여름방학 때 부족했던 DIP, ML 공부들 다시 정리하는 것까지 할 수 있다면더 바랄 것도 없이 최고로 뿌듯한 한 학기가 될 수 있을 것 같다.화이팅!🤩" }, { "title": "📚 2021년 여름방학을 마치며...", "url": "/posts/end-2021-summer/", "categories": "life", "tags": "2021년", "date": "2021-09-02 00:29:00 +0900", "snippet": "지금까지 보냈던 방학 중에서 가장 이것저것 많이 해보려 노력했던 2021년의 여름방학이 끝났다.내일이면 벌써 개강.. 이 아니고 글을 여러번 수정하다 보니 지금 시점으로 벌써 개강 둘째날 새벽이다 🥲사실 방학 회고록과 새 학기를 시작하는 다짐을 혼자 여행 가서 생각을 정리하면서 작성하고 싶어서여행 계획도 세워 놨는데, 여러 가지 이유로 결국 가지 못한 채 학기를 맞이하게 됐다.근데 비대면 수업이기도 하고, 한 3일 정도 혼자 쉬다 올 생각이라 9월~10월 중으로 미룬 거라서 별로 아쉽지는 않다.어쨌든… 이번 학기 돌아보면 매주 기한에 맞춰 주어진 과제들을 수행하느라 바빴는데마무리하고도 정리 겸 결산을 못한 과제도 있고 아예 아직 마무리하지 못한 것들도 있고 잔뜩 늘어뜨려 놓은 느낌인 것 같아새 학기를 시작하기 전에 스스로 정리하는 계기가 필요하다고 생각해 글을 쓰게 됐다.💻 디자인프로젝트 대비 DIP 세미나 진행 (6-23 ~ 7-15)2학기 디프 연구실을 방학 때 미리 배정받았는데, 다른 랩들과 비교해서 내가 배정받은 연구실이교수님도 열의가 많은 분이시고 석사 형들도 상당히 학부생들한테 시간을 많이 써주시는 편이었다.우리 연구실이 영상처리 기술을 많이 다루는 만큼 디프 주제 선정 및 진행을 위해서는 기초적인 지식부터 익힐 필요가 있었는데우선적으로 DIP(Digital Image Processing)에서 중요하다고 생각되는 내용들을 커리큘럼으로 꾸려 4주동안 세미나를 진행했다.발표 방식은 학부생 7명 모두가 발표를 준비하지만, 실제로 발표는 직전에 3명만 랜덤으로 뽑아서 시키며,자신이 뽑힐 지 모르기 때문에 일단 모두가 발표 준비는 100% 되어 있어야 하는 구조였다.첫 주차 발표 준비에 다소 미흡했던 관계로 제발 제비뽑기에 걸리지 않기를 기도했는데,다행히 뽑히지는 않았지만 발표자들을 향한 다소 직설적이고 공격적인 피드백에 좀 놀랐던 기억이 있다.당연하지만, 방학이 끝나는 시점에서 되돌아 보면 적극적인 피드백 덕분에 나를 포함한 학부생들이 많이 성장할 수 있었던 것 같다.영어로 발표를 준비하면서 학술적인 용어에 신경써보기도 하고어떠한 결과에 대해 이렇게도 접근할 수 있을까 다양하게 접근해보는 훈련이 되었던 것 같다.사실 DIP 세미나가 특히 중요했던 점은, 나를 뺀 나머지 6명 학부생 동기들은 전부1학기에 개설된 DIP 과목을 수강하고 왔기 때문에 사실상 한번 들은 내용을 복습하는 것이나 다름없었고나는 아예 처음 접하는 내용이었기 때문에 두 번, 세 번 해보며 익숙해질 필요가 있었다.그럼에도 아쉽게도 2주차까지 Affine Transformation, Morphology, Frequency Domain Filtering 정도만 다루고현대모비스 SW 교육 프로그램에 참여하게 되어 나머지 2주차 분량의 세미나는 직접 해보지 못한 채 마무리했다.2주차까지 진행한 내용 중에서도 Thresholding같이 사실상 구현을 제끼고 넘어간 부분도 있어서 개운하지 않은 채로 마무리한 것 같다.🚘 현대모비스-서강대 SW 사전교육 프로그램 2기 참여 (7-19 ~ 7-30)7월 중후반부터 약 2주 동안 현대모비스에서 서강대학교 학생들을 대상으로 진행하는 SW 교육 프로그램에 참여했다.1주차에는 파이썬 기초 문법을 다룬 뒤 Nvidia Jetson을 이용해 딥러닝 환경을 구축하고, 데이터셋 확보 및 전이 학습을 진행했다.2주차에는 배운 내용을 기반으로 현대모비스에서 제시한 4개의 주제 중에서 하나를 골라 프로젝트를 수행해 봤다.나는 4개의 주제 중 “자동차 인식” 혹은 “교통표지판 인식”을 다루어 보고 싶었는데실질적으로 기한 안에 마치지 못할 것 같아 가장 기초적인 “손글씨 인식”으로 프로젝트를 진행했다.사실 교육을 시작하기 전에 기대도 많이 했고 주제 선정에도 욕심을 부리고 싶었는데,실제로 학습을 진행하면서 시간 관리도 실패했고 다시 선택한 주제조차도 생각한 만큼 하지 못해서 많이 아쉬운 부분이다.특히, SW 사전교육을 마치고 다시 연구실로 복귀해서 ML 세미나를 2주 진행했는데사전교육 전에 ML 공부를 좀 하고 갔으면 최소한 학습의 전체적인 원리를 이해하고좀 더 많은 것들(Layer 구성 추가, Model의 Hyperparameter 변경 등)을 시도해볼 수 있었을 것 같아서 많이 아쉬웠다.💻 디자인프로젝트 대비 ML 세미나 진행 (8-3 ~ 8-19)8월부터는 2주차 정도로 주제를 구성해 디프 연구실에서 ML 세미나를 진행했다.개인적으로 이번 방학에 수행했던 것 중 가장 인상깊었던 과제였는데쌩 기초 단계부터 머신러닝, 그리고 딥러닝의 정의와 원리를 알아볼 수 있어서 좋았다.특히 바로 직전에 현대모비스 교육에서 교육기간 상 학습이 진행되는 원리에 대해 다루지 않고 넘어갔기 때문에내가 돌렸던 코드들이 가지는 의미를 다시 이해할 수 있어서 더 소중하게 느껴졌던 것 같다.딥러닝에는 예전부터 관심이 많았어서 네이버 부스트코스 등을 이용해 개인적으로 공부하려고 시도는 했었지만정말 아래 단계서부터 개념을 제대로 확립하고 싶어 공부할 시간를 확보하지 못하고 있었는데이번 ML 세미나가 MLP부터 CNN에 이르기까지의 기초 딥러닝 개념들을 잘 정리할 수 있었던 계기가 된 것 같아 뿌듯하다.물론 그렇다고 해도, Gradient Descending이나 Backpropagation 등의 개념에 대해서는아직 이해가 부족하다고 생각되기 때문에.. 틈 나는 대로 다시 블로그에 정리한 내용을 포스팅할 생각이다.마치는 글..위의 3개를 대표적으로 적어놨지만 사실 저 와중에도 일주일에 10시간 이상씩 교내 근로도 다니고연구실에도 의무 출근하면서 정말 바쁘게 시간을 보냈던 것 같다.이번 방학을 마치면서 스스로 반성하는 점이 많지만 하나로 요약하면“해야 할 때 100%를 쏟아 붓고, 이미 끝난 것에 미련 가지지 않기” 인 것 같다.맨 처음 DIP 세미나를 진행하면서 처음 접하는 개념들에 대해 너무 겁먹고 적극적으로 찾아보려 하지 않았던 게 후회된다.결과적으로 해당 주차까지 끝났어야 하는 내용이 부족하자내 성격 상 다음 주차로 나가지 못하고 이전 주차 내용을 뒤늦게 커버하기에 급급했고,결과적으로 세미나 일정을 다 소화하고도 뭔가 개운하지 않은 느낌이 남아있다.어떻게든 중요하다고 생각한 특정 주제들만이라도 뽑아서 개강 전까지 좀 다뤄보려고 했는데디프 주제 선정 및 제안서 작성도 일정이 여유롭지 않아서 이마저도 하지 못한 채 개강했다.어쩌면 지금까지 보낸 학기 중 가장 바쁜 학기를 앞두고, 이젠 완벽하게 마치려는 습관을 좀 버리고엉성해도 어떻게든 작은 부분부터 완성하려고 하는.. 그런 마음가짐으로 접근해야 하지 않을까 싶다.오히려 그렇게 하는 편이 결과적으로는 더 완성도 있게 마무리할 수 있을 것이라고 생각한다.어쨌든, 좋았던 것들도 아쉬웠던 것들도열심히 살았던 여름방학을 뒤로 하고다시 한 학기 동안 화이팅!!😃" }, { "title": "🐍 Anaconda 정의, 주요 명령어 정리", "url": "/posts/what-is-anaconda/", "categories": "coding, python", "tags": "anaconda, conda, python", "date": "2021-08-03 03:51:00 +0900", "snippet": "이번에 디자인프로젝트 대비 DIP 세미나를 마치고 딥러닝 세미나 주차에 들어가면서 다시 파이썬을 다룰 일이 더 많아졌다.이전에는 파이썬 가상환경은 그나마 virtualenv로만 다뤄봤는데 연구실 멘토분들께서 Anaconda로 환경 세팅하는 걸 알려주셨다.Anaconda의 존재와 편리함은 알고 있었지만 파이썬을 깊게 팔 계기가 없어서 그냥 필요할 때마다 pip만 사용했는데…그래서 이참에 명령어를 좀 정리해 보기로 했다.🐍 Anaconda?Anaconda는 쉽게 생각해서 파이썬 라이브러리 패키지를 관리해 주고 환경 설정을 도와주는 서비스이다.이렇게 말하면 pip와 뭐가 다르냐… 고 할 수도 있겠지만, Anaconda는 각각의 실행 환경을 분리할 수가 있다.예시를 들면, 내가 파이썬을 사용해 A라는 작업과 B라는 작업을 할 때, A와 B의 패키지 환경을 독립적으로 관리할 수 있다는 뜻이다.이러한 특징은 프로젝트 단위 코드가 복잡해질수록 생길 수 있는 의존성 충돌 문제를 방지해준다는 점에서 굉장히 편하다.뿐만 아니라 자체적으로 패키지들을 버젼 별로 배포한다는 점도 사용하기 편리한 장점이다.💻 설치https://www.anaconda.com/products/individual#download-section설치는 크게 건드릴 것 없이 안내해 주는 대로 따라가면 된다.Mac OS 기준으로도 pkg 파일로 제공되므로 편리하다.🔨 기본적인 명령어# anaconda 버젼 확인conda --version# anaconda 버젼 업데이트conda update --allconda update -n base -c defaults conda# base 가상환경 자동 실행 해제conda config --set auto_activate_base falseAnaconda가 잘 설치되었다면 터미널에서 앞에 (base) 라는 표시가 생겼음을 확인할 수 있다.이는 현재 base(= 기본) 가상환경이 실행되었다는 것을 의미한다.만약 터미널 실행 시 자동으로 base 가상환경이 실행되는 것을 방지하려면 auto_activate_base 옵션을 false로 지정하면 된다.# 새로운 가상환경 생성conda create -n [가상환경 이름]# 파이썬 버젼을 명시해 주면서 가상환경 생성conda create -n [가상환경 이름] python=[파이썬 버젼]# 생성된 가상환경 복제conda create --clone [복제되는 가상환경 이름] -n [새로운 가상환경 이름]# 생성된 가상환경 세팅 목록 확인conda env listconda info --envs# 생성된 가상환경 삭제 (패키지 포함)conda remove -n [가상환경 이름] --allAnaconda 명령어들은 대부분 conda로 시작하며, 용도에 따라 추가로 뒤에 argument가 붙는다.conda create -n [가상환경 이름]으로 새로운 가상환경을 생성할 수 있으며conda env list를 통해 생성한 가상환경 목록을 확인할 수 있다.(-n 옵션은 풀어서 쓰면 --name을 의미한다.)# 가상환경 활성화conda activate [가상환경 이름]# 가상환경 비활성화conda deactivate# 가상환경 삭제conda env remove -n [가상환경 이름]# 가상환경 세팅 파일로 추출conda env export &gt; [파일 이름.yml]conda env export -n [가상환경 이름] -f [파일 이름.yml]# 추출된 가상환경 세팅 파일을 토대로 가상환경 생성conda env create -f [파일 이름.yml]activate와 deactivate를 통해 가상환경을 활성화하거나, 또는 비활성화할 수 있다.보통 비활성화하는 경우는 해당 가상환경이 활성화된 상태에서 주는 명령이므로 이름 없이 deactivate로만 준다고 보면 될 것 같다.추가적으로 export로 설정한 가상환경 세팅을 내보내기 할 수 있는데,이렇게 생성된 파일을 -f 옵션과 함께 넘겨주면 세팅 그대로 가상환경을 새롭게 생성한다.(+ 어쩌다 보니까 안 사실인데, A 환경을 activate 시킨 후 B 환경을 덮어씌우듯이 activate 시키면추후 deactivate 시 A 환경으로 돌아가게 된다. 자세한 이유는 찾아봐야 알 것 같긴 함..)🗂 패키지 설치 관련 명령어# anaconda 저장소에 패키지가 존재하는지 검색하기conda search [패키지 이름]# 현재 가상환경에 패키지 설치conda install [패키지 이름]# 특정 가상환경에 패키지 설치conda install -n [가상환경 이름] [패키지 이름]# 설치된 패키지 삭제conda uninstall [패키지 이름]pip를 사용해서 패키지를 설치해 본 경험이 있다면 anaconda를 이용한 방식도 거의 비슷하다는 것을 느낄 수 있다.다만, 가상환경별로 패키지가 분리되어 설치되는 방식이므로, 서로 엉킬 수 있는 문제를 방지해 준다.# 현재 가상환경에 패키지 설치conda install [패키지 이름]# 버젼 명시해서 패키지 설치conda install [패키지 이름=버젼 이름]# Dependency 없이 패키지만 설치conda install --no-deps [패키지 이름]conda search [패키지 이름] 명령어를 통해 확인하면 conda 저장소에 패키지의 여러 버젼이 존재하는 것을 확인할 수 있다.버젼을 지정하는 경우는 =를 이용해 명령어 옵션을 줄 수 있으며, 생략된 경우 적절한 버젼을 자동으로 선택한다.📒 5. 주요 패키지 설치 관련 팁위에 설명한 대로 conda install ...을 통해 패키지를 설치할 수도 있지만,가장 문제 없이 원하는 패키지를 설치할 수 있는 방법은 구글에 conda install [패키지 이름]을 검색해 보는 것이다.anaconda.org로 이어지는 검색 결과가 있으면 가장 참고하기 편하고,아니면 패키지 공식 레퍼런스 문서 쪽에서도 설치 명령어를 명시해 준 경우가 많다.# numpyconda install -c anaconda numpy# matplotlibconda install -c conda-forge matplotlib# pandasconda install -c anaconda pandas🔥" }, { "title": "📚 2021년 봄학기를 마치며... (아쉬운 점 / 잘한 점)", "url": "/posts/end-2021-spring/", "categories": "life", "tags": "2021년", "date": "2021-06-28 16:19:00 +0900", "snippet": "오랜만에 포스팅..굉장히 오랜만에 블로그 포스팅을 올린다.마지막으로 올렸던 글이 3월 중순 쯤 세운 공부 계획 글과, 클라우드 서버 세팅 관련한 글이었는데전공 공부와 실험에 휩쓸려 허우적대다가 겨우 정신차려 보니 마법처럼 세 달이 통째로 사라진 기분이다.그럴 사람은 없겠지만.. 그럼에도 혹시 내 블로그 글을 정주행하는 사람이 있다면,바로 전 포스팅을 읽고 이 포스팅을 읽음으로써 무언가 이상한 기분을 느낄 수 있을 것이다.그렇다. 나는 학기 초 알차게 세운 목표들(포트폴리오 개발, 정기적인 CS 관련 복습 포스팅 등)을 대부분 수행하지 못하고시간에 쫒겨 한 학기를 🤢삭제🤢 하고야 말았다…3월 초 야심차게 몇 가지 목표를 세웠었다.그 중에는 포트폴리오 사이트 개발과 같이 (A)이번 학기에 꼭 해내야 하는 일으로 분류한 목표도 있었고, 지난 학기에 배운 전공 과목 / 이번 학기에 배우게 될 전공 과목들에 대한 정기적인 복습 내용 포스팅과 같이 (B)생활하면서 꾸준히 지키고자 했던 목표 등으로 분류해 놓은 목표도 있었다.하지만 결과적으로 이렇게 정해 놓은 분류가 무색하게대부분의 목표들을 (F)일단 바쁘니까ㅋㅋㅋ 이 레포트까지만 내고 남는 시간에 하는 목표 로 밀어 놓게 돼 버린 것이다.어쨌든 여름 계절학기도 수강하지 않게 됐고, 디자인프로젝트 관련 연구실 첫 출근까지는 며칠 시간이 있어서숨을 돌리는 김에 왜 이렇게 되어 버린 것인가 / 그럼에도 이번 학기에 얻은 것은 무엇인가에 대해 변명 및 고찰을 해 보기로 했다.😥 아쉬운 점1) 나는 4학년 1학기 / 공대 복수전공 / 실험 두 개의 바쁨을 간과했다.나는 내가 세운 목표들이 학기 커리큘럼을 고려했을 때 결코 그럭저럭 하며 넘어갈 수 있는할 수 있는 목표라고는 생각하지 않았다.오히려, 매우 힘들 것임을 어느 정도 예상했고 평소에 하던대로 세부적인 목표로 나누어 여러 마리 토끼를 동시에 잡고자 했다.하지만, 토끼가 되어 잡혀버린 건 나였다.정신차려 보니 맨 위의 짤처럼 실험 보고서를 일주일에 무지성으로 세 개씩 써제끼느라 손만 움직이는 시바🐶새끼가 되어버린 것이었다.일주일마다 전자회로실험 예비보고서, 결과보고서, 마이크로프로세서응용실험 결과보고서, 격주로 장론 과제와 전자회로 과제,어셈블리 과제 및 퀴즈 준비를 하다 보니 일주일 내에 남는 시간은 없었고 오히려 마이너스가 되어버렸기 때문에일주일에 1~2일은 평균적으로 밤을 새며 몸 상태도 박살났다.이런 생활 속에서 주어진 것들을 모두 제출하는 것은 고사하고 개인적인 목표들을 위해 시간을 쪼개 쓴다는 것은사실상 불가능한 것이나 다름 없었던 것이다. 이는 더 이상 열심히 하고 덜 열심히 하고의 문제가 아니었다.(이 모든 글이 변명처럼 들릴 수도 있지만 변명을 적는 포스트기 때문에 잘 들은 것이라고 할 수 있다)2) 통학 과정에서 너무 많은 시간/체력을 낭비했다.통학한 지 4년차 되는 시점에서 새삼스럽게 무슨 엄살이냐고 할 수도 있겠지만,통학 과정에서 낭비되는 시간들을 뼈저리게 느낀 것 또한 이번 학기였다.보통 어셈블리 퀴즈나 마프실 보고서 등 장기간 집중이 필요한 공부가 필요할 때면 학교의 남는 강의실에서 밤 늦게까지 공부하곤 했는데,똑같이 공부한 친구들과 비교해 보면 그 친구들은 15분 거리의 자취방으로 향해서 잠을 자고 다음날 아침 8시 도서관으로 복귀하기까지어림잡아 1시간 정도의 잉여 시간이 발생하는데, 반면에 나는 이동부터가 편도 1시간 반씩 걸리다 보니 집에 도착해서 30분 정도 씻고강아지 밥을 주는 순간 아침에 제 시간에 도서관을 도착하기 위해 출발해야 하는 시간까지 3시간이 채 남지 않은 초유의 사태가 발생하는 것이었다.이러한 현상은 시험기간에 더 심해지는데, 밤을 새고 나면 집에 도착해서 시험을 보고 다음 시험을 준비하기 위해 약 1시간 반 정도 자고학교로 와야 했기 때문이다. 이런 생활을 2달 가까이 했던 시점에는 정신이 나가서 학교의 모 P 건물에서 36시간 정도를 노숙한 적도 있었다.(이 문단이야말로 정말 찐 변명처럼 들리는데, 어쨌든 이번 학기의 아쉬운 점을 사실적으로 적기로 했으니까 일단은 계속 적어 보기로 하자.)3) 학기 중간에 내 스스로를 되돌아 볼 시간이 없었다.위의 아쉬운 점 #1과 #2가 바쁘게 지낼 수 밖에 없었던 이유라고 한다면,아쉬운 점 #3는 학기를 끝내고 느끼는 허무함에 대한 원인이라고 할 수 있다.전회실과 마프실이 본격적인 실험 주차로 진입한 3월 중후반부터 위와 같은 생활이 시작되었고중간고사 주차를 제외하고서는 계속 무언가 하고 있지 않거나 하루에 적어도 뭔가 하나를 제출하지 않으면 마음이 불안해지는 그런 시간들을 보냈다.내 스스로를 되돌아 볼 시간이 없었다는 말이, 너무 거창한 생각까지 가지 않아도 “일단은 이 레포트까지만 내고 생각하자”,“일단은 다 제쳐두고 이 과제를 기한에 못 맞추면 😀된다” 이런 생각들을 하면서 숨 참고 학기를 바쁘게 끝내고 나니순간마다 내가 무얼 짚고 넘어가려고 했는지를 잊어 버렸기도 하고…학기를 어쨌든 마치기는 마쳤지만 원하는 학점보다는 낮게 나올 것 같아서 허탈함도 느껴지는그런 생각들이 종합적으로 합쳐져서 이런 기분이 느껴지는 것 같다.그리고.. “바쁘긴 했지만 정말 이 정도로 다른 걸 포기하면서까지 공부에만 집중했어야 했을까?”“혹시 덜 바쁘면서 공부 + 다른 추가적인 개인적인 목표들도 성취할 수 있었음에도 내가 시간을 덜 쪼개 쓴 게 아닐까?” 싶은 생각들도 든다.어쨌든 이제 숨을 돌릴 수 있으니까, 털어놓자면 분명 어딘가 내 생활 패턴에 개선할 점이 존재할 것이다.위와 같은 생각들이 들었다는 것 자체가 내가 내 스스로 뭔가 떳떳하지 못했다는 점을 느꼈기 때문이라고 생각한다.🙂 잘한 점1) 정신없이 보냈지만 헛되이 보내지는 않았다.이번 학기를 다 끝내고 나서 유난히 아쉬웠던 점들이 먼저 생각이 났지만, 분명 잘했다고 생각한 부분들도 있었다.그 중 하나는 바쁘게 보낸 만큼 얻은 것도 굉장히 많이 있었다는 것이다.1학기에 가장 많은 시간을 투자했던 과목은 마이크로프로세서개론 + 마이크로프로세서응용실험인데사실상 두 과목이 연계과목 같은 느낌으로 개론에서 익힌 이론을 실험에서 코드로 구현하도록 커리큘럼이 짜여져 있었다.보고서를 낸 첫 주 30장으로 시작해, 매 주마다 40장 가까이 되는 실험 보고서들을 써내면서 가장 많은 시간을 할애한 과목이었다.보고서에서 요구하는 인터럽트와 Serial 통신, Timer 등의 기능을 구현하기 위해 자세하게 정리된 실험 STEP을 따라가다 보면매 주마다 기본 10시간 정도씩 쏟아부을 수 밖에 없었지만, 끝내고 나니 해 본 만큼 전부 내 것으로 만들었다는 생각이 든다.어셈블리 프로그래밍 같은 경우도 2주에 한 번씩 과제를 제출하고, 막바지에는 실기 시험 준비까지 해서 코딩하는 데에 시간을 많이 투자했다.물론 강의자료도 파일 별로 필기를 다 받아 적었고 5번씩은 돌려 봤을 정도로 수업 자체에 많이 집중하긴 했지만,실제로 그 내용을 익히고 어느 정도 내가 설계한 구조를 표현하는 데 능숙해진 것은 과제하느라 들인 시간이 결정적이었다고 생각한다.어셈블리같은 경우 학점은 중간보다 좀 떨어져서 약간 아쉽긴 하지만ㅜㅜ 오히려 학점과 별개로 만족스럽게 느껴지는 점은x86 아키텍처나 명령어 구조에 대해 배운 게 많이 남았다는 생각 덕분일 것이다.원래 수업 내용을 주기적으로 블로그 포스팅을 통해 복습하고 싶었으나 결국 계획대로 하지 못한 것에 대해서 아쉽다는 생각을 했지만,오히려 전체 수업에 대해 딱 정리된 학기가 끝난 시점에 마무리 복습 느낌으로 포스팅을 진행하면어차피 중요하다고 생각했던 수업들에 대해서는 내용을 다 기억하고 있기 때문에 계획했던 복습을 어느정도 커버할 수 있을 것 같다는 생각도 든다.2) 바쁜 만큼 이것저것 많이 시도해 볼 수 있었다.어쩌면 지금 느껴지는 허무함이 뭔가 놓친 게 많아서 느껴지는 것이라기보단그 동안 생체 리듬이 2~3시간씩 자고 바쁘게 움직이고 하는 것들에 맞춰져 있어서 갑작스럽게 주어진 휴식 때문에 느끼는그런 긍정적인 허무함이 아닌가 싶은 생각도 든다.위에 공부에만 집중하느라 세운 세부적인 추가 목표들을 잘 수행하지 못했다고 적었지만, 전부 다 놓고 있지는 않았다.이번 학기 복수전공하면서 작정하고 전자공학쪽의 전공 선택을 다 채워버리겠다는 생각으로 6전공 (2실험)을 들은 와중에도중간중간마다 SW 기업 인턴이나 대학생 대상 프로그래밍 대회에 지원하면서 코딩 테스트 경험도 몇번 접해봤고,디자인프로젝트 관련 연구실 면담도 다녔고 여기에 교내 근로 아르바이트까지 꾸준히 다녔으니까나름 현실적인 상황에 대해서는 해보고 싶은 건 다 해보면서 보냈다는 생각이 든다.다음 학기부터 하나 개선하고자 하는 점은 모든 기회를 잡으려고 하기보다, 중요하다고 생각되는 몇 개의 기회에 좀 더 집중하면 좋을 것 같다는 점이다.마치는 글..위에도 적었듯이, 이 글을 쓰기 시작한 시점에는 학기가 딱 끝나고 3일 정도 주어진 휴식 시간동안 다 쓰겠지 생각하고 쓰기 시작했는데어느덧 글을 마무리하는 시점에는 벌써 연구실에 출근해 있다.그만큼 학기를 마무리하면서 든 생각들이 많아, 정리하는 데 예상보다 시간이 걸렸던 것 같다.어쨌든, 학기는 끝났고 지나간 시간은 돌릴 수 없으니까 아쉬운 점은 되새기고 넘어가고 잘했던 점에 집중해서 나를 더 가꾸어보고자 한다.방학을 막 시작했지만, 어차피 아르바이트 다니고, 연구실 다니면 월화수목금 중 하루 빼고는 매주마다 학교에 갈 것 같다.매주마다 주어진 세미나 주제를 정리하고 개인적으로 생각하고 있는 IOS 애플리케이션 개발과 포트폴리오 개발 등을 고려하면거의 이번 방학은 1.5학기처럼 보내게 될 것 같다…어차피 나는 한가한 걸 더 견디기 힘들어하는 성격이라는 걸 알기 때문에.. 이왕 바쁜 거 효율적으로 바쁘게 보내고 싶다ㅎㅎㅎ😎" }, { "title": "☁️ Naver Cloud Platform Micro 타입 서버 생성", "url": "/posts/naver-cloud-platform/", "categories": "projects, web portfolio", "tags": "naver cloud platform", "date": "2021-03-13 18:34:00 +0900", "snippet": "클라우드 플랫폼 신청4월 안쪽으로 포트폴리오를 웹상에 띄워 놓기로 염두에 두고 있었는데,메일로 구독하고 있던 노마드 코더에서 포트폴리오 챌린지를 3월 28일까지 진행한다고 해서급히 시작하려고 서버 인스턴스 생성부터 들어갔다.군대에서 신청한 AWS 1년 무료 체험이 끝나 있어서 다른 계정으로 만들까 아니면 구글 클라우드 플랫폼으로 해볼까 고민했는데,일단 서버 쪽 지식이 거의 없어서.. 당장 한글 레퍼런스가 잘 설명되어 있는 네이버 클라우드 플랫폼으로 해보기로 결정했다.여기도 신규 가입한 경우 10만원치 크레딧과 1년 무료 서버를 제공한다.(Micro 타입으로 생성할 경우에 한해서)인스턴스 생성 과정Micro 타입 서버로 선택하면 사실상 서버 생성 과정에서 선택할 항목은 거의 없다.인증서를 다운받아 잘 보관해 두고 계속 진행한다.수 분 내에 서버가 생성된다고 하는데, 나 같은 경우는 5분 안쪽으로 생성 알림 메일이 도착했다.다음으로는 공인 IP 신청을 해야 한다. 공인 IP는 한 달 기준으로 4,032원씩 요금이 결제된다.포트포워딩도 설정한다.캡쳐는 하지 않았는데 ACG 설정도 일단 몇 개 포트에 대해서 추가로 설정했다.필요한 설정 마무리하고 터미널로 접속한 모습..이제 홈페이지 배포하려면 이것저것 깔고 삽질 해야할듯 🔥참고한 링크 전체적인 과정이 잘 설명되어 있는 블로그 NCP Documentation" }, { "title": "📚 2021년 봄학기의 공부/복습 플랜", "url": "/posts/study-plan-spring-2021/", "categories": "life", "tags": "2021년, study", "date": "2021-03-10 20:55:00 +0900", "snippet": "이번 방학은 코로나 때문에 대부분 실내에서 보내서 유난히 더 아쉬움이 남는 듯… 그래서인지 개강도 적응이 잘 안 된다.또 4학년인데도 친구들은 교양 섞어서 3~4과목 들을 때 나는 복수전공 때문에 실험과목도 2개 껴있기도 하고… 😫그래도 떼 써 봐야 바뀔 건 없으니 일단은 빨리 학기에 적응하고 이번 학기의 공부 루틴을 정해야 한다.나는 내가 공부하는 데 가장 중요하게 작용하는 게 무엇인지 안다. 그건 바로 계획 설정이다.중학교 때부터 쓰기 시작했던 일정 관리 리스트 포맷도 있고 나 스스로 계획을 세우는 것을 즐겨 하는 편이라고 생각한다.(지키는 것은 별개)그래서 공부하는 것도 계획을 짜서 일종의 목표처럼 설정해 놔야 성취감을 통해 수월하게 이어나갈 수 있었던 것 같다.📚 지난 학기의 공부 플랜2020년 봄학기를 시작으로 복학하면서 제대로 마음 잡고 공부하기로 다짐하고 나에게 맞는 여러 예습/복습 플랜을 시도해 봤다.그 중 2020년 가을학기에 포스트잇으로 구간을 나누고 한 주 단위로 모든 과목 대비 복습을 돌린 공부법이 제법 잘 맞았다.그러다가 지난 겨울방학 때 큰 맘 먹고 아이패드를 구입하고 나서 이제 A4 뭉치가 아닌굿노트 폴더 안에 모든 강의 자료와 필기를 관리하다 보니 저번 학기처럼 강의 일자 별로 구간을 나누기도 애매해지고… 해서저번 학기 플랜을 기반으로 몇 가지를 수정해 새로운 공부 플랜을 세웠다.📚 새로운 공부 플랜 예습을 굿노트 필기로, 복습은 블로그에 올리면서 정리 한 번 복습 주기는 일주일 단위 (주말) 전 학기에 들었던 중요한 과목들도 복습 및 포스팅 (컴퓨터 구조, OS, …) 일단 90%는 복습에 집중하되, 전자기학처럼 교수님께서 예습을 적극 권장하신 과목은대충 수업 전까지 전 수업 진도 페이지 x2 만큼의 예습 진도를 유지하려고 한다.또한, 수업을 듣고 난 과목에 대해서는 굿노트에 필기한 내용 중 중요 개념을 키워드로 한 제목의 복습 내용 포스팅을 올릴 계획이다.이번 겨울에 아이패드 필기에 익숙해질 겸 정보처리 기사 필기를 접수했고 공부한 과정에서 느낀 점은나는 매우 게으르기 때문에 무조건 목표를 잘게 쪼개서 세부 목표로 만들고 나서 공부해야 한다는 점이다.그래야 하루 중 1~2시간 단위로 남는 시간을 효율적으로 사용할 수 있기도 하고, 성취감도 들 것 같다.또한, 이번 학기에 듣는 어셈블리나 마이크로프로세서 등 과목이 저번 2020년 가을학기 과목들과 연결되는 내용이 있어서원래 겨울방학 때 OS나 컴퓨터 구조 등 해당 과목들을 다시 한 번 복습 진도를 빼려고 했는데…. 미처 손대지 못한 부분은이번 학기에 한 과목 정도 더 청강한다고 생각하고 복습을 진행할 예정이다.초수강때처럼 전부 커버할 생각은 아니고 인터럽트나 DMA 등 실제 이번 학기에 구현해야 하는 부분들에 대해서 집중적으로 보면 되지 않을까 싶다.🔥 화이팅!!이번 학기 온라인 강의가 별로 없고 거의 실시간 강의로만 구성되어 시간 배분이나 체력적으로 철저히 따라가야 할 것 같은데내가 모자란 부분에 대해서는 무조건 도서관에 상주하면서 다른 친구들보다 1.5배 이상 더 노력한다고 생각하고 해야 할 것 같다…학기 초 초심을 잃지 말고 꾸준하게 포스팅할 수 있었으면…!! 🥲" }, { "title": "☀️ 2021년을 시작하며...", "url": "/posts/start-2021/", "categories": "life", "tags": "2021년", "date": "2021-02-03 16:23:00 +0900", "snippet": "2021년을 시작하며 드디어 블로그를 오픈했다!!전역하고부터 필요성을 많이 느끼기도 했고 좀 더 일찍 시작했다면 좋았겠지만학기 중엔 도저히 시간이 나지 않아서ㅠㅠ블로그 자체를 처음 하는 것은 아니고, 초중딩 때부터 전자제품 이것저것 리뷰해온 네이버 블로그가 있었고이후 21살 때 대학생 서포터즈 대외활동을 참여하면서 리뷰나 활동 기록을 업로드하는 데 그대로 사용했다.예전에는 일기처럼 잡다한 이야기도 가끔 업로드하고 했던 것 같은데..이제는 소식 공유는 인스타그램, 일정 관리는 종이 공책에 기록하는 게 습관처럼 굳어져서 어느 순간부터 사용하지 않게 되었다.이제는 필요에 의해 다시 블로그를 시작하기로 했다.그렇게 결심하게 된 이유나 얻고자 하는 목적 등을 티스토리 양식을 익힐 겸 밑에 쭉 정리해 보려고 한다.. 😆📄 개발자로써의 커리어를 위한 기록, 포트폴리오이번에 6학기를 마치고 겨울 방학을 어떻게 보낼까 고민하다가 IT 기업들 체험형 인턴 공고에 4~5개 정도 지원했다.기업마다 지원 절차는 다르지만 공통적으로는 서류 지원 - 코딩 테스트 (N차) - 면접 (N차) 순서인데,대부분의 서류 지원 과정에서 포트폴리오 파일이나 링크를 첨부하도록 되어 있었다.내가 다른 지원자들에 비해 일찍부터 코딩을 시작했거나 특별한 프로젝트 경험을 여럿 해 봤다고 적어도증명할 포트폴리오가 없다면 아무 것도 하지 않은 것이나 마찬가지였다.사실 전역 이후부터 개발 기록을 남기기 위한 포트폴리오나 웹페이지 개발을 다짐하고 있었으나 미루고 있다가이번 방학에 필요성을 아주 절실히 느끼게 되어 늦게나마 이렇게 구색을 갖추고 시작해 보려고 한다.맨 처음에 구상하기로는&lt;프로젝트 및 포트폴리오 소개 + 개발 기록 포스팅&gt; 의 역할을 하는 단일 웹페이지를 개발하는 것으로 기획했으나,실질적으로 소요되는 준비 기간을 고려해서 최종적으로 포트폴리오 사이트와 개발 기록 포스팅 블로그의 형태로 나누었다.포트폴리오 사이트는 2월 내 1차적으로 개발을 마치고 도메인과 연결할 예정이며개발 기록을 포스팅할 블로그는 직접 개발하는 대신 현재 기록하고 있는 티스토리를 사용하기로 했다.만약 사이드 프로젝트를 진행한다고 하면 결과물 (+Git Repository 링크)는 포트폴리오 사이트에,프로젝트 개발 과정 및 개발 중간에 생긴 여러 가지 아이디어나 개발 이슈는 이 곳에 올리도록 할 계획이다.💾 스쳐 지나간 과제부터 사이드 프로젝트까지 아카이빙전자공학과 학부 과목을 들으면 고학년으로 올라갈수록 코딩을 필요로 하는 수업 과제들이 많다.그 중에는 작게 스쳐가긴 하지만 Intel SSE2를 이용한 SIMD 프로그래밍이나 Verilog를 통한 디지털 회로 설계 등혼자 독학했다면 미처 짚고 넘어가지 못했을 귀중한 경험들도 있었다.앞으로 그러한 과제를 습득하고 해결하는 과정에 대해서 1차적으로는 내가 공부하고 해결한 내용을 기억하기 위해서,2차적으로는 습득한 내용을 공유하기 위해, 중요하다고 생각한 내용을 포스팅할 예정이다.특히 지난 학기에 수강했던 운영체제나 임베디드 컴퓨터 아키텍쳐 같은 수업에서는중간마다 정말 중요하다 싶은 개념이나 이론들을 접했다.이와 같은 중요도 있는 수업 내용들 또한 정리해서 포스팅으로 공유하고자 한다.추가적으로 그 동안 내가 잘못 생각한 점이자 이번에 블로그 포스팅을 시작하면서 고치고자 하는 점을 한 가지 찾았는데,바로 너무 일정 규모 이상의 프로그래밍 작업만을 기록으로 남기려고 했다는 점이다.주변에서, 특히 전자공학과 친구들에게 다양한 아이디어에 대한 코딩 부탁을 받을 때가 많은데대표적으로 파이썬을 통해 엑셀 파일에 정리된 도로명주소 정보를 위/경도 변환을 통해 지도 상에 일괄 표시한다던지,주어진 PDF 파일을 페이지별로 분리해 특정 표의 부분을 제목명으로 하는 파일들로 생성한다던지 등이 있었다.이런 작업들이 실질적으로 새로운 라이브러리나 프레임워크를 익숙하게 사용하거나 에러 처리를 하는 데크게 도움이 되었음에도 일주일 혹은 며칠 이내에 단기간 진행하고 끝냄으로써 기록화하지 않았다.앞으로는 사이드 프로젝트는 물론 작은 작업에 대해서도 구현 이슈나 에러 해결 과정에 코드와 함께 아카이빙하고자 한다.✉️ 마지막으로…지금까지 썼던 자소서에 많이 들어간 내용인데, 나는 코딩을 초등학교 6학년 때 처음 접했다.그 당시 도서관이었는지 집 서재였는지는 기억나지 않지만, &lt;플래시 MX 2004 무작정 따라하기&gt; 와 비슷한 제목의 책을 우연히 발견했고굉장히 흥미가 생겼다. 당시 또래 친구들 중에서 야후 꾸러기나 쥬니어네이버 같은 서비스를 통해 플래시 게임을 접하지 않은 친구는 거의 없었다.그래서 그런 게임들을 하는 게 아니라, 만들 수 있다는 점이 굉장히 매력적인 목표로 다가왔다.추가로, 나는 부모님이 게임을 매우 싫어하셔서 유행이었던 카트나 메이플 같은 온라인 게임도 하나도 안 했기 때문에,할 수 없을 바엔 만들어나 보자😤!!! 라고 생각했던 것 같다.그때 당시 네이버에서 10만 회원 가까이 활동하는 제법 큰 플래시 카페가 있었는데중학교때까지 하루의 반을 거기서 보낼 정도로 프로그래밍에 빠져 살았다.거기서 훨씬 나이가 어린데도 강좌를 쓰는 사람들이나 코딩에 훨씬 능숙한 또래들을 보며 더 열심히 배워야겠구나 생각했다.기억에 남는 건 그때 Adobe Air라고 플래시 Actionscript 기반의 데스크톱, 혹은 스마트폰 애플리케이션 개발 프레임워크가 있었는데중학교 2학년 때 Air로 7초에 가깝게 스탑워치를 멈추는 게임을 만들어서 플레이스토어와 티스토어에 등록하고친구들이 찾아와서 추천평을 남겨줬었는데, 처음으로 직접 만든 무언가를 선보인다는 게 참 뿌듯했다.이후 부모님이랑 여러 번 싸운 후에 스스로 서울 용산에 찾아가서 선린인터넷고 원서를 넣었다.지금이야 운 좋게 대학을 다니고 있긴 한데 그 때는대학 진학을 포기하고 아예 프로그래밍에 매진하겠다 생각한 것이나 다름없었다.3년 동안 인문계에서 진학을 위해 공부하기보다 내가 좋아하는 것을 위한 시간을 보내고 싶었다.입학 전 겨울방학 C언어 교육부터 시작해 3년 동안 프론트엔드, 백엔드, 웹디자인, 네트워크, 애플리케이션 등많은 분야에 대해서 조금씩 익힐 수 있었다. 교내 대회나 교외 해커톤에도 몇 번 참여했었는데고등학교 때가 아마 지금까지 중 가장 순수하게 개발에 몰두했던 시간이었던 것 같다.여기까지 적고 보면 갑자기 뜬금없이 느껴지겠지만 나는 대학교 진학을 전자공학과로 정했다.주변 대학 친구들에게 수없이 많이 들었던 말이 “너는 왜 컴퓨터공학과가 아닌 전자공학과로 왔냐?” 였다.가장 솔직한 이유는 내가 접수했던 원서 전형에서는 전자공학과 지원이 합격에 더 유리했기 때문이고,일단은 입학 후 나중에 복수전공 제도로 컴퓨터공학을 추가로 전공할 수 있다고 생각했기 때문이다.고등학교 3년을 웹 프로그래밍 전공으로 보냈으므로 이미 알고 있는 것보다 모르는 분야를 배우고 싶다는 생각도 있었다.(아마 이 생각이 아니었다면 끝까지 고민하다가 컴퓨터공학으로 지원했을지도 모른다.)어느덧 4학년 1학기를 앞둔 지금, 돌아보자면 전자공학과로 입학한 것을 다행이라고 생각한다.사실 대학교 2학년까지는 개발에서 거리가 좀 있는 회로이론, 디지털회로 등 과목에 집중하며 진로에 대해 고민을 많이 했다.전자공학자와 개발자 사이에서 애매한 포지션을 갖고 어느 쪽에도 제대로 집중하지 못하는 게 아닐까 싶은 걱정이 있었다.지금은 많이 마음을 잡고 개발자 쪽에 좀 더 가깝게 커리어 방향을 정한 상태이다.하지만 그동안 전자공학과에서 배운 과목들, 앞으로 졸업하기 위해 들어야 할 전자공학 과목들이 버려지는 시간이 아닌나를 전자공학 또한 이해하는 특별한 개발자로 만들어 줄 것이라고 확신한다.다신 오지 않을 2021년, 25살의 1년을 시작하며,화이팅!! 🔥🔥" } ]
